/* --- Generated by PLIC-CxxStub --- */

// --- ClientHH Boilerplate ---
#include <plic/runtime.hh>

#include <rapicorn-core.hh> // for rcore/rapicornsignal.hh
using Rapicorn::Signals::slot;

// --- ClientCC/ServerCC Boilerplate ---
#include <string>
#include <vector>
#include <stdexcept>
#ifndef __PLIC_GENERIC_CC_BOILERPLATE__
#define __PLIC_GENERIC_CC_BOILERPLATE__

#define PLIC_CHECK(cond,errmsg) do { if (cond) break; throw std::runtime_error (std::string ("PLIC-ERROR: ") + errmsg); } while (0)

namespace { // Anonymous
using Plic::uint64_t;

static __attribute__ ((__format__ (__printf__, 1, 2), unused))
Plic::FieldBuffer* plic$_error (const char *format, ...)
{
  va_list args;
  va_start (args, format);
  Plic::error_vprintf (format, args);
  va_end (args);
  return NULL;
}

} // Anonymous
#endif // __PLIC_GENERIC_CC_BOILERPLATE__

#include <plic/cxxstubaux.hh>


#ifndef PLIC_CONNECTION
#define PLIC_CONNECTION()       (*(Plic::ClientConnection*)NULL)
Plic::uint64_t       connection_handle2id  (const Plic::SmartHandle &h) { return h._rpc_id(); }
static inline void   connection_context4id (Plic::uint64_t ipcid, Plic::NonCopyable *ctx) {}
template<class C> C* connection_id2context (Plic::uint64_t oid) { return (C*) NULL; }
#endif // !PLIC_CONNECTION


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

enum Empty {
};
inline void operator<<= (Plic::FieldBuffer &fb,  Empty &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, Empty &e) { e = Empty (frr.pop_evalue()); }

enum Enum1 {
  E1_A = 1,
};
inline void operator<<= (Plic::FieldBuffer &fb,  Enum1 &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, Enum1 &e) { e = Enum1 (frr.pop_evalue()); }

enum Enum1c {
  E1C_A = 1,
};
inline void operator<<= (Plic::FieldBuffer &fb,  Enum1c &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, Enum1c &e) { e = Enum1c (frr.pop_evalue()); }

enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
inline void operator<<= (Plic::FieldBuffer &fb,  Enum2 &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, Enum2 &e) { e = Enum2 (frr.pop_evalue()); }

enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
inline void operator<<= (Plic::FieldBuffer &fb,  Enum2c &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, Enum2c &e) { e = Enum2c (frr.pop_evalue()); }

enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
inline void operator<<= (Plic::FieldBuffer &fb,  Enum3 &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, Enum3 &e) { e = Enum3 (frr.pop_evalue()); }

enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
inline void operator<<= (Plic::FieldBuffer &fb,  Enum3c &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, Enum3c &e) { e = Enum3c (frr.pop_evalue()); }

enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
inline void operator<<= (Plic::FieldBuffer &fb,  Enum4a &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, Enum4a &e) { e = Enum4a (frr.pop_evalue()); }

enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
inline void operator<<= (Plic::FieldBuffer &fb,  Enum4b &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, Enum4b &e) { e = Enum4b (frr.pop_evalue()); }

enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
inline void operator<<= (Plic::FieldBuffer &fb,  Enum4c &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, Enum4c &e) { e = Enum4c (frr.pop_evalue()); }

enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
inline void operator<<= (Plic::FieldBuffer &fb,  Enum4d &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, Enum4d &e) { e = Enum4d (frr.pop_evalue()); }

enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
inline void operator<<= (Plic::FieldBuffer &fb,  ExtensiveEnum &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, ExtensiveEnum &e) { e = ExtensiveEnum (frr.pop_evalue()); }

class FirstInterface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class FirstInterface.
{
  static FirstInterface_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  static Plic::ClientConnection __client_connection__ (void);
public:
  template<class C>
  static FirstInterface_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      FirstInterface_SmartHandle ();
  void                          void_func                  ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const FirstInterface_SmartHandle&);
void operator>>= (Plic::FieldReader&, FirstInterface_SmartHandle&);

struct XFooRecord_Handle {
  bool                          single_bool;
  int                           single_num;
  double                        single_float;
  std::string                   single_string;
  int                           sibling1;
  int                           sibling2;
  int                           multi1;
  int                           multi2;
  int                           multi3;
  int                           multi4;
  ExtensiveEnum                 enum_field;
  FirstInterface_SmartHandle    iface1;
  FirstInterface_SmartHandle    iface2;
  FirstInterface_SmartHandle    iface3;
  Plic::Any                     any1;
  Plic::Any                     any2;
  Plic::Any                     any3;
  inline                        XFooRecord_Handle () { single_bool = 0; single_num = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
void operator<<= (Plic::FieldBuffer&, const XFooRecord_Handle&);
void operator>>= (Plic::FieldReader&, XFooRecord_Handle&);

struct XFooSequence_Handle : public std::vector<bool> {
  typedef std::vector<bool> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Plic::FieldBuffer&, const XFooSequence_Handle&);
void operator>>= (Plic::FieldReader&, XFooSequence_Handle&);

struct IntSequence_Handle : public std::vector<int> {
  typedef std::vector<int> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Plic::FieldBuffer&, const IntSequence_Handle&);
void operator>>= (Plic::FieldReader&, IntSequence_Handle&);

struct FloatSequence_Handle : public std::vector<double> {
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Plic::FieldBuffer&, const FloatSequence_Handle&);
void operator>>= (Plic::FieldReader&, FloatSequence_Handle&);

struct StringSequence_Handle : public std::vector<std::string> {
  typedef std::vector<std::string> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Plic::FieldBuffer&, const StringSequence_Handle&);
void operator>>= (Plic::FieldReader&, StringSequence_Handle&);

struct ExtensiveEnumSequence_Handle : public std::vector<ExtensiveEnum> {
  typedef std::vector<ExtensiveEnum> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Plic::FieldBuffer&, const ExtensiveEnumSequence_Handle&);
void operator>>= (Plic::FieldReader&, ExtensiveEnumSequence_Handle&);

struct RecordSequence_Handle : public std::vector<XFooRecord_Handle> {
  typedef std::vector<XFooRecord_Handle> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Plic::FieldBuffer&, const RecordSequence_Handle&);
void operator>>= (Plic::FieldReader&, RecordSequence_Handle&);

struct SequenceSequence_Handle : public std::vector<IntSequence_Handle> {
  typedef std::vector<IntSequence_Handle> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Plic::FieldBuffer&, const SequenceSequence_Handle&);
void operator>>= (Plic::FieldReader&, SequenceSequence_Handle&);

struct InterfaceSequence_Handle : public std::vector<FirstInterface_SmartHandle> {
  typedef std::vector<FirstInterface_SmartHandle> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Plic::FieldBuffer&, const InterfaceSequence_Handle&);
void operator>>= (Plic::FieldReader&, InterfaceSequence_Handle&);

struct AnySequence_Handle : public std::vector<Plic::Any> {
  typedef std::vector<Plic::Any> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Plic::FieldBuffer&, const AnySequence_Handle&);
void operator>>= (Plic::FieldReader&, AnySequence_Handle&);

struct NestedTypesRec_Handle {
  XFooRecord_Handle             rec;
  XFooSequence_Handle           seq;
  inline                        NestedTypesRec_Handle () { }
};
void operator<<= (Plic::FieldBuffer&, const NestedTypesRec_Handle&);
void operator>>= (Plic::FieldReader&, NestedTypesRec_Handle&);

struct NestedTypesSeq_Handle : public std::vector<NestedTypesRec_Handle> {
  typedef std::vector<NestedTypesRec_Handle> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Plic::FieldBuffer&, const NestedTypesSeq_Handle&);
void operator>>= (Plic::FieldReader&, NestedTypesSeq_Handle&);

typedef Plic::Any AliasAny;

typedef int AliasInt;

typedef double AliasFloat;

typedef bool AliasBool;

typedef std::string AliasString;

typedef XFooRecord_Handle AliasRecord;

typedef XFooSequence_Handle AliasSequence;

typedef ExtensiveEnum AliasEnum;

struct NewRecord_Handle {
  int                           i;
  Enum1                         enum1;
  XFooSequence_Handle           xfs;
  NestedTypesRec_Handle         ntr;
  inline                        NewRecord_Handle () { i = 0; enum1 = Enum1 (0); }
};
void operator<<= (Plic::FieldBuffer&, const NewRecord_Handle&);
void operator>>= (Plic::FieldReader&, NewRecord_Handle&);

namespace Inner {

struct InnerRecord_Handle {
  int                           x;
  int                           y;
  NewRecord_Handle              rec;
  inline                        InnerRecord_Handle () { x = 0; y = 0; }
};
void operator<<= (Plic::FieldBuffer&, const InnerRecord_Handle&);
void operator>>= (Plic::FieldReader&, InnerRecord_Handle&);
} // Inner

struct Refer2Inner_Handle {
  Inner::InnerRecord_Handle     r;
  inline                        Refer2Inner_Handle () { }
};
void operator<<= (Plic::FieldBuffer&, const Refer2Inner_Handle&);
void operator>>= (Plic::FieldReader&, Refer2Inner_Handle&);
} // MandatoryNamespace

namespace OtherNamespace {

struct SomeRecord_Handle {
  MandatoryNamespace::NewRecord_Handle r1;
  MandatoryNamespace::NewRecord_Handle r2;
  MandatoryNamespace::Inner::InnerRecord_Handle r3;
  MandatoryNamespace::Inner::InnerRecord_Handle r4;
  inline                        SomeRecord_Handle () { }
};
void operator<<= (Plic::FieldBuffer&, const SomeRecord_Handle&);
void operator>>= (Plic::FieldReader&, SomeRecord_Handle&);
} // OtherNamespace

namespace Auxdata {

typedef int bar;

typedef double x;

typedef std::string s;
} // Auxdata

namespace InterfaceTests {

class UIWidgetArea_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class UIWidgetArea.
{
  static UIWidgetArea_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  static Plic::ClientConnection __client_connection__ (void);
  typedef Rapicorn::Signals::SignalProxy<UIWidgetArea_SmartHandle, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::SignalProxy<UIWidgetArea_SmartHandle, double (UIWidgetArea_SmartHandle &ba1, int someint)> Signal_sample_signal;
public:
  template<class C>
  static UIWidgetArea_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      UIWidgetArea_SmartHandle ();
  double                        dummy    () const;
  void                          dummy    (double);
  std::string                   on_click () const;
  void                          on_click (const std::string&);
  Signal_void_signal&           sig_void_signal();
  Signal_sample_signal&         sig_sample_signal();
  double                        simple_method            ();
  double                        single_arg               (int n);
  double                        single_arg2              (int n = 5);
  double                        two_args                 (int n,
                                                          double r);
  double                        two_args2                (int n = 6,
                                                          double r = 7.7);
  double                        multi_args               (int n,
                                                          double r,
                                                          int i,
                                                          const std::string &s = "String ding",
                                                          double y = 5);
  double                        self_method              (UIWidgetArea_SmartHandle &ba1,
                                                          UIWidgetArea_SmartHandle &ba2);
  void                          void_method              ();
  std::string                   on_click2out             ();
  void                          on_click2in              (const std::string &command);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const UIWidgetArea_SmartHandle&);
void operator>>= (Plic::FieldReader&, UIWidgetArea_SmartHandle&);

class Parent_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class Parent.
{
  static Parent_SmartHandle     _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  static Plic::ClientConnection __client_connection__ (void);
public:
  template<class C>
  static Parent_SmartHandle     downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      Parent_SmartHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const Parent_SmartHandle&);
void operator>>= (Plic::FieldReader&, Parent_SmartHandle&);

class Child_SmartHandle : public Parent_SmartHandle
  /// See also the corresponding IDL class Child.
{
  static Child_SmartHandle      _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static Child_SmartHandle      downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      Child_SmartHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const Child_SmartHandle&);
void operator>>= (Plic::FieldReader&, Child_SmartHandle&);

class Descendant_SmartHandle : public Child_SmartHandle
  /// See also the corresponding IDL class Descendant.
{
  static Descendant_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static Descendant_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      Descendant_SmartHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const Descendant_SmartHandle&);
void operator>>= (Plic::FieldReader&, Descendant_SmartHandle&);

class GrandChild_SmartHandle : public Descendant_SmartHandle
  /// See also the corresponding IDL class GrandChild.
{
  static GrandChild_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static GrandChild_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      GrandChild_SmartHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const GrandChild_SmartHandle&);
void operator>>= (Plic::FieldReader&, GrandChild_SmartHandle&);

enum QuickEnum {
  ZERO = 0,
};
inline void operator<<= (Plic::FieldBuffer &fb,  QuickEnum &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, QuickEnum &e) { e = QuickEnum (frr.pop_evalue()); }

struct QuickRecord_Handle {
  int                           int1;
  int                           int2;
  inline                        QuickRecord_Handle () { int1 = 0; int2 = 0; }
};
void operator<<= (Plic::FieldBuffer&, const QuickRecord_Handle&);
void operator>>= (Plic::FieldReader&, QuickRecord_Handle&);

struct QuickSequence_Handle : public std::vector<double> {
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Plic::FieldBuffer&, const QuickSequence_Handle&);
void operator>>= (Plic::FieldReader&, QuickSequence_Handle&);

class QuickIface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class QuickIface.
{
  static QuickIface_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  static Plic::ClientConnection __client_connection__ (void);
public:
  template<class C>
  static QuickIface_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      QuickIface_SmartHandle ();
  void                          simple_function        (int i = 9);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const QuickIface_SmartHandle&);
void operator>>= (Plic::FieldReader&, QuickIface_SmartHandle&);

class MethodTestInterface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class MethodTestInterface.
{
  static MethodTestInterface_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  static Plic::ClientConnection __client_connection__ (void);
public:
  template<class C>
  static MethodTestInterface_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      MethodTestInterface_SmartHandle ();
  void                          method_with_void                ();
  bool                          method_with_bools               (bool input,
                                                                 bool optval = 0);
  int                           method_with_ints                (int input,
                                                                 int optval = -2);
  double                        method_with_floats              (double input,
                                                                 double optval = 309.9);
  std::string                   method_with_string              (const std::string &input,
                                                                 const std::string &optval = "default");
  QuickEnum                     method_with_enum                (QuickEnum input,
                                                                 QuickEnum optval = QuickEnum (0));
  QuickRecord_Handle            method_with_record              (const QuickRecord_Handle &input,
                                                                 const QuickRecord_Handle &optval = QuickRecord_Handle());
  QuickSequence_Handle          method_with_sequence            (const QuickSequence_Handle &input,
                                                                 const QuickSequence_Handle &optval = QuickSequence_Handle());
  GrandChild_SmartHandle        method_with_interface           (GrandChild_SmartHandle &input,
                                                                 GrandChild_SmartHandle &optval = *(GrandChild_SmartHandle*) NULL);
  Plic::Any                     method_with_anys                (const Plic::Any &input,
                                                                 const Plic::Any &optval);
  QuickIface_SmartHandle        method_with_quickiface          (QuickIface_SmartHandle &input,
                                                                 QuickIface_SmartHandle &iface0 = *(QuickIface_SmartHandle*) NULL);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const MethodTestInterface_SmartHandle&);
void operator>>= (Plic::FieldReader&, MethodTestInterface_SmartHandle&);

class SignalTestInterface_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class SignalTestInterface.
{
  static SignalTestInterface_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  static Plic::ClientConnection __client_connection__ (void);
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void ()> Signal_void_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, bool ()> Signal_bool_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, int ()> Signal_int_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, double ()> Signal_float_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, std::string ()> Signal_string_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, QuickRecord_Handle ()> Signal_record_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, QuickSequence_Handle ()> Signal_sequence_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, GrandChild_SmartHandle ()> Signal_interface_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, Plic::Any ()> Signal_any_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, SignalTestInterface_SmartHandle ()> Signal_self_result;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void ()> Signal_void_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (int i)> Signal_int_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (double f)> Signal_float_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (const QuickRecord_Handle &r)> Signal_record_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (const QuickSequence_Handle &s)> Signal_sequence_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (GrandChild_SmartHandle &i)> Signal_interface_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (const Plic::Any &a)> Signal_any_arg;
  typedef Rapicorn::Signals::SignalProxy<SignalTestInterface_SmartHandle, void (SignalTestInterface_SmartHandle &self_)> Signal_self_args;
public:
  template<class C>
  static SignalTestInterface_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      SignalTestInterface_SmartHandle ();
  Signal_void_result&           sig_void_result();
  Signal_bool_result&           sig_bool_result();
  Signal_int_result&            sig_int_result();
  Signal_float_result&          sig_float_result();
  Signal_string_result&         sig_string_result();
  Signal_enum_result&           sig_enum_result();
  Signal_record_result&         sig_record_result();
  Signal_sequence_result&       sig_sequence_result();
  Signal_interface_result&      sig_interface_result();
  Signal_any_result&            sig_any_result();
  Signal_self_result&           sig_self_result();
  Signal_void_arg&              sig_void_arg();
  Signal_bool_arg&              sig_bool_arg();
  Signal_int_arg&               sig_int_arg();
  Signal_float_arg&             sig_float_arg();
  Signal_string_arg&            sig_string_arg();
  Signal_enum_arg&              sig_enum_arg();
  Signal_record_arg&            sig_record_arg();
  Signal_sequence_arg&          sig_sequence_arg();
  Signal_interface_arg&         sig_interface_arg();
  Signal_any_arg&               sig_any_arg();
  Signal_self_args&             sig_self_args();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const SignalTestInterface_SmartHandle&);
void operator>>= (Plic::FieldReader&, SignalTestInterface_SmartHandle&);

class ChildInheritingSignals_SmartHandle : public SignalTestInterface_SmartHandle
  /// See also the corresponding IDL class ChildInheritingSignals.
{
  static ChildInheritingSignals_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  typedef Rapicorn::Signals::SignalProxy<ChildInheritingSignals_SmartHandle, void (ChildInheritingSignals_SmartHandle &c, SignalTestInterface_SmartHandle &p, const Plic::Any &a, int i, const QuickRecord_Handle &r, const QuickSequence_Handle &s)> Signal_child_signal;
public:
  template<class C>
  static ChildInheritingSignals_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      ChildInheritingSignals_SmartHandle ();
  Signal_child_signal&          sig_child_signal();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const ChildInheritingSignals_SmartHandle&);
void operator>>= (Plic::FieldReader&, ChildInheritingSignals_SmartHandle&);

class AnotherChild_SmartHandle : public SignalTestInterface_SmartHandle
  /// See also the corresponding IDL class AnotherChild.
{
  static AnotherChild_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
public:
  template<class C>
  static AnotherChild_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      AnotherChild_SmartHandle ();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const AnotherChild_SmartHandle&);
void operator>>= (Plic::FieldReader&, AnotherChild_SmartHandle&);

class PropertyTester_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class PropertyTester.
{
  static PropertyTester_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  static Plic::ClientConnection __client_connection__ (void);
public:
  template<class C>
  static PropertyTester_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      PropertyTester_SmartHandle ();
  bool                          bool_prop      () const;
  void                          bool_prop      (bool);
  int                           int_prop       () const;
  void                          int_prop       (int);
  double                        float_prop     () const;
  void                          float_prop     (double);
  std::string                   string_prop    () const;
  void                          string_prop    (const std::string&);
  QuickEnum                     enum_prop      () const;
  void                          enum_prop      (QuickEnum);
  QuickRecord_Handle            record_prop    () const;
  void                          record_prop    (const QuickRecord_Handle&);
  QuickSequence_Handle          sequence_prop  () const;
  void                          sequence_prop  (const QuickSequence_Handle&);
  GrandChild_SmartHandle        interface_prop () const;
  void                          interface_prop (GrandChild_SmartHandle);
  PropertyTester_SmartHandle    self_prop      () const;
  void                          self_prop      (PropertyTester_SmartHandle);
  Plic::Any                     any_prop       () const;
  void                          any_prop       (const Plic::Any&);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const PropertyTester_SmartHandle&);
void operator>>= (Plic::FieldReader&, PropertyTester_SmartHandle&);
} // InterfaceTests

namespace RapicornPlicTest {

enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
inline void operator<<= (Plic::FieldBuffer &fb,  ClickType &e) { fb <<= Plic::EnumValue (e); }
inline void operator>>= (Plic::FieldReader &frr, ClickType &e) { e = ClickType (frr.pop_evalue()); }

class ButtonArea_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class ButtonArea.
{
  static ButtonArea_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  static Plic::ClientConnection __client_connection__ (void);
  typedef Rapicorn::Signals::SignalProxy<ButtonArea_SmartHandle, bool ()> Signal_check_activate;
  typedef Rapicorn::Signals::SignalProxy<ButtonArea_SmartHandle, void ()> Signal_activate;
public:
  template<class C>
  static ButtonArea_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      ButtonArea_SmartHandle ();
  std::string                   on_click   () const;
  void                          on_click   (const std::string&);
  std::string                   on_click2  () const;
  void                          on_click2  (const std::string&);
  std::string                   on_click3  () const;
  void                          on_click3  (const std::string&);
  ClickType                     click_type () const;
  void                          click_type (ClickType);
  Signal_check_activate&        sig_check_activate();
  Signal_activate&              sig_activate();
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const ButtonArea_SmartHandle&);
void operator>>= (Plic::FieldReader&, ButtonArea_SmartHandle&);

class PureMethods_SmartHandle;

class PureMethods_SmartHandle : public virtual Plic::SmartHandle
  /// See also the corresponding IDL class PureMethods.
{
  static PureMethods_SmartHandle _cast (Plic::SmartHandle&, const Plic::TypeHashList&);
  static const Plic::TypeHash&  _type ();
protected:
  static Plic::ClientConnection __client_connection__ (void);
public:
  template<class C>
  static PureMethods_SmartHandle downcast (C c) { return _cast (c, c.cast_types()); }
  const Plic::TypeHashList&     cast_types ();
  explicit                      PureMethods_SmartHandle ();
  int                           pure_method             (double f);
//inline               operator _UnspecifiedBool () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
void operator<<= (Plic::FieldBuffer&, const PureMethods_SmartHandle&);
void operator>>= (Plic::FieldReader&, PureMethods_SmartHandle&);
} // RapicornPlicTest

// --- Implementations ---

namespace MandatoryNamespace {

// === FirstInterface ===
static inline void ref   (FirstInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (FirstInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
struct FirstInterface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public FirstInterface_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  FirstInterface_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
FirstInterface_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3e0c8f5da9110ad8ULL, 0xea565508333a9035ULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
FirstInterface_SmartHandle::FirstInterface_SmartHandle ()
{}
Plic::ClientConnection
FirstInterface_SmartHandle::__client_connection__ (void)
{
  return PLIC_CONNECTION();
}
void
operator<<= (Plic::FieldBuffer &fb, const FirstInterface_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, FirstInterface_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<FirstInterface_Context$> (ipcid)->handle$ : FirstInterface_SmartHandle();
}
const Plic::TypeHash&
FirstInterface_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x04be3719c81a379bULL, 0x1079454a90442f2cULL);
  return type_hash;
}
FirstInterface_SmartHandle
FirstInterface_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<FirstInterface_Context$> (connection_handle2id (other))->handle$;
  return FirstInterface_SmartHandle();
}
const Plic::TypeHashList&
FirstInterface_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<FirstInterface_Context$> (ipcid)->list_types();
}
void
FirstInterface_SmartHandle::void_func ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x209463c55becedadULL, 0x39ddfcb9aadc3c74ULL); // msgid
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (PLIC_UNLIKELY (fr != NULL)) delete fr;
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const XFooRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (17);
  fb <<= self.single_bool;
  fb <<= self.single_num;
  fb <<= self.single_float;
  fb <<= self.single_string;
  fb <<= self.sibling1;
  fb <<= self.sibling2;
  fb <<= self.multi1;
  fb <<= self.multi2;
  fb <<= self.multi3;
  fb <<= self.multi4;
  fb <<= self.enum_field;
  fb <<= self.iface1;
  fb <<= self.iface2;
  fb <<= self.iface3;
  fb <<= self.any1;
  fb <<= self.any2;
  fb <<= self.any3;
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, XFooRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 17) return;
  fbr >>= self.single_bool;
  fbr >>= self.single_num;
  fbr >>= self.single_float;
  fbr >>= self.single_string;
  fbr >>= self.sibling1;
  fbr >>= self.sibling2;
  fbr >>= self.multi1;
  fbr >>= self.multi2;
  fbr >>= self.multi3;
  fbr >>= self.multi4;
  fbr >>= self.enum_field;
  fbr >>= self.iface1;
  fbr >>= self.iface2;
  fbr >>= self.iface3;
  fbr >>= self.any1;
  fbr >>= self.any2;
  fbr >>= self.any3;
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const XFooSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, XFooSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
XFooSequence_Handle::reference
XFooSequence_Handle::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const IntSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, IntSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
IntSequence_Handle::reference
IntSequence_Handle::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const FloatSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, FloatSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
FloatSequence_Handle::reference
FloatSequence_Handle::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const StringSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, StringSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
StringSequence_Handle::reference
StringSequence_Handle::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const ExtensiveEnumSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, ExtensiveEnumSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
ExtensiveEnumSequence_Handle::reference
ExtensiveEnumSequence_Handle::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const RecordSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, RecordSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
RecordSequence_Handle::reference
RecordSequence_Handle::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const SequenceSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, SequenceSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SequenceSequence_Handle::reference
SequenceSequence_Handle::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const InterfaceSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, InterfaceSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
InterfaceSequence_Handle::reference
InterfaceSequence_Handle::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const AnySequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, AnySequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
AnySequence_Handle::reference
AnySequence_Handle::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const NestedTypesRec_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  fb <<= self.rec;
  fb <<= self.seq;
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, NestedTypesRec_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >>= self.rec;
  fbr >>= self.seq;
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const NestedTypesSeq_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, NestedTypesSeq_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
NestedTypesSeq_Handle::reference
NestedTypesSeq_Handle::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const NewRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  fb <<= self.i;
  fb <<= self.enum1;
  fb <<= self.xfs;
  fb <<= self.ntr;
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, NewRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >>= self.i;
  fbr >>= self.enum1;
  fbr >>= self.xfs;
  fbr >>= self.ntr;
}

namespace Inner {
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const InnerRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (3);
  fb <<= self.x;
  fb <<= self.y;
  fb <<= self.rec;
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, InnerRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 3) return;
  fbr >>= self.x;
  fbr >>= self.y;
  fbr >>= self.rec;
}
} // Inner
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const Refer2Inner_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (1);
  fb <<= self.r;
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, Refer2Inner_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 1) return;
  fbr >>= self.r;
}
} // MandatoryNamespace

namespace OtherNamespace {
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const SomeRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  fb <<= self.r1;
  fb <<= self.r2;
  fb <<= self.r3;
  fb <<= self.r4;
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, SomeRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >>= self.r1;
  fbr >>= self.r2;
  fbr >>= self.r3;
  fbr >>= self.r4;
}
} // OtherNamespace

namespace InterfaceTests {

// === UIWidgetArea ===
static inline void ref   (UIWidgetArea_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (UIWidgetArea_SmartHandle&) {} // dummy stub for Signal<>.emit
struct UIWidgetArea_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public UIWidgetArea_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  typedef Plic::CxxStub::SignalHandler<UIWidgetArea_SmartHandle, void ()> SignalHandler__void_signal;
  SignalHandler__void_signal void_signal;
  typedef Plic::CxxStub::SignalHandler<UIWidgetArea_SmartHandle, double (UIWidgetArea_SmartHandle &ba1, int someint)> SignalHandler__sample_signal;
  SignalHandler__sample_signal sample_signal;
  UIWidgetArea_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    void_signal (handle$, 0x52ef738c2571d0f2ULL, 0x05b653adf0a80acfULL),
    sample_signal (handle$, 0x511bbb2e2b129d5bULL, 0xe7152819ec289550ULL),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
UIWidgetArea_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3b205dd851cb8a1dULL, 0x5bcddc39beffee0dULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
UIWidgetArea_SmartHandle::UIWidgetArea_SmartHandle ()
{}
Plic::ClientConnection
UIWidgetArea_SmartHandle::__client_connection__ (void)
{
  return PLIC_CONNECTION();
}
void
operator<<= (Plic::FieldBuffer &fb, const UIWidgetArea_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, UIWidgetArea_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<UIWidgetArea_Context$> (ipcid)->handle$ : UIWidgetArea_SmartHandle();
}
const Plic::TypeHash&
UIWidgetArea_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0c1b9195fa9a5a6cULL, 0xc1f636e721317b86ULL);
  return type_hash;
}
UIWidgetArea_SmartHandle
UIWidgetArea_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<UIWidgetArea_Context$> (connection_handle2id (other))->handle$;
  return UIWidgetArea_SmartHandle();
}
const Plic::TypeHashList&
UIWidgetArea_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<UIWidgetArea_Context$> (ipcid)->list_types();
}
UIWidgetArea_SmartHandle::Signal_void_signal&
UIWidgetArea_SmartHandle::sig_void_signal ()
{
  return connection_id2context<UIWidgetArea_Context$> (connection_handle2id (*this))->void_signal.psignal;
}
UIWidgetArea_SmartHandle::Signal_sample_signal&
UIWidgetArea_SmartHandle::sig_sample_signal ()
{
  return connection_id2context<UIWidgetArea_Context$> (connection_handle2id (*this))->sample_signal.psignal;
}
double
UIWidgetArea_SmartHandle::dummy () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x39146750080bd117ULL, 0x9edc3ab3b5e82e8dULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::dummy (double value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2a284d0b5305ac3aULL, 0xd98a1d86235ad649ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
UIWidgetArea_SmartHandle::on_click () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x37b8129e6139dfaeULL, 0xece65fb7aeda0163ULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::on_click (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2d15d46bb30e2a40ULL, 0xc421a429912efd6dULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
double
UIWidgetArea_SmartHandle::simple_method ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x39a122b559d15903ULL, 0x0a95fe35b7a1de33ULL); // msgid
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::single_arg (int arg_n)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x3910395d202c93c2ULL, 0x9206a89acaaf2086ULL); // msgid
  fb <<= (*this);
  fb <<= arg_n;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::single_arg2 (int arg_n)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x3b5ae84b86dfa59cULL, 0x5d2ef3880b1fa360ULL); // msgid
  fb <<= (*this);
  fb <<= arg_n;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::two_args (int arg_n,
                                    double arg_r)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x359c33f1677a63ebULL, 0x3a05748016992575ULL); // msgid
  fb <<= (*this);
  fb <<= arg_n;
  fb <<= arg_r;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::two_args2 (int arg_n,
                                     double arg_r)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3291a584ff9121b3ULL, 0xbd14f4bbc47fb2ccULL); // msgid
  fb <<= (*this);
  fb <<= arg_n;
  fb <<= arg_r;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::multi_args (int arg_n,
                                      double arg_r,
                                      int arg_i,
                                      const std::string &arg_s,
                                      double arg_y)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 5), *fr = NULL;
  fb.add_msgid (0x3501ef84b7c1d9ffULL, 0x564566ab8a5e1b8bULL); // msgid
  fb <<= (*this);
  fb <<= arg_n;
  fb <<= arg_r;
  fb <<= arg_i;
  fb <<= arg_s;
  fb <<= arg_y;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetArea_SmartHandle::self_method (UIWidgetArea_SmartHandle &arg_ba1,
                                       UIWidgetArea_SmartHandle &arg_ba2)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x316521a2bcc037d0ULL, 0x43987053dab0c3c0ULL); // msgid
  fb <<= (*this);
  fb <<= arg_ba1;
  fb <<= arg_ba2;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::void_method ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x2e02c52c84773703ULL, 0x00027e452edb615cULL); // msgid
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (PLIC_UNLIKELY (fr != NULL)) delete fr;
}
std::string
UIWidgetArea_SmartHandle::on_click2out ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x3e4f2ff4e1424783ULL, 0x439ed3d602e3946eULL); // msgid
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetArea_SmartHandle::on_click2in (const std::string &arg_command)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2294f15cd15e9458ULL, 0x5e0ac9b493bb4f17ULL); // msgid
  fb <<= (*this);
  fb <<= arg_command;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (PLIC_UNLIKELY (fr != NULL)) delete fr;
}

// === Parent ===
static inline void ref   (Parent_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (Parent_SmartHandle&) {} // dummy stub for Signal<>.emit
struct Parent_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public Parent_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  Parent_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
Parent_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x358122a8447018eaULL, 0xf27025a07a51a48aULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
Parent_SmartHandle::Parent_SmartHandle ()
{}
Plic::ClientConnection
Parent_SmartHandle::__client_connection__ (void)
{
  return PLIC_CONNECTION();
}
void
operator<<= (Plic::FieldBuffer &fb, const Parent_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, Parent_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<Parent_Context$> (ipcid)->handle$ : Parent_SmartHandle();
}
const Plic::TypeHash&
Parent_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0d7cb4311e1f74a9ULL, 0xe1ad9d71f1c712e5ULL);
  return type_hash;
}
Parent_SmartHandle
Parent_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<Parent_Context$> (connection_handle2id (other))->handle$;
  return Parent_SmartHandle();
}
const Plic::TypeHashList&
Parent_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<Parent_Context$> (ipcid)->list_types();
}

// === Child ===
static inline void ref   (Child_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (Child_SmartHandle&) {} // dummy stub for Signal<>.emit
struct Child_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public Child_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  Child_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
Child_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3d9ee6a844c60394ULL, 0xd2cee7633ad091d5ULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
Child_SmartHandle::Child_SmartHandle ()
{}
void
operator<<= (Plic::FieldBuffer &fb, const Child_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, Child_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<Child_Context$> (ipcid)->handle$ : Child_SmartHandle();
}
const Plic::TypeHash&
Child_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0a44a1b5cf26cfc0ULL, 0xcd6e05d08ba2667eULL);
  return type_hash;
}
Child_SmartHandle
Child_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<Child_Context$> (connection_handle2id (other))->handle$;
  return Child_SmartHandle();
}
const Plic::TypeHashList&
Child_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<Child_Context$> (ipcid)->list_types();
}

// === Descendant ===
static inline void ref   (Descendant_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (Descendant_SmartHandle&) {} // dummy stub for Signal<>.emit
struct Descendant_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public Descendant_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  Descendant_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
Descendant_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3a8b819b364228b8ULL, 0x9dce3529210a7700ULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
Descendant_SmartHandle::Descendant_SmartHandle ()
{}
void
operator<<= (Plic::FieldBuffer &fb, const Descendant_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, Descendant_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<Descendant_Context$> (ipcid)->handle$ : Descendant_SmartHandle();
}
const Plic::TypeHash&
Descendant_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0980fc7a8521c350ULL, 0x641568ba1f461de2ULL);
  return type_hash;
}
Descendant_SmartHandle
Descendant_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<Descendant_Context$> (connection_handle2id (other))->handle$;
  return Descendant_SmartHandle();
}
const Plic::TypeHashList&
Descendant_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<Descendant_Context$> (ipcid)->list_types();
}

// === GrandChild ===
static inline void ref   (GrandChild_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (GrandChild_SmartHandle&) {} // dummy stub for Signal<>.emit
struct GrandChild_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public GrandChild_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  GrandChild_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
GrandChild_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3aa9daa434261f37ULL, 0xa848862e429bf919ULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
GrandChild_SmartHandle::GrandChild_SmartHandle ()
{}
void
operator<<= (Plic::FieldBuffer &fb, const GrandChild_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, GrandChild_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<GrandChild_Context$> (ipcid)->handle$ : GrandChild_SmartHandle();
}
const Plic::TypeHash&
GrandChild_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x001a87e60ed9bd66ULL, 0xfff1a96d7bab9cd9ULL);
  return type_hash;
}
GrandChild_SmartHandle
GrandChild_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<GrandChild_Context$> (connection_handle2id (other))->handle$;
  return GrandChild_SmartHandle();
}
const Plic::TypeHashList&
GrandChild_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<GrandChild_Context$> (ipcid)->list_types();
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const QuickRecord_Handle &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  fb <<= self.int1;
  fb <<= self.int2;
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, QuickRecord_Handle &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >>= self.int1;
  fbr >>= self.int2;
}
inline void __attribute__ ((used))
operator<<= (Plic::FieldBuffer &dst, const QuickSequence_Handle &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Plic::FieldReader &src, QuickSequence_Handle &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
QuickSequence_Handle::reference
QuickSequence_Handle::append_back()
{
  resize (size() + 1);
  return back();
}

// === QuickIface ===
static inline void ref   (QuickIface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (QuickIface_SmartHandle&) {} // dummy stub for Signal<>.emit
struct QuickIface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public QuickIface_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  QuickIface_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
QuickIface_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3ceafdc3043b707dULL, 0xf30106bb4338c235ULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
QuickIface_SmartHandle::QuickIface_SmartHandle ()
{}
Plic::ClientConnection
QuickIface_SmartHandle::__client_connection__ (void)
{
  return PLIC_CONNECTION();
}
void
operator<<= (Plic::FieldBuffer &fb, const QuickIface_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, QuickIface_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<QuickIface_Context$> (ipcid)->handle$ : QuickIface_SmartHandle();
}
const Plic::TypeHash&
QuickIface_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0ce40c896cfa0177ULL, 0x5ab6faf97ff6fed2ULL);
  return type_hash;
}
QuickIface_SmartHandle
QuickIface_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<QuickIface_Context$> (connection_handle2id (other))->handle$;
  return QuickIface_SmartHandle();
}
const Plic::TypeHashList&
QuickIface_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<QuickIface_Context$> (ipcid)->list_types();
}
void
QuickIface_SmartHandle::simple_function (int arg_i)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2446078b004b9aabULL, 0x37d6c73a34ac7070ULL); // msgid
  fb <<= (*this);
  fb <<= arg_i;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (PLIC_UNLIKELY (fr != NULL)) delete fr;
}

// === MethodTestInterface ===
static inline void ref   (MethodTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (MethodTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
struct MethodTestInterface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public MethodTestInterface_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  MethodTestInterface_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
MethodTestInterface_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x363e0b9e750bbbe2ULL, 0x8b5953ab5fb23a59ULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
MethodTestInterface_SmartHandle::MethodTestInterface_SmartHandle ()
{}
Plic::ClientConnection
MethodTestInterface_SmartHandle::__client_connection__ (void)
{
  return PLIC_CONNECTION();
}
void
operator<<= (Plic::FieldBuffer &fb, const MethodTestInterface_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, MethodTestInterface_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<MethodTestInterface_Context$> (ipcid)->handle$ : MethodTestInterface_SmartHandle();
}
const Plic::TypeHash&
MethodTestInterface_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x03befccd5d5ee8d5ULL, 0x7f1f65a869ad267fULL);
  return type_hash;
}
MethodTestInterface_SmartHandle
MethodTestInterface_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<MethodTestInterface_Context$> (connection_handle2id (other))->handle$;
  return MethodTestInterface_SmartHandle();
}
const Plic::TypeHashList&
MethodTestInterface_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<MethodTestInterface_Context$> (ipcid)->list_types();
}
void
MethodTestInterface_SmartHandle::method_with_void ()
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0), *fr = NULL;
  fb.add_msgid (0x281392e54343bee9ULL, 0x0dbeb788728dbff4ULL); // msgid
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (PLIC_UNLIKELY (fr != NULL)) delete fr;
}
bool
MethodTestInterface_SmartHandle::method_with_bools (bool arg_input,
                                                    bool arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3b68546991e25342ULL, 0xa71399caec9ccfc7ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  bool  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
int
MethodTestInterface_SmartHandle::method_with_ints (int arg_input,
                                                   int arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x39555e79a31047bfULL, 0x0f06b4f122a81e1dULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  int  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
MethodTestInterface_SmartHandle::method_with_floats (double arg_input,
                                                     double arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x391dd7c671dada38ULL, 0x32ca18bc1bd39689ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
std::string
MethodTestInterface_SmartHandle::method_with_string (const std::string &arg_input,
                                                     const std::string &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3ad5eafe588b965aULL, 0x38c04145925d2963ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickEnum
MethodTestInterface_SmartHandle::method_with_enum (QuickEnum arg_input,
                                                   QuickEnum arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x387f08a5c150e6a7ULL, 0x83c133fcd2be3200ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickEnum  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickRecord_Handle
MethodTestInterface_SmartHandle::method_with_record (const QuickRecord_Handle &arg_input,
                                                     const QuickRecord_Handle &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3b59b493f287edf0ULL, 0x4771d353c78389d1ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickRecord_Handle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickSequence_Handle
MethodTestInterface_SmartHandle::method_with_sequence (const QuickSequence_Handle &arg_input,
                                                       const QuickSequence_Handle &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x34c9e8a686a7f261ULL, 0x9af099b173ac979cULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickSequence_Handle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
GrandChild_SmartHandle
MethodTestInterface_SmartHandle::method_with_interface (GrandChild_SmartHandle &arg_input,
                                                        GrandChild_SmartHandle &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x34619983babcee5bULL, 0x9875f78f28f381b7ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  GrandChild_SmartHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
Plic::Any
MethodTestInterface_SmartHandle::method_with_anys (const Plic::Any &arg_input,
                                                   const Plic::Any &arg_optval)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x37b8d8ed63487319ULL, 0xb18dc7a6d35529d5ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  Plic::Any  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickIface_SmartHandle
MethodTestInterface_SmartHandle::method_with_quickiface (QuickIface_SmartHandle &arg_input,
                                                         QuickIface_SmartHandle &arg_iface0)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2), *fr = NULL;
  fb.add_msgid (0x3a2ab33a8358edcbULL, 0x7c028db9464052a0ULL); // msgid
  fb <<= (*this);
  fb <<= arg_input;
  fb <<= arg_iface0;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickIface_SmartHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}

// === SignalTestInterface ===
static inline void ref   (SignalTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (SignalTestInterface_SmartHandle&) {} // dummy stub for Signal<>.emit
struct SignalTestInterface_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public SignalTestInterface_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void ()> SignalHandler__void_result;
  SignalHandler__void_result void_result;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, bool ()> SignalHandler__bool_result;
  SignalHandler__bool_result bool_result;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, int ()> SignalHandler__int_result;
  SignalHandler__int_result int_result;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, double ()> SignalHandler__float_result;
  SignalHandler__float_result float_result;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, std::string ()> SignalHandler__string_result;
  SignalHandler__string_result string_result;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, QuickEnum ()> SignalHandler__enum_result;
  SignalHandler__enum_result enum_result;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, QuickRecord_Handle ()> SignalHandler__record_result;
  SignalHandler__record_result record_result;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, QuickSequence_Handle ()> SignalHandler__sequence_result;
  SignalHandler__sequence_result sequence_result;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, GrandChild_SmartHandle ()> SignalHandler__interface_result;
  SignalHandler__interface_result interface_result;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, Plic::Any ()> SignalHandler__any_result;
  SignalHandler__any_result any_result;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, SignalTestInterface_SmartHandle ()> SignalHandler__self_result;
  SignalHandler__self_result self_result;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void ()> SignalHandler__void_arg;
  SignalHandler__void_arg void_arg;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void (bool b)> SignalHandler__bool_arg;
  SignalHandler__bool_arg bool_arg;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void (int i)> SignalHandler__int_arg;
  SignalHandler__int_arg int_arg;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void (double f)> SignalHandler__float_arg;
  SignalHandler__float_arg float_arg;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void (const std::string &s)> SignalHandler__string_arg;
  SignalHandler__string_arg string_arg;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void (QuickEnum e)> SignalHandler__enum_arg;
  SignalHandler__enum_arg enum_arg;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void (const QuickRecord_Handle &r)> SignalHandler__record_arg;
  SignalHandler__record_arg record_arg;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void (const QuickSequence_Handle &s)> SignalHandler__sequence_arg;
  SignalHandler__sequence_arg sequence_arg;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void (GrandChild_SmartHandle &i)> SignalHandler__interface_arg;
  SignalHandler__interface_arg interface_arg;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void (const Plic::Any &a)> SignalHandler__any_arg;
  SignalHandler__any_arg any_arg;
  typedef Plic::CxxStub::SignalHandler<SignalTestInterface_SmartHandle, void (SignalTestInterface_SmartHandle &self_)> SignalHandler__self_args;
  SignalHandler__self_args self_args;
  SignalTestInterface_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    void_result (handle$, 0x535d5e95471873b6ULL, 0x7a9f5692ce00e007ULL),
    bool_result (handle$, 0x51ffffa2f8db1b1bULL, 0x3e01434baf49eceeULL),
    int_result (handle$, 0x51ac083cdc878affULL, 0x72ad7414773447a2ULL),
    float_result (handle$, 0x5cc54429499b42b6ULL, 0x35e1fb7707130bcaULL),
    string_result (handle$, 0x5790f575b6cac788ULL, 0x27db8e3c014993a7ULL),
    enum_result (handle$, 0x56fc6f3f4946e7b2ULL, 0x0fe0cc5f83d2ab84ULL),
    record_result (handle$, 0x50b723665ed298a5ULL, 0x32aa063680a4e3c0ULL),
    sequence_result (handle$, 0x5ef00325dfcf4552ULL, 0x991130ecddd21730ULL),
    interface_result (handle$, 0x58e8587c542d85ceULL, 0xe2b572e902c69f7cULL),
    any_result (handle$, 0x52aa86cb9557c7b5ULL, 0xb5b86bcd272326c5ULL),
    self_result (handle$, 0x59bb2da621bab28fULL, 0x32bc82e7eb9bc512ULL),
    void_arg (handle$, 0x583dc36c7785c7f3ULL, 0xb330cefa4e8247a9ULL),
    bool_arg (handle$, 0x5f7ba898d12986bfULL, 0x8a1143a5f6dc85b8ULL),
    int_arg (handle$, 0x5f91dc79c2bee013ULL, 0x809b90b2fad4ea0aULL),
    float_arg (handle$, 0x5d5c43cd47b258caULL, 0xb0d5fde097d6d12cULL),
    string_arg (handle$, 0x53de7a105b57bf62ULL, 0x9d8ffe4942a0934fULL),
    enum_arg (handle$, 0x586138796f133c4dULL, 0x1c7573f2d30ac907ULL),
    record_arg (handle$, 0x59cb77461ddeac82ULL, 0xfeaa98721bd8ecd3ULL),
    sequence_arg (handle$, 0x547b4dd41606b568ULL, 0x1d763791a33d2bc9ULL),
    interface_arg (handle$, 0x57a5dbfbeb5a4ef9ULL, 0xb5df0c3b3bba4b22ULL),
    any_arg (handle$, 0x51d96c2cd8c40104ULL, 0x04aedd456681cb81ULL),
    self_args (handle$, 0x5c515ee37b78a970ULL, 0xe89c2af2f29359a0ULL),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
SignalTestInterface_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3b2248e8e9d4ff05ULL, 0xda71e710449d85dfULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
SignalTestInterface_SmartHandle::SignalTestInterface_SmartHandle ()
{}
Plic::ClientConnection
SignalTestInterface_SmartHandle::__client_connection__ (void)
{
  return PLIC_CONNECTION();
}
void
operator<<= (Plic::FieldBuffer &fb, const SignalTestInterface_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, SignalTestInterface_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<SignalTestInterface_Context$> (ipcid)->handle$ : SignalTestInterface_SmartHandle();
}
const Plic::TypeHash&
SignalTestInterface_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0acc338edd01a172ULL, 0x27c5f8854a5f9458ULL);
  return type_hash;
}
SignalTestInterface_SmartHandle
SignalTestInterface_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (other))->handle$;
  return SignalTestInterface_SmartHandle();
}
const Plic::TypeHashList&
SignalTestInterface_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<SignalTestInterface_Context$> (ipcid)->list_types();
}
SignalTestInterface_SmartHandle::Signal_void_result&
SignalTestInterface_SmartHandle::sig_void_result ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->void_result.psignal;
}
SignalTestInterface_SmartHandle::Signal_bool_result&
SignalTestInterface_SmartHandle::sig_bool_result ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->bool_result.psignal;
}
SignalTestInterface_SmartHandle::Signal_int_result&
SignalTestInterface_SmartHandle::sig_int_result ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->int_result.psignal;
}
SignalTestInterface_SmartHandle::Signal_float_result&
SignalTestInterface_SmartHandle::sig_float_result ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->float_result.psignal;
}
SignalTestInterface_SmartHandle::Signal_string_result&
SignalTestInterface_SmartHandle::sig_string_result ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->string_result.psignal;
}
SignalTestInterface_SmartHandle::Signal_enum_result&
SignalTestInterface_SmartHandle::sig_enum_result ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->enum_result.psignal;
}
SignalTestInterface_SmartHandle::Signal_record_result&
SignalTestInterface_SmartHandle::sig_record_result ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->record_result.psignal;
}
SignalTestInterface_SmartHandle::Signal_sequence_result&
SignalTestInterface_SmartHandle::sig_sequence_result ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->sequence_result.psignal;
}
SignalTestInterface_SmartHandle::Signal_interface_result&
SignalTestInterface_SmartHandle::sig_interface_result ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->interface_result.psignal;
}
SignalTestInterface_SmartHandle::Signal_any_result&
SignalTestInterface_SmartHandle::sig_any_result ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->any_result.psignal;
}
SignalTestInterface_SmartHandle::Signal_self_result&
SignalTestInterface_SmartHandle::sig_self_result ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->self_result.psignal;
}
SignalTestInterface_SmartHandle::Signal_void_arg&
SignalTestInterface_SmartHandle::sig_void_arg ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->void_arg.psignal;
}
SignalTestInterface_SmartHandle::Signal_bool_arg&
SignalTestInterface_SmartHandle::sig_bool_arg ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->bool_arg.psignal;
}
SignalTestInterface_SmartHandle::Signal_int_arg&
SignalTestInterface_SmartHandle::sig_int_arg ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->int_arg.psignal;
}
SignalTestInterface_SmartHandle::Signal_float_arg&
SignalTestInterface_SmartHandle::sig_float_arg ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->float_arg.psignal;
}
SignalTestInterface_SmartHandle::Signal_string_arg&
SignalTestInterface_SmartHandle::sig_string_arg ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->string_arg.psignal;
}
SignalTestInterface_SmartHandle::Signal_enum_arg&
SignalTestInterface_SmartHandle::sig_enum_arg ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->enum_arg.psignal;
}
SignalTestInterface_SmartHandle::Signal_record_arg&
SignalTestInterface_SmartHandle::sig_record_arg ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->record_arg.psignal;
}
SignalTestInterface_SmartHandle::Signal_sequence_arg&
SignalTestInterface_SmartHandle::sig_sequence_arg ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->sequence_arg.psignal;
}
SignalTestInterface_SmartHandle::Signal_interface_arg&
SignalTestInterface_SmartHandle::sig_interface_arg ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->interface_arg.psignal;
}
SignalTestInterface_SmartHandle::Signal_any_arg&
SignalTestInterface_SmartHandle::sig_any_arg ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->any_arg.psignal;
}
SignalTestInterface_SmartHandle::Signal_self_args&
SignalTestInterface_SmartHandle::sig_self_args ()
{
  return connection_id2context<SignalTestInterface_Context$> (connection_handle2id (*this))->self_args.psignal;
}

// === ChildInheritingSignals ===
static inline void ref   (ChildInheritingSignals_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (ChildInheritingSignals_SmartHandle&) {} // dummy stub for Signal<>.emit
struct ChildInheritingSignals_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public ChildInheritingSignals_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  typedef Plic::CxxStub::SignalHandler<ChildInheritingSignals_SmartHandle, void (ChildInheritingSignals_SmartHandle &c, SignalTestInterface_SmartHandle &p, const Plic::Any &a, int i, const QuickRecord_Handle &r, const QuickSequence_Handle &s)> SignalHandler__child_signal;
  SignalHandler__child_signal child_signal;
  ChildInheritingSignals_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    child_signal (handle$, 0x56e02e4bf72a0363ULL, 0x4af5fd2e14057dc2ULL),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
ChildInheritingSignals_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3d6b68fa4d6a3c76ULL, 0xc9f1e8332c98049bULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
ChildInheritingSignals_SmartHandle::ChildInheritingSignals_SmartHandle ()
{}
void
operator<<= (Plic::FieldBuffer &fb, const ChildInheritingSignals_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, ChildInheritingSignals_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<ChildInheritingSignals_Context$> (ipcid)->handle$ : ChildInheritingSignals_SmartHandle();
}
const Plic::TypeHash&
ChildInheritingSignals_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0d6e67873f4098cbULL, 0xe7f2eb93eb46037cULL);
  return type_hash;
}
ChildInheritingSignals_SmartHandle
ChildInheritingSignals_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<ChildInheritingSignals_Context$> (connection_handle2id (other))->handle$;
  return ChildInheritingSignals_SmartHandle();
}
const Plic::TypeHashList&
ChildInheritingSignals_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<ChildInheritingSignals_Context$> (ipcid)->list_types();
}
ChildInheritingSignals_SmartHandle::Signal_child_signal&
ChildInheritingSignals_SmartHandle::sig_child_signal ()
{
  return connection_id2context<ChildInheritingSignals_Context$> (connection_handle2id (*this))->child_signal.psignal;
}

// === AnotherChild ===
static inline void ref   (AnotherChild_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (AnotherChild_SmartHandle&) {} // dummy stub for Signal<>.emit
struct AnotherChild_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public AnotherChild_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  AnotherChild_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
AnotherChild_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x300b6f8565bd0732ULL, 0x164c7a93dffad03bULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
AnotherChild_SmartHandle::AnotherChild_SmartHandle ()
{}
void
operator<<= (Plic::FieldBuffer &fb, const AnotherChild_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, AnotherChild_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<AnotherChild_Context$> (ipcid)->handle$ : AnotherChild_SmartHandle();
}
const Plic::TypeHash&
AnotherChild_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0e2870deaacf05f9ULL, 0x2851002b6bd14b7aULL);
  return type_hash;
}
AnotherChild_SmartHandle
AnotherChild_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<AnotherChild_Context$> (connection_handle2id (other))->handle$;
  return AnotherChild_SmartHandle();
}
const Plic::TypeHashList&
AnotherChild_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<AnotherChild_Context$> (ipcid)->list_types();
}

// === PropertyTester ===
static inline void ref   (PropertyTester_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (PropertyTester_SmartHandle&) {} // dummy stub for Signal<>.emit
struct PropertyTester_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public PropertyTester_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  PropertyTester_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
PropertyTester_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x33ed5186814fd96fULL, 0x2db9aae41d7f688cULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
PropertyTester_SmartHandle::PropertyTester_SmartHandle ()
{}
Plic::ClientConnection
PropertyTester_SmartHandle::__client_connection__ (void)
{
  return PLIC_CONNECTION();
}
void
operator<<= (Plic::FieldBuffer &fb, const PropertyTester_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, PropertyTester_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<PropertyTester_Context$> (ipcid)->handle$ : PropertyTester_SmartHandle();
}
const Plic::TypeHash&
PropertyTester_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0de89d5c207bc662ULL, 0x846800e315917b46ULL);
  return type_hash;
}
PropertyTester_SmartHandle
PropertyTester_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<PropertyTester_Context$> (connection_handle2id (other))->handle$;
  return PropertyTester_SmartHandle();
}
const Plic::TypeHashList&
PropertyTester_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<PropertyTester_Context$> (ipcid)->list_types();
}
bool
PropertyTester_SmartHandle::bool_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x396c5b1aaf49cec6ULL, 0xb6218ab5ac6b82c3ULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  bool  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::bool_prop (bool value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2bd3c8fc8f71f8b4ULL, 0x2dde5c2c8fcf750cULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
int
PropertyTester_SmartHandle::int_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x369c402f00bbf1e2ULL, 0x515a4131e4516216ULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  int  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::int_prop (int value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2a015ad6b813701dULL, 0x62fa674331e78289ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
double
PropertyTester_SmartHandle::float_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3b2c96526265c4baULL, 0xc1f4b15d96504a08ULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::float_prop (double value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x25ae78062c0435cdULL, 0x1d21f473f7647360ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
PropertyTester_SmartHandle::string_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x385771786e6432dbULL, 0xcb19bfb3aa9a26feULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::string_prop (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x206d200c92ba7e41ULL, 0x857975e0304c85f3ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickEnum
PropertyTester_SmartHandle::enum_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3d09e074f5d2f8edULL, 0x38e8a275e29c3fc2ULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickEnum  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::enum_prop (QuickEnum value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2b77a2f3a3c4d5b4ULL, 0x4d5b96d1adf5f7ccULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickRecord_Handle
PropertyTester_SmartHandle::record_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x31443949c61d0fecULL, 0xeb221638d6ffd3cfULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickRecord_Handle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::record_prop (const QuickRecord_Handle &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2a5f5c212625f446ULL, 0x30d24123307269ceULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
QuickSequence_Handle
PropertyTester_SmartHandle::sequence_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3f323c929c803ea8ULL, 0x6ebf49e977bfb699ULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  QuickSequence_Handle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::sequence_prop (const QuickSequence_Handle &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x232174952090a941ULL, 0xae8b7a3e13fdfde7ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
GrandChild_SmartHandle
PropertyTester_SmartHandle::interface_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x33a8b72ea92bb600ULL, 0x3837c1118556aaedULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  GrandChild_SmartHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::interface_prop (GrandChild_SmartHandle value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x29163b10631cf4b4ULL, 0xf014d69b1a1153e9ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
PropertyTester_SmartHandle
PropertyTester_SmartHandle::self_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3e6b07e114fab96bULL, 0x45a97f76ee1a7bcfULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  PropertyTester_SmartHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::self_prop (PropertyTester_SmartHandle value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2c1aea6b5567c7beULL, 0x8f21acd05f5030deULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
Plic::Any
PropertyTester_SmartHandle::any_prop () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x331c2730c160062aULL, 0xaabfaeca6649ae46ULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  Plic::Any  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTester_SmartHandle::any_prop (const Plic::Any &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x28a440900d170de2ULL, 0x69e43a111fa9fb39ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
} // InterfaceTests

namespace RapicornPlicTest {

// === ButtonArea ===
static inline void ref   (ButtonArea_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (ButtonArea_SmartHandle&) {} // dummy stub for Signal<>.emit
struct ButtonArea_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public ButtonArea_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  typedef Plic::CxxStub::SignalHandler<ButtonArea_SmartHandle, bool ()> SignalHandler__check_activate;
  SignalHandler__check_activate check_activate;
  typedef Plic::CxxStub::SignalHandler<ButtonArea_SmartHandle, void ()> SignalHandler__activate;
  SignalHandler__activate activate;
  ButtonArea_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    check_activate (handle$, 0x5aa49f58f83f54b7ULL, 0xff357b59e593e480ULL),
    activate (handle$, 0x567351a83995c46eULL, 0xcd153a5a755401f6ULL),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
ButtonArea_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3416c0fa53fb9e4bULL, 0xca6572c6a964739bULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
ButtonArea_SmartHandle::ButtonArea_SmartHandle ()
{}
Plic::ClientConnection
ButtonArea_SmartHandle::__client_connection__ (void)
{
  return PLIC_CONNECTION();
}
void
operator<<= (Plic::FieldBuffer &fb, const ButtonArea_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, ButtonArea_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<ButtonArea_Context$> (ipcid)->handle$ : ButtonArea_SmartHandle();
}
const Plic::TypeHash&
ButtonArea_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0dcb7c084481f495ULL, 0x58f43abd0dd694eaULL);
  return type_hash;
}
ButtonArea_SmartHandle
ButtonArea_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<ButtonArea_Context$> (connection_handle2id (other))->handle$;
  return ButtonArea_SmartHandle();
}
const Plic::TypeHashList&
ButtonArea_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<ButtonArea_Context$> (ipcid)->list_types();
}
ButtonArea_SmartHandle::Signal_check_activate&
ButtonArea_SmartHandle::sig_check_activate ()
{
  return connection_id2context<ButtonArea_Context$> (connection_handle2id (*this))->check_activate.psignal;
}
ButtonArea_SmartHandle::Signal_activate&
ButtonArea_SmartHandle::sig_activate ()
{
  return connection_id2context<ButtonArea_Context$> (connection_handle2id (*this))->activate.psignal;
}
std::string
ButtonArea_SmartHandle::on_click () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3e3aae70657f83b7ULL, 0x728ed182ccdc4020ULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::on_click (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x2d526a22ceb83792ULL, 0x62169ce8c45be6e0ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
ButtonArea_SmartHandle::on_click2 () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3c128313732bc9a9ULL, 0xad69a127aa1ce9b0ULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::on_click2 (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x23c57c80df9b0efbULL, 0xb8e860a363947d7dULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
std::string
ButtonArea_SmartHandle::on_click3 () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x380ad1778851e535ULL, 0x5b045ec25d2deb0eULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::on_click3 (const std::string &value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x27d09d1b9508a02bULL, 0x1e072d4d979e4921ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}
ClickType
ButtonArea_SmartHandle::click_type () const
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1), *fr = NULL;
  fb.add_msgid (0x3d39bef0c031e35dULL, 0x7ea1af466f8574b1ULL);
  fb <<= (*this);
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  ClickType  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonArea_SmartHandle::click_type (ClickType value)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x27b69c1801d07bbeULL, 0x929dbc4b4f2ea981ULL); // msgid
  fb <<= (*this);
  fb <<= value;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  if (fr) delete fr;
}

// === PureMethods ===
static inline void ref   (PureMethods_SmartHandle&) {} // dummy stub for Signal<>.emit
static inline void unref (PureMethods_SmartHandle&) {} // dummy stub for Signal<>.emit
struct PureMethods_Context$ : public Plic::NonCopyable {
  struct SmartHandle$ : public PureMethods_SmartHandle {
    SmartHandle$ (Plic::uint64_t ipcid) : Plic::SmartHandle (ipcid) {}
  } handle$;
  PureMethods_Context$ (Plic::uint64_t ipcid) :
    handle$ (ipcid),
    m_cached_types (NULL)
  {}
  Plic::TypeHashList *m_cached_types;
  const Plic::TypeHashList& list_types ();
};
const Plic::TypeHashList&
PureMethods_Context$::list_types ()
{
  if (!m_cached_types) {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (0x3f8c1b3ea1e0fd3cULL, 0x53f8ae50709fadc0ULL);
    fb <<= handle$;
    Plic::FieldBuffer *fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
    PLIC_CHECK (fr != NULL, "missing result from 2-way call");
    Plic::FieldReader frr (*fr);
    frr.skip_msgid(); // FIXME: msgid for return?
    size_t len;
    frr >>= len;
    PLIC_CHECK (frr.remaining() == len * 2, "result truncated");
    Plic::TypeHashList *thv = new Plic::TypeHashList();
    Plic::TypeHash thash;
    for (size_t i = 0; i < len; i++) {
      frr >>= thash;
      thv->push_back (thash);
    }
    delete fr;
    if (!Plic::atomic_ptr_cas (&m_cached_types, (Plic::TypeHashList*) NULL, thv))
      delete thv;
  }
  return *m_cached_types;
}
PureMethods_SmartHandle::PureMethods_SmartHandle ()
{}
Plic::ClientConnection
PureMethods_SmartHandle::__client_connection__ (void)
{
  return PLIC_CONNECTION();
}
void
operator<<= (Plic::FieldBuffer &fb, const PureMethods_SmartHandle &handle)
{
  fb.add_object (connection_handle2id (handle));
}
void
operator>>= (Plic::FieldReader &fbr, PureMethods_SmartHandle &handle)
{
  const Plic::uint64_t ipcid = fbr.pop_object();
  handle = PLIC_ISLIKELY (ipcid) ? connection_id2context<PureMethods_Context$> (ipcid)->handle$ : PureMethods_SmartHandle();
}
const Plic::TypeHash&
PureMethods_SmartHandle::_type()
{
  static const Plic::TypeHash type_hash = Plic::TypeHash (0x0364646bccfb6bbcULL, 0x37b842dacad68d00ULL);
  return type_hash;
}
PureMethods_SmartHandle
PureMethods_SmartHandle::_cast (Plic::SmartHandle &other, const Plic::TypeHashList &types)
{
  size_t i; const Plic::TypeHash &mine = _type();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return connection_id2context<PureMethods_Context$> (connection_handle2id (other))->handle$;
  return PureMethods_SmartHandle();
}
const Plic::TypeHashList&
PureMethods_SmartHandle::cast_types()
{
  static Plic::TypeHashList notypes;
  const Plic::uint64_t ipcid = connection_handle2id (*this);
  if (PLIC_UNLIKELY (!ipcid)) return notypes; // null handle
  return connection_id2context<PureMethods_Context$> (ipcid)->list_types();
}
int
PureMethods_SmartHandle::pure_method (double arg_f)
{
  Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1), *fr = NULL;
  fb.add_msgid (0x3c452a34192441bfULL, 0xcb1002037bf028e2ULL); // msgid
  fb <<= (*this);
  fb <<= arg_f;
  fr = PLIC_CONNECTION().call_remote (&fb); // deletes fb
  Plic::FieldReader frr (*fr);
  frr.skip_msgid(); // FIXME: check msgid
  int  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
} // RapicornPlicTest


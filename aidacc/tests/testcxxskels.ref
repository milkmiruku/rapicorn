// --- Generated by AidaCxxStub ---

// --- ServerHH Boilerplate ---
#include <rapicorn-core.hh>

#include <rapicorn-core.hh> // for rcore/signal.hh

// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

class I_FirstInterfaceIface;
typedef std::shared_ptr<I_FirstInterfaceIface> I_FirstInterfaceIfaceP;
typedef std::weak_ptr  <I_FirstInterfaceIface> I_FirstInterfaceIfaceW;

/** @interface FirstInterface
 * See also the corresponding C++ servant class I_FirstInterfaceIface. */
/// See also the corresponding IDL class FirstInterface.
class I_FirstInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_FirstInterfaceIface ();
  virtual /*Des*/                       ~I_FirstInterfaceIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "MandatoryNamespace::FirstInterface"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          void_func             (); 	///< See FirstInterface::void_func()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterfaceIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterfaceIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_FirstInterfaceIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_FirstInterfaceIfaceP&);
I_FirstInterfaceIface* operator->* (FirstInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
FirstInterfaceHandle operator->* (I_FirstInterfaceIface *obj, Rapicorn::Aida::_HandleType);

typedef Rapicorn::Aida::Any AliasAny;

typedef bool AliasBool;

typedef int AliasInt32;

typedef Rapicorn::Aida::int64 AliasInt64;

typedef double AliasFloat;

typedef std::string AliasString;

typedef XFooRecord AliasRecord;

typedef XFooSequence AliasSequence;

typedef ExtensiveEnum AliasEnum;
} // MandatoryNamespace

namespace Auxdata {

typedef bool AuxBool;

typedef int Aux32;

typedef Rapicorn::Aida::int64 Aux64;

typedef double AuxF64;

typedef std::string AuxStr;
} // Auxdata

namespace InterfaceTests {

class I_UIWidgetAreaIface;
typedef std::shared_ptr<I_UIWidgetAreaIface> I_UIWidgetAreaIfaceP;
typedef std::weak_ptr  <I_UIWidgetAreaIface> I_UIWidgetAreaIfaceW;

/** @interface UIWidgetArea
 * See also the corresponding C++ servant class I_UIWidgetAreaIface. */
/// See also the corresponding IDL class UIWidgetArea.
class I_UIWidgetAreaIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_UIWidgetAreaIface ();
  virtual /*Des*/                       ~I_UIWidgetAreaIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::UIWidgetArea"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual bool                          dummy    () const = 0; 	///< See UIWidgetArea::dummy
  virtual void                          dummy    (bool) = 0; 	///< See UIWidgetArea::dummy
  virtual std::string                   on_click () const = 0; 	///< See UIWidgetArea::on_click
  virtual void                          on_click (const std::string&) = 0; 	///< See UIWidgetArea::on_click
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_signal;
  typedef Rapicorn::Aida::AsyncSignal<double (I_UIWidgetAreaIface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double                        simple_method       (); 	///< See UIWidgetArea::simple_method()
  virtual double                        single_arg          (int n); 	///< See UIWidgetArea::single_arg()
  virtual double                        single_arg2         (int n = 5); 	///< See UIWidgetArea::single_arg2()
  virtual double                        two_args            (int n,
                                                             double r); 	///< See UIWidgetArea::two_args()
  virtual double                        two_args2           (int n = 6,
                                                             double r = 7.7); 	///< See UIWidgetArea::two_args2()
  virtual double                        multi_args          (bool b,
                                                             Rapicorn::Aida::int64 n,
                                                             double r,
                                                             int i,
                                                             const std::string &s = "String ding",
                                                             double y = 5); 	///< See UIWidgetArea::multi_args()
  virtual double                        self_method         (I_UIWidgetAreaIface &ba1,
                                                             I_UIWidgetAreaIface &ba2); 	///< See UIWidgetArea::self_method()
  virtual void                          void_method         (); 	///< See UIWidgetArea::void_method()
  virtual std::string                   on_click2out        (); 	///< See UIWidgetArea::on_click2out()
  virtual void                          on_click2in         (const std::string &command); 	///< See UIWidgetArea::on_click2in()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetAreaIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetAreaIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_UIWidgetAreaIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_UIWidgetAreaIfaceP&);
I_UIWidgetAreaIface* operator->* (UIWidgetAreaHandle &sh, Rapicorn::Aida::_ServantType);
UIWidgetAreaHandle operator->* (I_UIWidgetAreaIface *obj, Rapicorn::Aida::_HandleType);

class I_ParentIface;
typedef std::shared_ptr<I_ParentIface> I_ParentIfaceP;
typedef std::weak_ptr  <I_ParentIface> I_ParentIfaceW;

/** @interface Parent
 * See also the corresponding C++ servant class I_ParentIface. */
/// See also the corresponding IDL class Parent.
class I_ParentIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_ParentIface ();
  virtual /*Des*/                       ~I_ParentIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::Parent"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ParentIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ParentIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ParentIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ParentIfaceP&);
I_ParentIface* operator->* (ParentHandle &sh, Rapicorn::Aida::_ServantType);
ParentHandle operator->* (I_ParentIface *obj, Rapicorn::Aida::_HandleType);

class I_ChildIface;
typedef std::shared_ptr<I_ChildIface> I_ChildIfaceP;
typedef std::weak_ptr  <I_ChildIface> I_ChildIfaceW;

/** @interface Child
 * See also the corresponding C++ servant class I_ChildIface. */
/// See also the corresponding IDL class Child.
class I_ChildIface : public virtual I_ParentIface
{
protected:
  explicit                               I_ChildIface ();
  virtual /*Des*/                       ~I_ChildIface () override = 0;
public:
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::Child"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildIfaceP&);
I_ChildIface* operator->* (ChildHandle &sh, Rapicorn::Aida::_ServantType);
ChildHandle operator->* (I_ChildIface *obj, Rapicorn::Aida::_HandleType);

class I_DescendantIface;
typedef std::shared_ptr<I_DescendantIface> I_DescendantIfaceP;
typedef std::weak_ptr  <I_DescendantIface> I_DescendantIfaceW;

/** @interface Descendant
 * See also the corresponding C++ servant class I_DescendantIface. */
/// See also the corresponding IDL class Descendant.
class I_DescendantIface : public virtual I_ChildIface
{
protected:
  explicit                               I_DescendantIface ();
  virtual /*Des*/                       ~I_DescendantIface () override = 0;
public:
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::Descendant"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_DescendantIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_DescendantIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_DescendantIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_DescendantIfaceP&);
I_DescendantIface* operator->* (DescendantHandle &sh, Rapicorn::Aida::_ServantType);
DescendantHandle operator->* (I_DescendantIface *obj, Rapicorn::Aida::_HandleType);

class I_GrandChildIface;
typedef std::shared_ptr<I_GrandChildIface> I_GrandChildIfaceP;
typedef std::weak_ptr  <I_GrandChildIface> I_GrandChildIfaceW;

/** @interface GrandChild
 * See also the corresponding C++ servant class I_GrandChildIface. */
/// See also the corresponding IDL class GrandChild.
class I_GrandChildIface : public virtual I_DescendantIface
{
protected:
  explicit                               I_GrandChildIface ();
  virtual /*Des*/                       ~I_GrandChildIface () override = 0;
public:
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::GrandChild"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChildIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChildIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_GrandChildIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_GrandChildIfaceP&);
I_GrandChildIface* operator->* (GrandChildHandle &sh, Rapicorn::Aida::_ServantType);
GrandChildHandle operator->* (I_GrandChildIface *obj, Rapicorn::Aida::_HandleType);

class I_QuickIfaceIface;
typedef std::shared_ptr<I_QuickIfaceIface> I_QuickIfaceIfaceP;
typedef std::weak_ptr  <I_QuickIfaceIface> I_QuickIfaceIfaceW;

/** @interface QuickIface
 * See also the corresponding C++ servant class I_QuickIfaceIface. */
/// See also the corresponding IDL class QuickIface.
class I_QuickIfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_QuickIfaceIface ();
  virtual /*Des*/                       ~I_QuickIfaceIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::QuickIface"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          simple_function   (int i = 9); 	///< See QuickIface::simple_function()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIfaceIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIfaceIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_QuickIfaceIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_QuickIfaceIfaceP&);
I_QuickIfaceIface* operator->* (QuickIfaceHandle &sh, Rapicorn::Aida::_ServantType);
QuickIfaceHandle operator->* (I_QuickIfaceIface *obj, Rapicorn::Aida::_HandleType);

class I_MethodTestInterfaceIface;
typedef std::shared_ptr<I_MethodTestInterfaceIface> I_MethodTestInterfaceIfaceP;
typedef std::weak_ptr  <I_MethodTestInterfaceIface> I_MethodTestInterfaceIfaceW;

/** @interface MethodTestInterface
 * See also the corresponding C++ servant class I_MethodTestInterfaceIface. */
/// See also the corresponding IDL class MethodTestInterface.
class I_MethodTestInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_MethodTestInterfaceIface ();
  virtual /*Des*/                       ~I_MethodTestInterfaceIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::MethodTestInterface"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          method_with_void           (); 	///< See MethodTestInterface::method_with_void()
  virtual bool                          method_with_bools          (bool input,
                                                                    bool optval = 0); 	///< See MethodTestInterface::method_with_bools()
  virtual int                           method_with_ints32         (int input,
                                                                    int optval = -2); 	///< See MethodTestInterface::method_with_ints32()
  virtual Rapicorn::Aida::int64         method_with_ints64         (Rapicorn::Aida::int64 input,
                                                                    Rapicorn::Aida::int64 optval = 576460752303423488); 	///< See MethodTestInterface::method_with_ints64()
  virtual double                        method_with_floats         (double input,
                                                                    double optval = 309.9); 	///< See MethodTestInterface::method_with_floats()
  virtual std::string                   method_with_string         (const std::string &input,
                                                                    const std::string &optval = "default"); 	///< See MethodTestInterface::method_with_string()
  virtual QuickEnum                     method_with_enum           (QuickEnum input,
                                                                    QuickEnum optval = QuickEnum (0)); 	///< See MethodTestInterface::method_with_enum()
  virtual QuickRecord                   method_with_record         (const QuickRecord &input,
                                                                    const QuickRecord &optval = QuickRecord()); 	///< See MethodTestInterface::method_with_record()
  virtual QuickSequence                 method_with_sequence       (const QuickSequence &input,
                                                                    const QuickSequence &optval = QuickSequence()); 	///< See MethodTestInterface::method_with_sequence()
  virtual I_GrandChildIfaceP            method_with_interface      (I_GrandChildIface &input,
                                                                    I_GrandChildIface &optval = *(I_GrandChildIface*) NULL); 	///< See MethodTestInterface::method_with_interface()
  virtual Rapicorn::Aida::Any           method_with_anys           (const Rapicorn::Aida::Any &input,
                                                                    const Rapicorn::Aida::Any &optval); 	///< See MethodTestInterface::method_with_anys()
  virtual I_QuickIfaceIfaceP            method_with_quickiface     (I_QuickIfaceIface &input,
                                                                    I_QuickIfaceIface &iface0 = *(I_QuickIfaceIface*) NULL); 	///< See MethodTestInterface::method_with_quickiface()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterfaceIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterfaceIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_MethodTestInterfaceIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_MethodTestInterfaceIfaceP&);
I_MethodTestInterfaceIface* operator->* (MethodTestInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
MethodTestInterfaceHandle operator->* (I_MethodTestInterfaceIface *obj, Rapicorn::Aida::_HandleType);

class I_SignalTestInterfaceIface;
typedef std::shared_ptr<I_SignalTestInterfaceIface> I_SignalTestInterfaceIfaceP;
typedef std::weak_ptr  <I_SignalTestInterfaceIface> I_SignalTestInterfaceIfaceW;

/** @interface SignalTestInterface
 * See also the corresponding C++ servant class I_SignalTestInterfaceIface. */
/// See also the corresponding IDL class SignalTestInterface.
class I_SignalTestInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_SignalTestInterfaceIface ();
  virtual /*Des*/                       ~I_SignalTestInterfaceIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::SignalTestInterface"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_result;
  typedef Rapicorn::Aida::AsyncSignal<bool ()> Signal_bool_result;
  typedef Rapicorn::Aida::AsyncSignal<int ()> Signal_int32_result;
  typedef Rapicorn::Aida::AsyncSignal<Rapicorn::Aida::int64 ()> Signal_int64_result;
  typedef Rapicorn::Aida::AsyncSignal<double ()> Signal_float64_result;
  typedef Rapicorn::Aida::AsyncSignal<std::string ()> Signal_string_result;
  typedef Rapicorn::Aida::AsyncSignal<QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Aida::AsyncSignal<QuickRecord ()> Signal_record_result;
  typedef Rapicorn::Aida::AsyncSignal<QuickSequence ()> Signal_sequence_result;
  typedef Rapicorn::Aida::AsyncSignal<I_GrandChildIfaceP ()> Signal_interface_result;
  typedef Rapicorn::Aida::AsyncSignal<Rapicorn::Aida::Any ()> Signal_any_result;
  typedef Rapicorn::Aida::AsyncSignal<I_SignalTestInterfaceIfaceP ()> Signal_self_result;
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_arg;
  typedef Rapicorn::Aida::Signal<void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Aida::Signal<void (int i)> Signal_int32_arg;
  typedef Rapicorn::Aida::Signal<void (Rapicorn::Aida::int64 i)> Signal_int64_arg;
  typedef Rapicorn::Aida::Signal<void (double f)> Signal_float64_arg;
  typedef Rapicorn::Aida::Signal<void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Aida::Signal<void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Aida::Signal<void (const QuickRecord &r)> Signal_record_arg;
  typedef Rapicorn::Aida::Signal<void (const QuickSequence &s)> Signal_sequence_arg;
  typedef Rapicorn::Aida::Signal<void (I_GrandChildIface &i)> Signal_interface_arg;
  typedef Rapicorn::Aida::Signal<void (const Rapicorn::Aida::Any &a)> Signal_any_arg;
  typedef Rapicorn::Aida::Signal<void (I_SignalTestInterfaceIface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int32_result sig_int32_result;
  Signal_int64_result sig_int64_result;
  Signal_float64_result sig_float64_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_any_result sig_any_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int32_arg sig_int32_arg;
  Signal_int64_arg sig_int64_arg;
  Signal_float64_arg sig_float64_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_any_arg sig_any_arg;
  Signal_self_args sig_self_args;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterfaceIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterfaceIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SignalTestInterfaceIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SignalTestInterfaceIfaceP&);
I_SignalTestInterfaceIface* operator->* (SignalTestInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
SignalTestInterfaceHandle operator->* (I_SignalTestInterfaceIface *obj, Rapicorn::Aida::_HandleType);

class I_ChildInheritingSignalsIface;
typedef std::shared_ptr<I_ChildInheritingSignalsIface> I_ChildInheritingSignalsIfaceP;
typedef std::weak_ptr  <I_ChildInheritingSignalsIface> I_ChildInheritingSignalsIfaceW;

/** @interface ChildInheritingSignals
 * See also the corresponding C++ servant class I_ChildInheritingSignalsIface. */
/// See also the corresponding IDL class ChildInheritingSignals.
class I_ChildInheritingSignalsIface : public virtual I_SignalTestInterfaceIface
{
protected:
  explicit                               I_ChildInheritingSignalsIface ();
  virtual /*Des*/                       ~I_ChildInheritingSignalsIface () override = 0;
public:
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::ChildInheritingSignals"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  typedef Rapicorn::Aida::Signal<void (I_ChildInheritingSignalsIface &c, I_SignalTestInterfaceIface &p, const Rapicorn::Aida::Any &a, int i, const QuickRecord &r, const QuickSequence &s)> Signal_child_signal;
  Signal_child_signal sig_child_signal;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignalsIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignalsIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildInheritingSignalsIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildInheritingSignalsIfaceP&);
I_ChildInheritingSignalsIface* operator->* (ChildInheritingSignalsHandle &sh, Rapicorn::Aida::_ServantType);
ChildInheritingSignalsHandle operator->* (I_ChildInheritingSignalsIface *obj, Rapicorn::Aida::_HandleType);

class I_AnotherChildIface;
typedef std::shared_ptr<I_AnotherChildIface> I_AnotherChildIfaceP;
typedef std::weak_ptr  <I_AnotherChildIface> I_AnotherChildIfaceW;

/** @interface AnotherChild
 * See also the corresponding C++ servant class I_AnotherChildIface. */
/// See also the corresponding IDL class AnotherChild.
class I_AnotherChildIface : public virtual I_SignalTestInterfaceIface
{
protected:
  explicit                               I_AnotherChildIface ();
  virtual /*Des*/                       ~I_AnotherChildIface () override = 0;
public:
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::AnotherChild"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChildIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChildIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_AnotherChildIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_AnotherChildIfaceP&);
I_AnotherChildIface* operator->* (AnotherChildHandle &sh, Rapicorn::Aida::_ServantType);
AnotherChildHandle operator->* (I_AnotherChildIface *obj, Rapicorn::Aida::_HandleType);

class I_PropertyTesterIface;
typedef std::shared_ptr<I_PropertyTesterIface> I_PropertyTesterIfaceP;
typedef std::weak_ptr  <I_PropertyTesterIface> I_PropertyTesterIfaceW;

/** @interface PropertyTester
 * See also the corresponding C++ servant class I_PropertyTesterIface. */
/// See also the corresponding IDL class PropertyTester.
class I_PropertyTesterIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_PropertyTesterIface ();
  virtual /*Des*/                       ~I_PropertyTesterIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "InterfaceTests::PropertyTester"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual bool                          bool_prop      () const = 0; 	///< See PropertyTester::bool_prop
  virtual void                          bool_prop      (bool) = 0; 	///< See PropertyTester::bool_prop
  virtual int                           int32_prop     () const = 0; 	///< See PropertyTester::int32_prop
  virtual void                          int32_prop     (int) = 0; 	///< See PropertyTester::int32_prop
  virtual Rapicorn::Aida::int64         int64_prop     () const = 0; 	///< See PropertyTester::int64_prop
  virtual void                          int64_prop     (Rapicorn::Aida::int64) = 0; 	///< See PropertyTester::int64_prop
  virtual double                        float64_prop   () const = 0; 	///< See PropertyTester::float64_prop
  virtual void                          float64_prop   (double) = 0; 	///< See PropertyTester::float64_prop
  virtual std::string                   string_prop    () const = 0; 	///< See PropertyTester::string_prop
  virtual void                          string_prop    (const std::string&) = 0; 	///< See PropertyTester::string_prop
  virtual QuickEnum                     enum_prop      () const = 0; 	///< See PropertyTester::enum_prop
  virtual void                          enum_prop      (QuickEnum) = 0; 	///< See PropertyTester::enum_prop
  virtual QuickRecord                   record_prop    () const = 0; 	///< See PropertyTester::record_prop
  virtual void                          record_prop    (const QuickRecord&) = 0; 	///< See PropertyTester::record_prop
  virtual QuickSequence                 sequence_prop  () const = 0; 	///< See PropertyTester::sequence_prop
  virtual void                          sequence_prop  (const QuickSequence&) = 0; 	///< See PropertyTester::sequence_prop
  virtual I_GrandChildIfaceP            interface_prop () const = 0; 	///< See PropertyTester::interface_prop
  virtual void                          interface_prop (I_GrandChildIface*) = 0; 	///< See PropertyTester::interface_prop
  virtual I_PropertyTesterIfaceP        self_prop      () const = 0; 	///< See PropertyTester::self_prop
  virtual void                          self_prop      (I_PropertyTesterIface*) = 0; 	///< See PropertyTester::self_prop
  virtual Rapicorn::Aida::Any           any_prop       () const = 0; 	///< See PropertyTester::any_prop
  virtual void                          any_prop       (const Rapicorn::Aida::Any&) = 0; 	///< See PropertyTester::any_prop
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTesterIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTesterIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PropertyTesterIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PropertyTesterIfaceP&);
I_PropertyTesterIface* operator->* (PropertyTesterHandle &sh, Rapicorn::Aida::_ServantType);
PropertyTesterHandle operator->* (I_PropertyTesterIface *obj, Rapicorn::Aida::_HandleType);
} // InterfaceTests

namespace RapicornAidaTest {

class I_ButtonAreaIface;
typedef std::shared_ptr<I_ButtonAreaIface> I_ButtonAreaIfaceP;
typedef std::weak_ptr  <I_ButtonAreaIface> I_ButtonAreaIfaceW;

/** @interface ButtonArea
 * See also the corresponding C++ servant class I_ButtonAreaIface. */
/// See also the corresponding IDL class ButtonArea.
class I_ButtonAreaIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_ButtonAreaIface ();
  virtual /*Des*/                       ~I_ButtonAreaIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "RapicornAidaTest::ButtonArea"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual std::string                   on_click   () const = 0; 	///< See ButtonArea::on_click
  virtual void                          on_click   (const std::string&) = 0; 	///< See ButtonArea::on_click
  virtual std::string                   on_click2  () const = 0; 	///< See ButtonArea::on_click2
  virtual void                          on_click2  (const std::string&) = 0; 	///< See ButtonArea::on_click2
  virtual std::string                   on_click3  () const = 0; 	///< See ButtonArea::on_click3
  virtual void                          on_click3  (const std::string&) = 0; 	///< See ButtonArea::on_click3
  virtual ClickType                     click_type () const = 0; 	///< See ButtonArea::click_type
  virtual void                          click_type (ClickType) = 0; 	///< See ButtonArea::click_type
  typedef Rapicorn::Aida::AsyncSignal<bool ()> Signal_check_activate;
  typedef Rapicorn::Aida::Signal<void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonAreaIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonAreaIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ButtonAreaIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ButtonAreaIfaceP&);
I_ButtonAreaIface* operator->* (ButtonAreaHandle &sh, Rapicorn::Aida::_ServantType);
ButtonAreaHandle operator->* (I_ButtonAreaIface *obj, Rapicorn::Aida::_HandleType);

class I_PureMethodsIface;

class I_PureMethodsIface;
typedef std::shared_ptr<I_PureMethodsIface> I_PureMethodsIfaceP;
typedef std::weak_ptr  <I_PureMethodsIface> I_PureMethodsIfaceW;

/** @interface PureMethods
 * See also the corresponding C++ servant class I_PureMethodsIface. */
/// See also the corresponding IDL class PureMethods.
class I_PureMethodsIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_PureMethodsIface ();
  virtual /*Des*/                       ~I_PureMethodsIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "RapicornAidaTest::PureMethods"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual int                           pure_method        (double f) = 0; 	///< See PureMethods::pure_method()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethodsIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethodsIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PureMethodsIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PureMethodsIfaceP&);
I_PureMethodsIface* operator->* (PureMethodsHandle &sh, Rapicorn::Aida::_ServantType);
PureMethodsHandle operator->* (I_PureMethodsIface *obj, Rapicorn::Aida::_HandleType);
} // RapicornAidaTest

namespace Other {

class I_NameTestsIface;
typedef std::shared_ptr<I_NameTestsIface> I_NameTestsIfaceP;
typedef std::weak_ptr  <I_NameTestsIface> I_NameTestsIfaceW;

/** @interface NameTests
 * See also the corresponding C++ servant class I_NameTestsIface. */
/// See also the corresponding IDL class NameTests.
class I_NameTestsIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_NameTestsIface ();
  virtual /*Des*/                       ~I_NameTestsIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "Other::NameTests"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          args_from_other_namespace (const InterfaceTests::QuickRecord &qr,
                                                                   RapicornAidaTest::ClickType qe,
                                                                   const OtherNamespace::SomeRecord &sr); 	///< See NameTests::args_from_other_namespace()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_NameTestsIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_NameTestsIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_NameTestsIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_NameTestsIfaceP&);
I_NameTestsIface* operator->* (NameTestsHandle &sh, Rapicorn::Aida::_ServantType);
NameTestsHandle operator->* (I_NameTestsIface *obj, Rapicorn::Aida::_HandleType);
} // Other

namespace BseTest {

class I_CompressorIface;
typedef std::shared_ptr<I_CompressorIface> I_CompressorIfaceP;
typedef std::weak_ptr  <I_CompressorIface> I_CompressorIfaceW;

/** @interface Compressor
 * See also the corresponding C++ servant class I_CompressorIface. */
/// See also the corresponding IDL class Compressor.
class I_CompressorIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_CompressorIface ();
  virtual /*Des*/                       ~I_CompressorIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "BseTest::Compressor"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual double                        threshold () const = 0; 	///< See Compressor::threshold
  virtual void                          threshold (double) = 0; 	///< See Compressor::threshold
  virtual double                        ratio     () const = 0; 	///< See Compressor::ratio
  virtual void                          ratio     (double) = 0; 	///< See Compressor::ratio
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_CompressorIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_CompressorIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_CompressorIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_CompressorIfaceP&);
I_CompressorIface* operator->* (CompressorHandle &sh, Rapicorn::Aida::_ServantType);
CompressorHandle operator->* (I_CompressorIface *obj, Rapicorn::Aida::_HandleType);

class I_SoundModuleIface;
typedef std::shared_ptr<I_SoundModuleIface> I_SoundModuleIfaceP;
typedef std::weak_ptr  <I_SoundModuleIface> I_SoundModuleIfaceW;

/** @interface SoundModule
 * See also the corresponding C++ servant class I_SoundModuleIface. */
/// See also the corresponding IDL class SoundModule.
class I_SoundModuleIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_SoundModuleIface ();
  virtual /*Des*/                       ~I_SoundModuleIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual std::string                    __aida_type_name__ () const	{ return "BseTest::SoundModule"; }
  virtual void                           __aida_typelist__ (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SoundModuleIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SoundModuleIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SoundModuleIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SoundModuleIfaceP&);
I_SoundModuleIface* operator->* (SoundModuleHandle &sh, Rapicorn::Aida::_ServantType);
SoundModuleHandle operator->* (I_SoundModuleIface *obj, Rapicorn::Aida::_HandleType);
} // BseTest

// --- Interface Skeletons ---

void
MandatoryNamespace::I_FirstInterfaceIface::void_func ()
{
}

double
InterfaceTests::I_UIWidgetAreaIface::simple_method ()
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::single_arg (int n)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::single_arg2 (int n)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::two_args (int n,
                                               double r)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::two_args2 (int n,
                                                double r)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::multi_args (bool b,
                                                 Rapicorn::Aida::int64 n,
                                                 double r,
                                                 int i,
                                                 const std::string &s,
                                                 double y)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetAreaIface::self_method (InterfaceTests::I_UIWidgetAreaIface &ba1,
                                                  InterfaceTests::I_UIWidgetAreaIface &ba2)
{
  return 0;
}

void
InterfaceTests::I_UIWidgetAreaIface::void_method ()
{
}

std::string
InterfaceTests::I_UIWidgetAreaIface::on_click2out ()
{
  return "";
}

void
InterfaceTests::I_UIWidgetAreaIface::on_click2in (const std::string &command)
{
}

void
InterfaceTests::I_QuickIfaceIface::simple_function (int i)
{
}

void
InterfaceTests::I_MethodTestInterfaceIface::method_with_void ()
{
}

bool
InterfaceTests::I_MethodTestInterfaceIface::method_with_bools (bool input,
                                                               bool optval)
{
  return 0;
}

int
InterfaceTests::I_MethodTestInterfaceIface::method_with_ints32 (int input,
                                                                int optval)
{
  return 0;
}

Rapicorn::Aida::int64
InterfaceTests::I_MethodTestInterfaceIface::method_with_ints64 (Rapicorn::Aida::int64 input,
                                                                Rapicorn::Aida::int64 optval)
{
  return 0;
}

double
InterfaceTests::I_MethodTestInterfaceIface::method_with_floats (double input,
                                                                double optval)
{
  return 0;
}

std::string
InterfaceTests::I_MethodTestInterfaceIface::method_with_string (const std::string &input,
                                                                const std::string &optval)
{
  return "";
}

InterfaceTests::QuickEnum
InterfaceTests::I_MethodTestInterfaceIface::method_with_enum (InterfaceTests::QuickEnum input,
                                                              InterfaceTests::QuickEnum optval)
{
  return InterfaceTests::QuickEnum (0);
}

InterfaceTests::QuickRecord
InterfaceTests::I_MethodTestInterfaceIface::method_with_record (const InterfaceTests::QuickRecord &input,
                                                                const InterfaceTests::QuickRecord &optval)
{
  return InterfaceTests::QuickRecord();
}

InterfaceTests::QuickSequence
InterfaceTests::I_MethodTestInterfaceIface::method_with_sequence (const InterfaceTests::QuickSequence &input,
                                                                  const InterfaceTests::QuickSequence &optval)
{
  return InterfaceTests::QuickSequence();
}

InterfaceTests::I_GrandChildIfaceP
InterfaceTests::I_MethodTestInterfaceIface::method_with_interface (InterfaceTests::I_GrandChildIface &input,
                                                                   InterfaceTests::I_GrandChildIface &optval)
{
  return 0;
}

Rapicorn::Aida::Any
InterfaceTests::I_MethodTestInterfaceIface::method_with_anys (const Rapicorn::Aida::Any &input,
                                                              const Rapicorn::Aida::Any &optval)
{
  return Rapicorn::Aida::Any();
}

InterfaceTests::I_QuickIfaceIfaceP
InterfaceTests::I_MethodTestInterfaceIface::method_with_quickiface (InterfaceTests::I_QuickIfaceIface &input,
                                                                    InterfaceTests::I_QuickIfaceIface &iface0)
{
  return 0;
}

void
Other::I_NameTestsIface::args_from_other_namespace (const InterfaceTests::QuickRecord &qr,
                                                    RapicornAidaTest::ClickType qe,
                                                    const OtherNamespace::SomeRecord &sr)
{
}


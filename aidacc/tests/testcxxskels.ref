// --- Generated by AidaCxxStub ---

// --- ServerHH Boilerplate ---
#include <rapicorn-core.hh>
namespace Rapicorn { namespace Aida {
constexpr struct _ServantType {} _servant;
constexpr struct _HandleType {} _handle;
} } // Rapicorn::Aida

namespace Rapicorn { namespace Aida {
class TestServerBase : public virtual PropertyHostInterface {
public:
  explicit             TestServerBase ()            {}
  virtual             ~TestServerBase ()            {}
  virtual uint64_t     _orbid         () const      { return uint64_t (this); }
};
} } // Rapicorn::Aida

#include <rapicorn-core.hh> // for rcore/signal.hh
using Rapicorn::Signals::slot;

// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

/** @interface FirstInterface
 * See also the corresponding C++ servant class I_FirstInterface_Interface. */
/// See also the corresponding IDL class FirstInterface.
class I_FirstInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_FirstInterface_Interface ();
  virtual /*Des*/                       ~I_FirstInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          void_func                  ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_FirstInterface_Interface*&);
I_FirstInterface_Interface* operator->* (FirstInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
FirstInterfaceHandle operator->* (I_FirstInterface_Interface *obj, Rapicorn::Aida::_HandleType);

typedef Rapicorn::Aida::Any AliasAny;

typedef bool AliasBool;

typedef int AliasInt32;

typedef Rapicorn::Aida::int64_t AliasInt64;

typedef double AliasFloat;

typedef std::string AliasString;

typedef XFooRecord AliasRecord;

typedef XFooSequence AliasSequence;

typedef ExtensiveEnum AliasEnum;
} // MandatoryNamespace

namespace Auxdata {

typedef bool AuxBool;

typedef int Aux32;

typedef Rapicorn::Aida::int64_t Aux64;

typedef double AuxF64;

typedef std::string AuxStr;
} // Auxdata

namespace InterfaceTests {

/** @interface UIWidgetArea
 * See also the corresponding C++ servant class I_UIWidgetArea_Interface. */
/// See also the corresponding IDL class UIWidgetArea.
class I_UIWidgetArea_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_UIWidgetArea_Interface ();
  virtual /*Des*/                       ~I_UIWidgetArea_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual bool                          dummy    () const = 0;
  virtual void                          dummy    (bool) = 0;
  virtual std::string                   on_click () const = 0;
  virtual void                          on_click (const std::string&) = 0;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, double (I_UIWidgetArea_Interface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double                        simple_method            ();
  virtual double                        single_arg               (int n);
  virtual double                        single_arg2              (int n = 5);
  virtual double                        two_args                 (int n,
                                                                  double r);
  virtual double                        two_args2                (int n = 6,
                                                                  double r = 7.7);
  virtual double                        multi_args               (bool b,
                                                                  Rapicorn::Aida::int64_t n,
                                                                  double r,
                                                                  int i,
                                                                  const std::string &s = "String ding",
                                                                  double y = 5);
  virtual double                        self_method              (I_UIWidgetArea_Interface &ba1,
                                                                  I_UIWidgetArea_Interface &ba2);
  virtual void                          void_method              ();
  virtual std::string                   on_click2out             ();
  virtual void                          on_click2in              (const std::string &command);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetArea_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetArea_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_UIWidgetArea_Interface*&);
I_UIWidgetArea_Interface* operator->* (UIWidgetAreaHandle &sh, Rapicorn::Aida::_ServantType);
UIWidgetAreaHandle operator->* (I_UIWidgetArea_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface Parent
 * See also the corresponding C++ servant class I_Parent_Interface. */
/// See also the corresponding IDL class Parent.
class I_Parent_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_Parent_Interface ();
  virtual /*Des*/                       ~I_Parent_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Parent_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Parent_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Parent_Interface*&);
I_Parent_Interface* operator->* (ParentHandle &sh, Rapicorn::Aida::_ServantType);
ParentHandle operator->* (I_Parent_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface Child
 * See also the corresponding C++ servant class I_Child_Interface. */
/// See also the corresponding IDL class Child.
class I_Child_Interface : public virtual I_Parent_Interface
{
protected:
  explicit                               I_Child_Interface ();
  virtual /*Des*/                       ~I_Child_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Child_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Child_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Child_Interface*&);
I_Child_Interface* operator->* (ChildHandle &sh, Rapicorn::Aida::_ServantType);
ChildHandle operator->* (I_Child_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface Descendant
 * See also the corresponding C++ servant class I_Descendant_Interface. */
/// See also the corresponding IDL class Descendant.
class I_Descendant_Interface : public virtual I_Child_Interface
{
protected:
  explicit                               I_Descendant_Interface ();
  virtual /*Des*/                       ~I_Descendant_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Descendant_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Descendant_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Descendant_Interface*&);
I_Descendant_Interface* operator->* (DescendantHandle &sh, Rapicorn::Aida::_ServantType);
DescendantHandle operator->* (I_Descendant_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface GrandChild
 * See also the corresponding C++ servant class I_GrandChild_Interface. */
/// See also the corresponding IDL class GrandChild.
class I_GrandChild_Interface : public virtual I_Descendant_Interface
{
protected:
  explicit                               I_GrandChild_Interface ();
  virtual /*Des*/                       ~I_GrandChild_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChild_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChild_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_GrandChild_Interface*&);
I_GrandChild_Interface* operator->* (GrandChildHandle &sh, Rapicorn::Aida::_ServantType);
GrandChildHandle operator->* (I_GrandChild_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface QuickIface
 * See also the corresponding C++ servant class I_QuickIface_Interface. */
/// See also the corresponding IDL class QuickIface.
class I_QuickIface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_QuickIface_Interface ();
  virtual /*Des*/                       ~I_QuickIface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          simple_function        (int i = 9);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_QuickIface_Interface*&);
I_QuickIface_Interface* operator->* (QuickIfaceHandle &sh, Rapicorn::Aida::_ServantType);
QuickIfaceHandle operator->* (I_QuickIface_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface MethodTestInterface
 * See also the corresponding C++ servant class I_MethodTestInterface_Interface. */
/// See also the corresponding IDL class MethodTestInterface.
class I_MethodTestInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_MethodTestInterface_Interface ();
  virtual /*Des*/                       ~I_MethodTestInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          method_with_void                ();
  virtual bool                          method_with_bools               (bool input,
                                                                         bool optval = 0);
  virtual int                           method_with_ints32              (int input,
                                                                         int optval = -2);
  virtual Rapicorn::Aida::int64_t       method_with_ints64              (Rapicorn::Aida::int64_t input,
                                                                         Rapicorn::Aida::int64_t optval = 576460752303423488);
  virtual double                        method_with_floats              (double input,
                                                                         double optval = 309.9);
  virtual std::string                   method_with_string              (const std::string &input,
                                                                         const std::string &optval = "default");
  virtual QuickEnum                     method_with_enum                (QuickEnum input,
                                                                         QuickEnum optval = QuickEnum (0));
  virtual QuickRecord                   method_with_record              (const QuickRecord &input,
                                                                         const QuickRecord &optval = QuickRecord());
  virtual QuickSequence                 method_with_sequence            (const QuickSequence &input,
                                                                         const QuickSequence &optval = QuickSequence());
  virtual I_GrandChild_Interface*       method_with_interface           (I_GrandChild_Interface &input,
                                                                         I_GrandChild_Interface &optval = *(I_GrandChild_Interface*) NULL);
  virtual Rapicorn::Aida::Any           method_with_anys                (const Rapicorn::Aida::Any &input,
                                                                         const Rapicorn::Aida::Any &optval);
  virtual I_QuickIface_Interface*       method_with_quickiface          (I_QuickIface_Interface &input,
                                                                         I_QuickIface_Interface &iface0 = *(I_QuickIface_Interface*) NULL);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_MethodTestInterface_Interface*&);
I_MethodTestInterface_Interface* operator->* (MethodTestInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
MethodTestInterfaceHandle operator->* (I_MethodTestInterface_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface SignalTestInterface
 * See also the corresponding C++ servant class I_SignalTestInterface_Interface. */
/// See also the corresponding IDL class SignalTestInterface.
class I_SignalTestInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_SignalTestInterface_Interface ();
  virtual /*Des*/                       ~I_SignalTestInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, bool ()> Signal_bool_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, int ()> Signal_int32_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, Rapicorn::Aida::int64_t ()> Signal_int64_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, double ()> Signal_float64_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, std::string ()> Signal_string_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickRecord ()> Signal_record_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickSequence ()> Signal_sequence_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_GrandChild_Interface* ()> Signal_interface_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, Rapicorn::Aida::Any ()> Signal_any_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_SignalTestInterface_Interface* ()> Signal_self_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (int i)> Signal_int32_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (Rapicorn::Aida::int64_t i)> Signal_int64_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (double f)> Signal_float64_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickRecord &r)> Signal_record_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickSequence &s)> Signal_sequence_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_GrandChild_Interface &i)> Signal_interface_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const Rapicorn::Aida::Any &a)> Signal_any_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_SignalTestInterface_Interface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int32_result sig_int32_result;
  Signal_int64_result sig_int64_result;
  Signal_float64_result sig_float64_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_any_result sig_any_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int32_arg sig_int32_arg;
  Signal_int64_arg sig_int64_arg;
  Signal_float64_arg sig_float64_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_any_arg sig_any_arg;
  Signal_self_args sig_self_args;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SignalTestInterface_Interface*&);
I_SignalTestInterface_Interface* operator->* (SignalTestInterfaceHandle &sh, Rapicorn::Aida::_ServantType);
SignalTestInterfaceHandle operator->* (I_SignalTestInterface_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface ChildInheritingSignals
 * See also the corresponding C++ servant class I_ChildInheritingSignals_Interface. */
/// See also the corresponding IDL class ChildInheritingSignals.
class I_ChildInheritingSignals_Interface : public virtual I_SignalTestInterface_Interface
{
protected:
  explicit                               I_ChildInheritingSignals_Interface ();
  virtual /*Des*/                       ~I_ChildInheritingSignals_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  typedef Rapicorn::Signals::Signal<I_ChildInheritingSignals_Interface, void (I_ChildInheritingSignals_Interface &c, I_SignalTestInterface_Interface &p, const Rapicorn::Aida::Any &a, int i, const QuickRecord &r, const QuickSequence &s)> Signal_child_signal;
  Signal_child_signal sig_child_signal;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignals_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignals_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildInheritingSignals_Interface*&);
I_ChildInheritingSignals_Interface* operator->* (ChildInheritingSignalsHandle &sh, Rapicorn::Aida::_ServantType);
ChildInheritingSignalsHandle operator->* (I_ChildInheritingSignals_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface AnotherChild
 * See also the corresponding C++ servant class I_AnotherChild_Interface. */
/// See also the corresponding IDL class AnotherChild.
class I_AnotherChild_Interface : public virtual I_SignalTestInterface_Interface
{
protected:
  explicit                               I_AnotherChild_Interface ();
  virtual /*Des*/                       ~I_AnotherChild_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChild_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChild_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_AnotherChild_Interface*&);
I_AnotherChild_Interface* operator->* (AnotherChildHandle &sh, Rapicorn::Aida::_ServantType);
AnotherChildHandle operator->* (I_AnotherChild_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface PropertyTester
 * See also the corresponding C++ servant class I_PropertyTester_Interface. */
/// See also the corresponding IDL class PropertyTester.
class I_PropertyTester_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_PropertyTester_Interface ();
  virtual /*Des*/                       ~I_PropertyTester_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual bool                          bool_prop      () const = 0;
  virtual void                          bool_prop      (bool) = 0;
  virtual int                           int32_prop     () const = 0;
  virtual void                          int32_prop     (int) = 0;
  virtual Rapicorn::Aida::int64_t       int64_prop     () const = 0;
  virtual void                          int64_prop     (Rapicorn::Aida::int64_t) = 0;
  virtual double                        float64_prop   () const = 0;
  virtual void                          float64_prop   (double) = 0;
  virtual std::string                   string_prop    () const = 0;
  virtual void                          string_prop    (const std::string&) = 0;
  virtual QuickEnum                     enum_prop      () const = 0;
  virtual void                          enum_prop      (QuickEnum) = 0;
  virtual QuickRecord                   record_prop    () const = 0;
  virtual void                          record_prop    (const QuickRecord&) = 0;
  virtual QuickSequence                 sequence_prop  () const = 0;
  virtual void                          sequence_prop  (const QuickSequence&) = 0;
  virtual I_GrandChild_Interface*       interface_prop () const = 0;
  virtual void                          interface_prop (I_GrandChild_Interface*) = 0;
  virtual I_PropertyTester_Interface*   self_prop      () const = 0;
  virtual void                          self_prop      (I_PropertyTester_Interface*) = 0;
  virtual Rapicorn::Aida::Any           any_prop       () const = 0;
  virtual void                          any_prop       (const Rapicorn::Aida::Any&) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTester_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTester_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PropertyTester_Interface*&);
I_PropertyTester_Interface* operator->* (PropertyTesterHandle &sh, Rapicorn::Aida::_ServantType);
PropertyTesterHandle operator->* (I_PropertyTester_Interface *obj, Rapicorn::Aida::_HandleType);
} // InterfaceTests

namespace RapicornAidaTest {

/** @interface ButtonArea
 * See also the corresponding C++ servant class I_ButtonArea_Interface. */
/// See also the corresponding IDL class ButtonArea.
class I_ButtonArea_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_ButtonArea_Interface ();
  virtual /*Des*/                       ~I_ButtonArea_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual std::string                   on_click   () const = 0;
  virtual void                          on_click   (const std::string&) = 0;
  virtual std::string                   on_click2  () const = 0;
  virtual void                          on_click2  (const std::string&) = 0;
  virtual std::string                   on_click3  () const = 0;
  virtual void                          on_click3  (const std::string&) = 0;
  virtual ClickType                     click_type () const = 0;
  virtual void                          click_type (ClickType) = 0;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, bool (), Rapicorn::Signals::CollectorUntil0<bool> > Signal_check_activate;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonArea_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonArea_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ButtonArea_Interface*&);
I_ButtonArea_Interface* operator->* (ButtonAreaHandle &sh, Rapicorn::Aida::_ServantType);
ButtonAreaHandle operator->* (I_ButtonArea_Interface *obj, Rapicorn::Aida::_HandleType);

class I_PureMethods_Interface;

/** @interface PureMethods
 * See also the corresponding C++ servant class I_PureMethods_Interface. */
/// See also the corresponding IDL class PureMethods.
class I_PureMethods_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_PureMethods_Interface ();
  virtual /*Des*/                       ~I_PureMethods_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual int                           pure_method             (double f) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethods_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethods_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PureMethods_Interface*&);
I_PureMethods_Interface* operator->* (PureMethodsHandle &sh, Rapicorn::Aida::_ServantType);
PureMethodsHandle operator->* (I_PureMethods_Interface *obj, Rapicorn::Aida::_HandleType);
} // RapicornAidaTest

namespace Other {

/** @interface NameTests
 * See also the corresponding C++ servant class I_NameTests_Interface. */
/// See also the corresponding IDL class NameTests.
class I_NameTests_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_NameTests_Interface ();
  virtual /*Des*/                       ~I_NameTests_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          args_from_other_namespace (const InterfaceTests::QuickRecord &qr,
                                                                   RapicornAidaTest::ClickType qe,
                                                                   const OtherNamespace::SomeRecord &sr);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_NameTests_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_NameTests_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_NameTests_Interface*&);
I_NameTests_Interface* operator->* (NameTestsHandle &sh, Rapicorn::Aida::_ServantType);
NameTestsHandle operator->* (I_NameTests_Interface *obj, Rapicorn::Aida::_HandleType);
} // Other

namespace BseTest {

/** @interface Compressor
 * See also the corresponding C++ servant class I_Compressor_Interface. */
/// See also the corresponding IDL class Compressor.
class I_Compressor_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_Compressor_Interface ();
  virtual /*Des*/                       ~I_Compressor_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual double                        threshold () const = 0;
  virtual void                          threshold (double) = 0;
  virtual double                        ratio     () const = 0;
  virtual void                          ratio     (double) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Compressor_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Compressor_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Compressor_Interface*&);
I_Compressor_Interface* operator->* (CompressorHandle &sh, Rapicorn::Aida::_ServantType);
CompressorHandle operator->* (I_Compressor_Interface *obj, Rapicorn::Aida::_HandleType);

/** @interface SoundModule
 * See also the corresponding C++ servant class I_SoundModule_Interface. */
/// See also the corresponding IDL class SoundModule.
class I_SoundModule_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_SoundModule_Interface ();
  virtual /*Des*/                       ~I_SoundModule_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SoundModule_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SoundModule_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SoundModule_Interface*&);
I_SoundModule_Interface* operator->* (SoundModuleHandle &sh, Rapicorn::Aida::_ServantType);
SoundModuleHandle operator->* (I_SoundModule_Interface *obj, Rapicorn::Aida::_HandleType);
} // BseTest

// --- Interface Skeletons ---

void
MandatoryNamespace::I_FirstInterface_Interface::void_func ()
{
}

double
InterfaceTests::I_UIWidgetArea_Interface::simple_method ()
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::single_arg (int n)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::single_arg2 (int n)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::two_args (int n,
                                                    double r)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::two_args2 (int n,
                                                     double r)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::multi_args (bool b,
                                                      Rapicorn::Aida::int64_t n,
                                                      double r,
                                                      int i,
                                                      const std::string &s,
                                                      double y)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::self_method (InterfaceTests::I_UIWidgetArea_Interface &ba1,
                                                       InterfaceTests::I_UIWidgetArea_Interface &ba2)
{
  return 0;
}

void
InterfaceTests::I_UIWidgetArea_Interface::void_method ()
{
}

std::string
InterfaceTests::I_UIWidgetArea_Interface::on_click2out ()
{
  return "";
}

void
InterfaceTests::I_UIWidgetArea_Interface::on_click2in (const std::string &command)
{
}

void
InterfaceTests::I_QuickIface_Interface::simple_function (int i)
{
}

void
InterfaceTests::I_MethodTestInterface_Interface::method_with_void ()
{
}

bool
InterfaceTests::I_MethodTestInterface_Interface::method_with_bools (bool input,
                                                                    bool optval)
{
  return 0;
}

int
InterfaceTests::I_MethodTestInterface_Interface::method_with_ints32 (int input,
                                                                     int optval)
{
  return 0;
}

Rapicorn::Aida::int64_t
InterfaceTests::I_MethodTestInterface_Interface::method_with_ints64 (Rapicorn::Aida::int64_t input,
                                                                     Rapicorn::Aida::int64_t optval)
{
  return 0;
}

double
InterfaceTests::I_MethodTestInterface_Interface::method_with_floats (double input,
                                                                     double optval)
{
  return 0;
}

std::string
InterfaceTests::I_MethodTestInterface_Interface::method_with_string (const std::string &input,
                                                                     const std::string &optval)
{
  return "";
}

InterfaceTests::QuickEnum
InterfaceTests::I_MethodTestInterface_Interface::method_with_enum (InterfaceTests::QuickEnum input,
                                                                   InterfaceTests::QuickEnum optval)
{
  return InterfaceTests::QuickEnum (0);
}

InterfaceTests::QuickRecord
InterfaceTests::I_MethodTestInterface_Interface::method_with_record (const InterfaceTests::QuickRecord &input,
                                                                     const InterfaceTests::QuickRecord &optval)
{
  return InterfaceTests::QuickRecord();
}

InterfaceTests::QuickSequence
InterfaceTests::I_MethodTestInterface_Interface::method_with_sequence (const InterfaceTests::QuickSequence &input,
                                                                       const InterfaceTests::QuickSequence &optval)
{
  return InterfaceTests::QuickSequence();
}

InterfaceTests::I_GrandChild_Interface*
InterfaceTests::I_MethodTestInterface_Interface::method_with_interface (InterfaceTests::I_GrandChild_Interface &input,
                                                                        InterfaceTests::I_GrandChild_Interface &optval)
{
  return 0;
}

Rapicorn::Aida::Any
InterfaceTests::I_MethodTestInterface_Interface::method_with_anys (const Rapicorn::Aida::Any &input,
                                                                   const Rapicorn::Aida::Any &optval)
{
  return Rapicorn::Aida::Any();
}

InterfaceTests::I_QuickIface_Interface*
InterfaceTests::I_MethodTestInterface_Interface::method_with_quickiface (InterfaceTests::I_QuickIface_Interface &input,
                                                                         InterfaceTests::I_QuickIface_Interface &iface0)
{
  return 0;
}

void
Other::I_NameTests_Interface::args_from_other_namespace (const InterfaceTests::QuickRecord &qr,
                                                         RapicornAidaTest::ClickType qe,
                                                         const OtherNamespace::SomeRecord &sr)
{
}


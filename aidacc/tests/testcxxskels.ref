// --- Generated by AidaCxxStub ---

// --- ServerHH Boilerplate ---
#include <rapicorn-core.hh>

namespace Rapicorn { namespace Aida {
class TestServerBase : public virtual PropertyHostInterface {
public:
  explicit             TestServerBase ()            {}
  virtual             ~TestServerBase ()            {}
  virtual uint64_t     _rpc_id        () const      { return uint64_t (this); }
};
} } // Rapicorn::Aida

#include <rapicorn-core.hh> // for rcore/signal.hh
using Rapicorn::Signals::slot;

// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

enum Enum1 {
  E1_A = 1,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum1  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum1 &e) { e = Enum1 (frr.pop_evalue()); }

enum Enum1c {
  E1C_A = 1,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum1c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum1c &e) { e = Enum1c (frr.pop_evalue()); }

enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum2  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum2 &e) { e = Enum2 (frr.pop_evalue()); }

enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum2c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum2c &e) { e = Enum2c (frr.pop_evalue()); }

enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum3  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum3 &e) { e = Enum3 (frr.pop_evalue()); }

enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum3c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum3c &e) { e = Enum3c (frr.pop_evalue()); }

enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4a  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4a &e) { e = Enum4a (frr.pop_evalue()); }

enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4b  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4b &e) { e = Enum4b (frr.pop_evalue()); }

enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4c &e) { e = Enum4c (frr.pop_evalue()); }

enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4d  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4d &e) { e = Enum4d (frr.pop_evalue()); }

enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  ExtensiveEnum  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, ExtensiveEnum &e) { e = ExtensiveEnum (frr.pop_evalue()); }

/** @interface FirstInterface
 * See also the corresponding C++ class I_FirstInterface_Interface (server side). */
/// See also the corresponding IDL class FirstInterface.
class I_FirstInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_FirstInterface_Interface ();
  virtual /*Des*/                       ~I_FirstInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          void_func                  ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_FirstInterface_Interface*&);

/** @interface XFooRecord
 * See also the corresponding C++ class XFooRecordImpl (server side). */
/// See also the corresponding IDL class XFooRecord.
struct XFooRecordImpl
{
  bool                          single_bool;
  int                           single_num;
  double                        single_float;
  std::string                   single_string;
  int                           sibling1;
  int                           sibling2;
  int                           multi1;
  int                           multi2;
  int                           multi3;
  int                           multi4;
  ExtensiveEnum                 enum_field;
  I_FirstInterface_Interface*   iface1;
  I_FirstInterface_Interface*   iface2;
  I_FirstInterface_Interface*   iface3;
  Rapicorn::Aida::Any           any1;
  Rapicorn::Aida::Any           any2;
  Rapicorn::Aida::Any           any3;
  inline                        XFooRecordImpl () { single_bool = 0; single_num = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const XFooRecordImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, XFooRecordImpl&);

/** @interface XFooSequence
 * See also the corresponding C++ class XFooSequenceImpl (server side). */
/// See also the corresponding IDL class XFooSequence.
struct XFooSequenceImpl : public std::vector<bool>
{
  typedef std::vector<bool> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const XFooSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, XFooSequenceImpl&);

/** @interface IntSequence
 * See also the corresponding C++ class IntSequenceImpl (server side). */
/// See also the corresponding IDL class IntSequence.
struct IntSequenceImpl : public std::vector<int>
{
  typedef std::vector<int> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const IntSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, IntSequenceImpl&);

/** @interface FloatSequence
 * See also the corresponding C++ class FloatSequenceImpl (server side). */
/// See also the corresponding IDL class FloatSequence.
struct FloatSequenceImpl : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const FloatSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, FloatSequenceImpl&);

/** @interface StringSequence
 * See also the corresponding C++ class StringSequenceImpl (server side). */
/// See also the corresponding IDL class StringSequence.
struct StringSequenceImpl : public std::vector<std::string>
{
  typedef std::vector<std::string> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const StringSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, StringSequenceImpl&);

/** @interface ExtensiveEnumSequence
 * See also the corresponding C++ class ExtensiveEnumSequenceImpl (server side). */
/// See also the corresponding IDL class ExtensiveEnumSequence.
struct ExtensiveEnumSequenceImpl : public std::vector<ExtensiveEnum>
{
  typedef std::vector<ExtensiveEnum> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ExtensiveEnumSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, ExtensiveEnumSequenceImpl&);

/** @interface RecordSequence
 * See also the corresponding C++ class RecordSequenceImpl (server side). */
/// See also the corresponding IDL class RecordSequence.
struct RecordSequenceImpl : public std::vector<XFooRecordImpl>
{
  typedef std::vector<XFooRecordImpl> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const RecordSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, RecordSequenceImpl&);

/** @interface SequenceSequence
 * See also the corresponding C++ class SequenceSequenceImpl (server side). */
/// See also the corresponding IDL class SequenceSequence.
struct SequenceSequenceImpl : public std::vector<IntSequenceImpl>
{
  typedef std::vector<IntSequenceImpl> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SequenceSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, SequenceSequenceImpl&);

/** @interface InterfaceSequence
 * See also the corresponding C++ class InterfaceSequenceImpl (server side). */
/// See also the corresponding IDL class InterfaceSequence.
struct InterfaceSequenceImpl : public std::vector<I_FirstInterface_Interface*>
{
  typedef std::vector<I_FirstInterface_Interface*> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const InterfaceSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, InterfaceSequenceImpl&);

/** @interface AnySequence
 * See also the corresponding C++ class AnySequenceImpl (server side). */
/// See also the corresponding IDL class AnySequence.
struct AnySequenceImpl : public std::vector<Rapicorn::Aida::Any>
{
  typedef std::vector<Rapicorn::Aida::Any> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const AnySequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, AnySequenceImpl&);

/** @interface NestedTypesRec
 * See also the corresponding C++ class NestedTypesRecImpl (server side). */
/// See also the corresponding IDL class NestedTypesRec.
struct NestedTypesRecImpl
{
  XFooRecordImpl                rec;
  XFooSequenceImpl              seq;
  inline                        NestedTypesRecImpl () { }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NestedTypesRecImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, NestedTypesRecImpl&);

/** @interface NestedTypesSeq
 * See also the corresponding C++ class NestedTypesSeqImpl (server side). */
/// See also the corresponding IDL class NestedTypesSeq.
struct NestedTypesSeqImpl : public std::vector<NestedTypesRecImpl>
{
  typedef std::vector<NestedTypesRecImpl> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NestedTypesSeqImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, NestedTypesSeqImpl&);

typedef Rapicorn::Aida::Any AliasAny;

typedef bool AliasBool;

typedef int AliasInt;

typedef double AliasFloat;

typedef std::string AliasString;

typedef XFooRecordImpl AliasRecord;

typedef XFooSequenceImpl AliasSequence;

typedef ExtensiveEnum AliasEnum;

/** @interface NewRecord
 * See also the corresponding C++ class NewRecordImpl (server side). */
/// See also the corresponding IDL class NewRecord.
struct NewRecordImpl
{
  int                           i;
  Enum1                         enum1;
  XFooSequenceImpl              xfs;
  NestedTypesRecImpl            ntr;
  inline                        NewRecordImpl () { i = 0; enum1 = Enum1 (0); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NewRecordImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, NewRecordImpl&);

namespace Inner {

/** @interface InnerRecord
 * See also the corresponding C++ class InnerRecordImpl (server side). */
/// See also the corresponding IDL class InnerRecord.
struct InnerRecordImpl
{
  int                           x;
  int                           y;
  NewRecordImpl                 rec;
  inline                        InnerRecordImpl () { x = 0; y = 0; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const InnerRecordImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, InnerRecordImpl&);
} // Inner

/** @interface Refer2Inner
 * See also the corresponding C++ class Refer2InnerImpl (server side). */
/// See also the corresponding IDL class Refer2Inner.
struct Refer2InnerImpl
{
  Inner::InnerRecordImpl        r;
  inline                        Refer2InnerImpl () { }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const Refer2InnerImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, Refer2InnerImpl&);
} // MandatoryNamespace

namespace OtherNamespace {

/** @interface SomeRecord
 * See also the corresponding C++ class SomeRecordImpl (server side). */
/// See also the corresponding IDL class SomeRecord.
struct SomeRecordImpl
{
  MandatoryNamespace::NewRecordImpl r1;
  MandatoryNamespace::NewRecordImpl r2;
  MandatoryNamespace::Inner::InnerRecordImpl r3;
  MandatoryNamespace::Inner::InnerRecordImpl r4;
  inline                        SomeRecordImpl () { }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SomeRecordImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, SomeRecordImpl&);
} // OtherNamespace

namespace Auxdata {

typedef bool bfoo;

typedef int ifoo;

typedef double ffoo;

typedef std::string sfoo;
} // Auxdata

namespace InterfaceTests {

/** @interface UIWidgetArea
 * See also the corresponding C++ class I_UIWidgetArea_Interface (server side). */
/// See also the corresponding IDL class UIWidgetArea.
class I_UIWidgetArea_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_UIWidgetArea_Interface ();
  virtual /*Des*/                       ~I_UIWidgetArea_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual bool                          dummy    () const = 0;
  virtual void                          dummy    (bool) = 0;
  virtual std::string                   on_click () const = 0;
  virtual void                          on_click (const std::string&) = 0;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, double (I_UIWidgetArea_Interface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double                        simple_method            ();
  virtual double                        single_arg               (int n);
  virtual double                        single_arg2              (int n = 5);
  virtual double                        two_args                 (int n,
                                                                  double r);
  virtual double                        two_args2                (int n = 6,
                                                                  double r = 7.7);
  virtual double                        multi_args               (bool b,
                                                                  int n,
                                                                  double r,
                                                                  int i,
                                                                  const std::string &s = "String ding",
                                                                  double y = 5);
  virtual double                        self_method              (I_UIWidgetArea_Interface &ba1,
                                                                  I_UIWidgetArea_Interface &ba2);
  virtual void                          void_method              ();
  virtual std::string                   on_click2out             ();
  virtual void                          on_click2in              (const std::string &command);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetArea_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetArea_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_UIWidgetArea_Interface*&);

/** @interface Parent
 * See also the corresponding C++ class I_Parent_Interface (server side). */
/// See also the corresponding IDL class Parent.
class I_Parent_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_Parent_Interface ();
  virtual /*Des*/                       ~I_Parent_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Parent_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Parent_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Parent_Interface*&);

/** @interface Child
 * See also the corresponding C++ class I_Child_Interface (server side). */
/// See also the corresponding IDL class Child.
class I_Child_Interface : public virtual I_Parent_Interface
{
protected:
  explicit                               I_Child_Interface ();
  virtual /*Des*/                       ~I_Child_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Child_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Child_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Child_Interface*&);

/** @interface Descendant
 * See also the corresponding C++ class I_Descendant_Interface (server side). */
/// See also the corresponding IDL class Descendant.
class I_Descendant_Interface : public virtual I_Child_Interface
{
protected:
  explicit                               I_Descendant_Interface ();
  virtual /*Des*/                       ~I_Descendant_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Descendant_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Descendant_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Descendant_Interface*&);

/** @interface GrandChild
 * See also the corresponding C++ class I_GrandChild_Interface (server side). */
/// See also the corresponding IDL class GrandChild.
class I_GrandChild_Interface : public virtual I_Descendant_Interface
{
protected:
  explicit                               I_GrandChild_Interface ();
  virtual /*Des*/                       ~I_GrandChild_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChild_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChild_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_GrandChild_Interface*&);

enum QuickEnum {
  ZERO = 0,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  QuickEnum  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, QuickEnum &e) { e = QuickEnum (frr.pop_evalue()); }

/** @interface QuickRecord
 * See also the corresponding C++ class QuickRecordImpl (server side). */
/// See also the corresponding IDL class QuickRecord.
struct QuickRecordImpl
{
  int                           int1;
  int                           int2;
  inline                        QuickRecordImpl () { int1 = 0; int2 = 0; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const QuickRecordImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, QuickRecordImpl&);

/** @interface QuickSequence
 * See also the corresponding C++ class QuickSequenceImpl (server side). */
/// See also the corresponding IDL class QuickSequence.
struct QuickSequenceImpl : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const QuickSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, QuickSequenceImpl&);

/** @interface QuickIface
 * See also the corresponding C++ class I_QuickIface_Interface (server side). */
/// See also the corresponding IDL class QuickIface.
class I_QuickIface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_QuickIface_Interface ();
  virtual /*Des*/                       ~I_QuickIface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          simple_function        (int i = 9);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_QuickIface_Interface*&);

/** @interface MethodTestInterface
 * See also the corresponding C++ class I_MethodTestInterface_Interface (server side). */
/// See also the corresponding IDL class MethodTestInterface.
class I_MethodTestInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_MethodTestInterface_Interface ();
  virtual /*Des*/                       ~I_MethodTestInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          method_with_void                ();
  virtual bool                          method_with_bools               (bool input,
                                                                         bool optval = 0);
  virtual int                           method_with_ints                (int input,
                                                                         int optval = -2);
  virtual double                        method_with_floats              (double input,
                                                                         double optval = 309.9);
  virtual std::string                   method_with_string              (const std::string &input,
                                                                         const std::string &optval = "default");
  virtual QuickEnum                     method_with_enum                (QuickEnum input,
                                                                         QuickEnum optval = QuickEnum (0));
  virtual QuickRecordImpl               method_with_record              (const QuickRecordImpl &input,
                                                                         const QuickRecordImpl &optval = QuickRecordImpl());
  virtual QuickSequenceImpl             method_with_sequence            (const QuickSequenceImpl &input,
                                                                         const QuickSequenceImpl &optval = QuickSequenceImpl());
  virtual I_GrandChild_Interface*       method_with_interface           (I_GrandChild_Interface &input,
                                                                         I_GrandChild_Interface &optval = *(I_GrandChild_Interface*) NULL);
  virtual Rapicorn::Aida::Any           method_with_anys                (const Rapicorn::Aida::Any &input,
                                                                         const Rapicorn::Aida::Any &optval);
  virtual I_QuickIface_Interface*       method_with_quickiface          (I_QuickIface_Interface &input,
                                                                         I_QuickIface_Interface &iface0 = *(I_QuickIface_Interface*) NULL);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_MethodTestInterface_Interface*&);

/** @interface SignalTestInterface
 * See also the corresponding C++ class I_SignalTestInterface_Interface (server side). */
/// See also the corresponding IDL class SignalTestInterface.
class I_SignalTestInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_SignalTestInterface_Interface ();
  virtual /*Des*/                       ~I_SignalTestInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, bool ()> Signal_bool_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, int ()> Signal_int_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, double ()> Signal_float_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, std::string ()> Signal_string_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickRecordImpl ()> Signal_record_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickSequenceImpl ()> Signal_sequence_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_GrandChild_Interface* ()> Signal_interface_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, Rapicorn::Aida::Any ()> Signal_any_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_SignalTestInterface_Interface* ()> Signal_self_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (int i)> Signal_int_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (double f)> Signal_float_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickRecordImpl &r)> Signal_record_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickSequenceImpl &s)> Signal_sequence_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_GrandChild_Interface &i)> Signal_interface_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const Rapicorn::Aida::Any &a)> Signal_any_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_SignalTestInterface_Interface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int_result sig_int_result;
  Signal_float_result sig_float_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_any_result sig_any_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int_arg sig_int_arg;
  Signal_float_arg sig_float_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_any_arg sig_any_arg;
  Signal_self_args sig_self_args;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SignalTestInterface_Interface*&);

/** @interface ChildInheritingSignals
 * See also the corresponding C++ class I_ChildInheritingSignals_Interface (server side). */
/// See also the corresponding IDL class ChildInheritingSignals.
class I_ChildInheritingSignals_Interface : public virtual I_SignalTestInterface_Interface
{
protected:
  explicit                               I_ChildInheritingSignals_Interface ();
  virtual /*Des*/                       ~I_ChildInheritingSignals_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  typedef Rapicorn::Signals::Signal<I_ChildInheritingSignals_Interface, void (I_ChildInheritingSignals_Interface &c, I_SignalTestInterface_Interface &p, const Rapicorn::Aida::Any &a, int i, const QuickRecordImpl &r, const QuickSequenceImpl &s)> Signal_child_signal;
  Signal_child_signal sig_child_signal;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignals_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignals_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildInheritingSignals_Interface*&);

/** @interface AnotherChild
 * See also the corresponding C++ class I_AnotherChild_Interface (server side). */
/// See also the corresponding IDL class AnotherChild.
class I_AnotherChild_Interface : public virtual I_SignalTestInterface_Interface
{
protected:
  explicit                               I_AnotherChild_Interface ();
  virtual /*Des*/                       ~I_AnotherChild_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChild_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChild_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_AnotherChild_Interface*&);

/** @interface PropertyTester
 * See also the corresponding C++ class I_PropertyTester_Interface (server side). */
/// See also the corresponding IDL class PropertyTester.
class I_PropertyTester_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_PropertyTester_Interface ();
  virtual /*Des*/                       ~I_PropertyTester_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual bool                          bool_prop      () const = 0;
  virtual void                          bool_prop      (bool) = 0;
  virtual int                           int_prop       () const = 0;
  virtual void                          int_prop       (int) = 0;
  virtual double                        float_prop     () const = 0;
  virtual void                          float_prop     (double) = 0;
  virtual std::string                   string_prop    () const = 0;
  virtual void                          string_prop    (const std::string&) = 0;
  virtual QuickEnum                     enum_prop      () const = 0;
  virtual void                          enum_prop      (QuickEnum) = 0;
  virtual QuickRecordImpl               record_prop    () const = 0;
  virtual void                          record_prop    (const QuickRecordImpl&) = 0;
  virtual QuickSequenceImpl             sequence_prop  () const = 0;
  virtual void                          sequence_prop  (const QuickSequenceImpl&) = 0;
  virtual I_GrandChild_Interface*       interface_prop () const = 0;
  virtual void                          interface_prop (I_GrandChild_Interface*) = 0;
  virtual I_PropertyTester_Interface*   self_prop      () const = 0;
  virtual void                          self_prop      (I_PropertyTester_Interface*) = 0;
  virtual Rapicorn::Aida::Any           any_prop       () const = 0;
  virtual void                          any_prop       (const Rapicorn::Aida::Any&) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTester_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTester_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PropertyTester_Interface*&);
} // InterfaceTests

namespace RapicornAidaTest {

enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  ClickType  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, ClickType &e) { e = ClickType (frr.pop_evalue()); }

/** @interface ButtonArea
 * See also the corresponding C++ class I_ButtonArea_Interface (server side). */
/// See also the corresponding IDL class ButtonArea.
class I_ButtonArea_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_ButtonArea_Interface ();
  virtual /*Des*/                       ~I_ButtonArea_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual std::string                   on_click   () const = 0;
  virtual void                          on_click   (const std::string&) = 0;
  virtual std::string                   on_click2  () const = 0;
  virtual void                          on_click2  (const std::string&) = 0;
  virtual std::string                   on_click3  () const = 0;
  virtual void                          on_click3  (const std::string&) = 0;
  virtual ClickType                     click_type () const = 0;
  virtual void                          click_type (ClickType) = 0;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, bool (), Rapicorn::Signals::CollectorUntil0<bool> > Signal_check_activate;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonArea_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonArea_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ButtonArea_Interface*&);

class I_PureMethods_Interface;

/** @interface PureMethods
 * See also the corresponding C++ class I_PureMethods_Interface (server side). */
/// See also the corresponding IDL class PureMethods.
class I_PureMethods_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_PureMethods_Interface ();
  virtual /*Des*/                       ~I_PureMethods_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual int                           pure_method             (double f) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethods_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethods_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PureMethods_Interface*&);
} // RapicornAidaTest

namespace Rapicorn {

namespace Aida {

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum1>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum1"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum1c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum1c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum2>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum2"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum2c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum2c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum3>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum3"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum3c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum3c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4a>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4a"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4b>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4b"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4d>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4d"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::ExtensiveEnum>() { return EnumInfo::from_nsid ("MandatoryNamespace", "ExtensiveEnum"); }

template<> inline EnumInfo enum_info<InterfaceTests::QuickEnum>() { return EnumInfo::from_nsid ("InterfaceTests", "QuickEnum"); }

template<> inline EnumInfo enum_info<RapicornAidaTest::ClickType>() { return EnumInfo::from_nsid ("RapicornAidaTest", "ClickType"); }
} // Aida
} // Rapicorn

// --- Interface Skeletons ---

void
MandatoryNamespace::I_FirstInterface_Interface::void_func ()
{
}

double
InterfaceTests::I_UIWidgetArea_Interface::simple_method ()
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::single_arg (int n)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::single_arg2 (int n)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::two_args (int n,
                                                    double r)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::two_args2 (int n,
                                                     double r)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::multi_args (bool b,
                                                      int n,
                                                      double r,
                                                      int i,
                                                      const std::string &s,
                                                      double y)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::self_method (InterfaceTests::I_UIWidgetArea_Interface &ba1,
                                                       InterfaceTests::I_UIWidgetArea_Interface &ba2)
{
  return 0;
}

void
InterfaceTests::I_UIWidgetArea_Interface::void_method ()
{
}

std::string
InterfaceTests::I_UIWidgetArea_Interface::on_click2out ()
{
  return "";
}

void
InterfaceTests::I_UIWidgetArea_Interface::on_click2in (const std::string &command)
{
}

void
InterfaceTests::I_QuickIface_Interface::simple_function (int i)
{
}

void
InterfaceTests::I_MethodTestInterface_Interface::method_with_void ()
{
}

bool
InterfaceTests::I_MethodTestInterface_Interface::method_with_bools (bool input,
                                                                    bool optval)
{
  return 0;
}

int
InterfaceTests::I_MethodTestInterface_Interface::method_with_ints (int input,
                                                                   int optval)
{
  return 0;
}

double
InterfaceTests::I_MethodTestInterface_Interface::method_with_floats (double input,
                                                                     double optval)
{
  return 0;
}

std::string
InterfaceTests::I_MethodTestInterface_Interface::method_with_string (const std::string &input,
                                                                     const std::string &optval)
{
  return "";
}

InterfaceTests::QuickEnum
InterfaceTests::I_MethodTestInterface_Interface::method_with_enum (InterfaceTests::QuickEnum input,
                                                                   InterfaceTests::QuickEnum optval)
{
  return InterfaceTests::QuickEnum (0);
}

InterfaceTests::QuickRecordImpl
InterfaceTests::I_MethodTestInterface_Interface::method_with_record (const InterfaceTests::QuickRecordImpl &input,
                                                                     const InterfaceTests::QuickRecordImpl &optval)
{
  return InterfaceTests::QuickRecordImpl();
}

InterfaceTests::QuickSequenceImpl
InterfaceTests::I_MethodTestInterface_Interface::method_with_sequence (const InterfaceTests::QuickSequenceImpl &input,
                                                                       const InterfaceTests::QuickSequenceImpl &optval)
{
  return InterfaceTests::QuickSequenceImpl();
}

InterfaceTests::I_GrandChild_Interface*
InterfaceTests::I_MethodTestInterface_Interface::method_with_interface (InterfaceTests::I_GrandChild_Interface &input,
                                                                        InterfaceTests::I_GrandChild_Interface &optval)
{
  return 0;
}

Rapicorn::Aida::Any
InterfaceTests::I_MethodTestInterface_Interface::method_with_anys (const Rapicorn::Aida::Any &input,
                                                                   const Rapicorn::Aida::Any &optval)
{
  return Rapicorn::Aida::Any();
}

InterfaceTests::I_QuickIface_Interface*
InterfaceTests::I_MethodTestInterface_Interface::method_with_quickiface (InterfaceTests::I_QuickIface_Interface &input,
                                                                         InterfaceTests::I_QuickIface_Interface &iface0)
{
  return 0;
}


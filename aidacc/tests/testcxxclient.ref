// --- Generated by AidaCxxStub ---

// --- ClientHH Boilerplate ---
#include <rapicorn-core.hh>


#ifndef AIDA_CHECK
#define AIDA_CHECK(cond,errmsg) do { if (cond) break; throw std::runtime_error (std::string ("AIDA-ERROR: ") + errmsg); } while (0)
#endif

namespace { // Anon
using Rapicorn::Aida::uint64_t;

namespace __AIDA_Local__ {
using namespace Rapicorn::Aida;

// connection
static Rapicorn::Aida::ClientConnection *client_connection = NULL;
static Rapicorn::Init init_client_connection ([]() {
  client_connection = ObjectBroker::new_client_connection (":AidaClientConnection:CxxStub:idl_file=aidacc/tests/testpass.idl:");
});

// helper

static FieldBuffer*
invoke (FieldBuffer *fb)                // async remote call, transfers memory
{
  return client_connection->call_remote (fb);
}

static bool
signal_disconnect (size_t signal_handler_id)
{
  return client_connection->signal_disconnect (signal_handler_id);
}

static size_t
signal_connect (uint64_t hhi, uint64_t hlo, const SmartHandle &sh, SignalEmitHandler seh, void *data)
{
  return client_connection->signal_connect (hhi, hlo, sh._orbid(), seh, data);
}

static inline uint64_t
smh2id (const SmartHandle &sh)
{
  return sh._orbid();
}

template<class SMH> SMH
smh2cast (const SmartHandle &handle)
{
  const uint64_t orbid = __AIDA_Local__::smh2id (handle);
  SMH target;
  const uint64_t input[2] = { orbid, target._orbid() };
  Rapicorn::Aida::ObjectBroker::dup_handle (input, target);
  return target;
}

static inline void
add_header2_call (FieldBuffer &fb, const SmartHandle &sh, uint64_t h, uint64_t l)
{
  fb.add_header2 (Rapicorn::Aida::MSGID_TWOWAY_CALL, ObjectBroker::connection_id_from_handle (sh),
                  client_connection->connection_id(), h, l);
}

static inline void
add_header1_call (FieldBuffer &fb, const SmartHandle &sh, uint64_t h, uint64_t l)
{
  fb.add_header1 (Rapicorn::Aida::MSGID_ONEWAY_CALL, ObjectBroker::connection_id_from_handle (sh), h, l);
}

static inline FieldBuffer*
new_emit_result (const FieldBuffer *fb, uint64_t h, uint64_t l, uint32_t n)
{
  return ObjectBroker::renew_into_result (const_cast<FieldBuffer*> (fb),
                                          Rapicorn::Aida::MSGID_EMIT_RESULT,
                                          ObjectBroker::receiver_connection_id (fb->first_id()),
                                          h, l, n);
}

} } // Anon::__AIDA_Local__


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

/// @cond GeneratedEnums
enum Enum1 {
  E1_A = 1,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum1  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum1 &e) { e = Enum1 (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum1c {
  E1C_A = 1,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum1c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum1c &e) { e = Enum1c (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum2  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum2 &e) { e = Enum2 (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum2c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum2c &e) { e = Enum2c (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum3  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum3 &e) { e = Enum3 (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum3c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum3c &e) { e = Enum3c (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4a  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4a &e) { e = Enum4a (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4b  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4b &e) { e = Enum4b (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4c &e) { e = Enum4c (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4d  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4d &e) { e = Enum4d (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  ExtensiveEnum  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, ExtensiveEnum &e) { e = ExtensiveEnum (frr.pop_evalue()); }
/// @endcond

/** @interface FirstInterface
 * See also the corresponding C++ stub class FirstInterfaceHandle. */
/// See also the corresponding IDL class FirstInterface.
class FirstInterfaceHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static FirstInterfaceHandle            __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static FirstInterfaceHandle   down_cast (SmartHandle smh) { return smh == NULL ? FirstInterfaceHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      FirstInterfaceHandle ();
  void                          void_func            ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const FirstInterfaceHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, FirstInterfaceHandle&);
typedef FirstInterfaceHandle FirstInterfaceH; ///< Convenience alias for the IDL type FirstInterface.

struct XFooRecord
{
  /// @cond GeneratedFields
  bool                          single_bool;
  int                           single_num;
  Rapicorn::Aida::int64_t       num64;
  double                        single_float;
  std::string                   single_string;
  int                           sibling1;
  int                           sibling2;
  int                           multi1;
  int                           multi2;
  int                           multi3;
  int                           multi4;
  ExtensiveEnum                 enum_field;
  Rapicorn::Aida::SmartMember<FirstInterfaceHandle> iface1;
  Rapicorn::Aida::SmartMember<FirstInterfaceHandle> iface2;
  Rapicorn::Aida::SmartMember<FirstInterfaceHandle> iface3;
  Rapicorn::Aida::Any           any1;
  Rapicorn::Aida::Any           any2;
  Rapicorn::Aida::Any           any3;
  /// @endcond
  inline                        XFooRecord () { single_bool = 0; single_num = 0; num64 = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::XFooRecord"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const XFooRecord&);
void operator>>= (Rapicorn::Aida::FieldReader&, XFooRecord&);

struct XFooSequence : public std::vector<bool>
{
  typedef std::vector<bool> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::XFooSequence"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const XFooSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, XFooSequence&);

struct IntSequence : public std::vector<int>
{
  typedef std::vector<int> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::IntSequence"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const IntSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, IntSequence&);

struct FloatSequence : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::FloatSequence"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const FloatSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, FloatSequence&);

struct StringSequence : public std::vector<std::string>
{
  typedef std::vector<std::string> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::StringSequence"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const StringSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, StringSequence&);

struct ExtensiveEnumSequence : public std::vector<ExtensiveEnum>
{
  typedef std::vector<ExtensiveEnum> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::ExtensiveEnumSequence"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ExtensiveEnumSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, ExtensiveEnumSequence&);

struct RecordSequence : public std::vector<XFooRecord>
{
  typedef std::vector<XFooRecord> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::RecordSequence"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const RecordSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, RecordSequence&);

struct SequenceSequence : public std::vector<IntSequence>
{
  typedef std::vector<IntSequence> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::SequenceSequence"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SequenceSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, SequenceSequence&);

struct InterfaceSequence : public std::vector<Rapicorn::Aida::SmartMember<FirstInterfaceHandle>>
{
  typedef std::vector<Rapicorn::Aida::SmartMember<FirstInterfaceHandle>> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::InterfaceSequence"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const InterfaceSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, InterfaceSequence&);

struct AnySequence : public std::vector<Rapicorn::Aida::Any>
{
  typedef std::vector<Rapicorn::Aida::Any> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::AnySequence"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const AnySequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, AnySequence&);

struct NestedTypesRec
{
  /// @cond GeneratedFields
  XFooRecord                    rec;
  XFooSequence                  seq;
  /// @endcond
  inline                        NestedTypesRec () { }
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::NestedTypesRec"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NestedTypesRec&);
void operator>>= (Rapicorn::Aida::FieldReader&, NestedTypesRec&);

struct NestedTypesSeq : public std::vector<NestedTypesRec>
{
  typedef std::vector<NestedTypesRec> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::NestedTypesSeq"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NestedTypesSeq&);
void operator>>= (Rapicorn::Aida::FieldReader&, NestedTypesSeq&);

typedef Rapicorn::Aida::Any AliasAny;

typedef bool AliasBool;

typedef int AliasInt32;

typedef Rapicorn::Aida::int64_t AliasInt64;

typedef double AliasFloat;

typedef std::string AliasString;

typedef XFooRecord AliasRecord;

typedef XFooSequence AliasSequence;

typedef ExtensiveEnum AliasEnum;

struct NewRecord
{
  /// @cond GeneratedFields
  int                           i;
  Enum1                         enum1;
  XFooSequence                  xfs;
  NestedTypesRec                ntr;
  /// @endcond
  inline                        NewRecord () { i = 0; enum1 = Enum1 (0); }
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::NewRecord"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NewRecord&);
void operator>>= (Rapicorn::Aida::FieldReader&, NewRecord&);

namespace Inner {

struct InnerRecord
{
  /// @cond GeneratedFields
  int                           x;
  int                           y;
  NewRecord                     rec;
  /// @endcond
  inline                        InnerRecord () { x = 0; y = 0; }
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::Inner::InnerRecord"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const InnerRecord&);
void operator>>= (Rapicorn::Aida::FieldReader&, InnerRecord&);
} // Inner

struct Refer2Inner
{
  /// @cond GeneratedFields
  Inner::InnerRecord            r;
  /// @endcond
  inline                        Refer2Inner () { }
  std::string                   __aida_type_name__ ()	{ return "MandatoryNamespace::Refer2Inner"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const Refer2Inner&);
void operator>>= (Rapicorn::Aida::FieldReader&, Refer2Inner&);
} // MandatoryNamespace

namespace OtherNamespace {

struct SomeRecord
{
  /// @cond GeneratedFields
  MandatoryNamespace::NewRecord r1;
  MandatoryNamespace::NewRecord r2;
  MandatoryNamespace::Inner::InnerRecord r3;
  MandatoryNamespace::Inner::InnerRecord r4;
  /// @endcond
  inline                        SomeRecord () { }
  std::string                   __aida_type_name__ ()	{ return "OtherNamespace::SomeRecord"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SomeRecord&);
void operator>>= (Rapicorn::Aida::FieldReader&, SomeRecord&);
} // OtherNamespace

namespace Auxdata {

typedef bool AuxBool;

typedef int Aux32;

typedef Rapicorn::Aida::int64_t Aux64;

typedef double AuxF64;

typedef std::string AuxStr;
} // Auxdata

namespace InterfaceTests {

/** @interface UIWidgetArea
 * See also the corresponding C++ stub class UIWidgetAreaHandle. */
/// See also the corresponding IDL class UIWidgetArea.
class UIWidgetAreaHandle : public virtual Rapicorn::Aida::SmartHandle
{
  typedef Rapicorn::Aida::Connector<UIWidgetAreaHandle, void ()> __Aida_Signal__void_signal;
  size_t __aida_connect__void_signal (size_t, const std::function<void ()>&);
  typedef Rapicorn::Aida::Connector<UIWidgetAreaHandle, double (UIWidgetAreaHandle &ba1, int someint)> __Aida_Signal__sample_signal;
  size_t __aida_connect__sample_signal (size_t, const std::function<double (UIWidgetAreaHandle &ba1, int someint)>&);
  static UIWidgetAreaHandle              __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static UIWidgetAreaHandle     down_cast (SmartHandle smh) { return smh == NULL ? UIWidgetAreaHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      UIWidgetAreaHandle ();
  bool                          dummy    () const;
  void                          dummy    (bool);
  std::string                   on_click () const;
  void                          on_click (const std::string&);
  __Aida_Signal__void_signal    sig_void_signal () { return __Aida_Signal__void_signal (*this, &UIWidgetAreaHandle::__aida_connect__void_signal); }
  __Aida_Signal__sample_signal  sig_sample_signal () { return __Aida_Signal__sample_signal (*this, &UIWidgetAreaHandle::__aida_connect__sample_signal); }
  double                        simple_method      ();
  double                        single_arg         (int n);
  double                        single_arg2        (int n = 5);
  double                        two_args           (int n,
                                                    double r);
  double                        two_args2          (int n = 6,
                                                    double r = 7.7);
  double                        multi_args         (bool b,
                                                    Rapicorn::Aida::int64_t n,
                                                    double r,
                                                    int i,
                                                    const std::string &s = "String ding",
                                                    double y = 5);
  double                        self_method        (UIWidgetAreaHandle &ba1,
                                                    UIWidgetAreaHandle &ba2);
  void                          void_method        ();
  std::string                   on_click2out       ();
  void                          on_click2in        (const std::string &command);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const UIWidgetAreaHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, UIWidgetAreaHandle&);
typedef UIWidgetAreaHandle UIWidgetAreaH; ///< Convenience alias for the IDL type UIWidgetArea.

/** @interface Parent
 * See also the corresponding C++ stub class ParentHandle. */
/// See also the corresponding IDL class Parent.
class ParentHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static ParentHandle                    __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static ParentHandle           down_cast (SmartHandle smh) { return smh == NULL ? ParentHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      ParentHandle ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ParentHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, ParentHandle&);
typedef ParentHandle ParentH; ///< Convenience alias for the IDL type Parent.

/** @interface Child
 * See also the corresponding C++ stub class ChildHandle. */
/// See also the corresponding IDL class Child.
class ChildHandle : public ParentHandle
{
  static ChildHandle                     __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static ChildHandle            down_cast (SmartHandle smh) { return smh == NULL ? ChildHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      ChildHandle ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ChildHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, ChildHandle&);
typedef ChildHandle ChildH; ///< Convenience alias for the IDL type Child.

/** @interface Descendant
 * See also the corresponding C++ stub class DescendantHandle. */
/// See also the corresponding IDL class Descendant.
class DescendantHandle : public ChildHandle
{
  static DescendantHandle                __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static DescendantHandle       down_cast (SmartHandle smh) { return smh == NULL ? DescendantHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      DescendantHandle ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const DescendantHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, DescendantHandle&);
typedef DescendantHandle DescendantH; ///< Convenience alias for the IDL type Descendant.

/** @interface GrandChild
 * See also the corresponding C++ stub class GrandChildHandle. */
/// See also the corresponding IDL class GrandChild.
class GrandChildHandle : public DescendantHandle
{
  static GrandChildHandle                __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static GrandChildHandle       down_cast (SmartHandle smh) { return smh == NULL ? GrandChildHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      GrandChildHandle ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const GrandChildHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, GrandChildHandle&);
typedef GrandChildHandle GrandChildH; ///< Convenience alias for the IDL type GrandChild.

/// @cond GeneratedEnums
enum QuickEnum {
  ZERO = 0,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  QuickEnum  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, QuickEnum &e) { e = QuickEnum (frr.pop_evalue()); }
/// @endcond

struct QuickRecord
{
  /// @cond GeneratedFields
  int                           int1;
  int                           int2;
  /// @endcond
  inline                        QuickRecord () { int1 = 0; int2 = 0; }
  std::string                   __aida_type_name__ ()	{ return "InterfaceTests::QuickRecord"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const QuickRecord&);
void operator>>= (Rapicorn::Aida::FieldReader&, QuickRecord&);

struct QuickSequence : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ ()	{ return "InterfaceTests::QuickSequence"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const QuickSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, QuickSequence&);

/** @interface QuickIface
 * See also the corresponding C++ stub class QuickIfaceHandle. */
/// See also the corresponding IDL class QuickIface.
class QuickIfaceHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static QuickIfaceHandle                __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static QuickIfaceHandle       down_cast (SmartHandle smh) { return smh == NULL ? QuickIfaceHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      QuickIfaceHandle ();
  void                          simple_function  (int i = 9);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const QuickIfaceHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, QuickIfaceHandle&);
typedef QuickIfaceHandle QuickIfaceH; ///< Convenience alias for the IDL type QuickIface.

/** @interface MethodTestInterface
 * See also the corresponding C++ stub class MethodTestInterfaceHandle. */
/// See also the corresponding IDL class MethodTestInterface.
class MethodTestInterfaceHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static MethodTestInterfaceHandle       __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static MethodTestInterfaceHandle down_cast (SmartHandle smh) { return smh == NULL ? MethodTestInterfaceHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      MethodTestInterfaceHandle ();
  void                          method_with_void          ();
  bool                          method_with_bools         (bool input,
                                                           bool optval = 0);
  int                           method_with_ints32        (int input,
                                                           int optval = -2);
  Rapicorn::Aida::int64_t       method_with_ints64        (Rapicorn::Aida::int64_t input,
                                                           Rapicorn::Aida::int64_t optval = 576460752303423488);
  double                        method_with_floats        (double input,
                                                           double optval = 309.9);
  std::string                   method_with_string        (const std::string &input,
                                                           const std::string &optval = "default");
  QuickEnum                     method_with_enum          (QuickEnum input,
                                                           QuickEnum optval = QuickEnum (0));
  QuickRecord                   method_with_record        (const QuickRecord &input,
                                                           const QuickRecord &optval = QuickRecord());
  QuickSequence                 method_with_sequence      (const QuickSequence &input,
                                                           const QuickSequence &optval = QuickSequence());
  GrandChildHandle              method_with_interface     (GrandChildHandle &input,
                                                           GrandChildHandle &optval = *(GrandChildHandle*) NULL);
  Rapicorn::Aida::Any           method_with_anys          (const Rapicorn::Aida::Any &input,
                                                           const Rapicorn::Aida::Any &optval);
  QuickIfaceHandle              method_with_quickiface    (QuickIfaceHandle &input,
                                                           QuickIfaceHandle &iface0 = *(QuickIfaceHandle*) NULL);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const MethodTestInterfaceHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, MethodTestInterfaceHandle&);
typedef MethodTestInterfaceHandle MethodTestInterfaceH; ///< Convenience alias for the IDL type MethodTestInterface.

/** @interface SignalTestInterface
 * See also the corresponding C++ stub class SignalTestInterfaceHandle. */
/// See also the corresponding IDL class SignalTestInterface.
class SignalTestInterfaceHandle : public virtual Rapicorn::Aida::SmartHandle
{
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void ()> __Aida_Signal__void_result;
  size_t __aida_connect__void_result (size_t, const std::function<void ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, bool ()> __Aida_Signal__bool_result;
  size_t __aida_connect__bool_result (size_t, const std::function<bool ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, int ()> __Aida_Signal__int32_result;
  size_t __aida_connect__int32_result (size_t, const std::function<int ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, Rapicorn::Aida::int64_t ()> __Aida_Signal__int64_result;
  size_t __aida_connect__int64_result (size_t, const std::function<Rapicorn::Aida::int64_t ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, double ()> __Aida_Signal__float64_result;
  size_t __aida_connect__float64_result (size_t, const std::function<double ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, std::string ()> __Aida_Signal__string_result;
  size_t __aida_connect__string_result (size_t, const std::function<std::string ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, QuickEnum ()> __Aida_Signal__enum_result;
  size_t __aida_connect__enum_result (size_t, const std::function<QuickEnum ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, QuickRecord ()> __Aida_Signal__record_result;
  size_t __aida_connect__record_result (size_t, const std::function<QuickRecord ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, QuickSequence ()> __Aida_Signal__sequence_result;
  size_t __aida_connect__sequence_result (size_t, const std::function<QuickSequence ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, GrandChildHandle ()> __Aida_Signal__interface_result;
  size_t __aida_connect__interface_result (size_t, const std::function<GrandChildHandle ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, Rapicorn::Aida::Any ()> __Aida_Signal__any_result;
  size_t __aida_connect__any_result (size_t, const std::function<Rapicorn::Aida::Any ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, SignalTestInterfaceHandle ()> __Aida_Signal__self_result;
  size_t __aida_connect__self_result (size_t, const std::function<SignalTestInterfaceHandle ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void ()> __Aida_Signal__void_arg;
  size_t __aida_connect__void_arg (size_t, const std::function<void ()>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (bool b)> __Aida_Signal__bool_arg;
  size_t __aida_connect__bool_arg (size_t, const std::function<void (bool b)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (int i)> __Aida_Signal__int32_arg;
  size_t __aida_connect__int32_arg (size_t, const std::function<void (int i)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (Rapicorn::Aida::int64_t i)> __Aida_Signal__int64_arg;
  size_t __aida_connect__int64_arg (size_t, const std::function<void (Rapicorn::Aida::int64_t i)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (double f)> __Aida_Signal__float64_arg;
  size_t __aida_connect__float64_arg (size_t, const std::function<void (double f)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (const std::string &s)> __Aida_Signal__string_arg;
  size_t __aida_connect__string_arg (size_t, const std::function<void (const std::string &s)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (QuickEnum e)> __Aida_Signal__enum_arg;
  size_t __aida_connect__enum_arg (size_t, const std::function<void (QuickEnum e)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (const QuickRecord &r)> __Aida_Signal__record_arg;
  size_t __aida_connect__record_arg (size_t, const std::function<void (const QuickRecord &r)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (const QuickSequence &s)> __Aida_Signal__sequence_arg;
  size_t __aida_connect__sequence_arg (size_t, const std::function<void (const QuickSequence &s)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (GrandChildHandle &i)> __Aida_Signal__interface_arg;
  size_t __aida_connect__interface_arg (size_t, const std::function<void (GrandChildHandle &i)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (const Rapicorn::Aida::Any &a)> __Aida_Signal__any_arg;
  size_t __aida_connect__any_arg (size_t, const std::function<void (const Rapicorn::Aida::Any &a)>&);
  typedef Rapicorn::Aida::Connector<SignalTestInterfaceHandle, void (SignalTestInterfaceHandle &self_)> __Aida_Signal__self_args;
  size_t __aida_connect__self_args (size_t, const std::function<void (SignalTestInterfaceHandle &self_)>&);
  static SignalTestInterfaceHandle       __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static SignalTestInterfaceHandle down_cast (SmartHandle smh) { return smh == NULL ? SignalTestInterfaceHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      SignalTestInterfaceHandle ();
  __Aida_Signal__void_result    sig_void_result () { return __Aida_Signal__void_result (*this, &SignalTestInterfaceHandle::__aida_connect__void_result); }
  __Aida_Signal__bool_result    sig_bool_result () { return __Aida_Signal__bool_result (*this, &SignalTestInterfaceHandle::__aida_connect__bool_result); }
  __Aida_Signal__int32_result   sig_int32_result () { return __Aida_Signal__int32_result (*this, &SignalTestInterfaceHandle::__aida_connect__int32_result); }
  __Aida_Signal__int64_result   sig_int64_result () { return __Aida_Signal__int64_result (*this, &SignalTestInterfaceHandle::__aida_connect__int64_result); }
  __Aida_Signal__float64_result sig_float64_result () { return __Aida_Signal__float64_result (*this, &SignalTestInterfaceHandle::__aida_connect__float64_result); }
  __Aida_Signal__string_result  sig_string_result () { return __Aida_Signal__string_result (*this, &SignalTestInterfaceHandle::__aida_connect__string_result); }
  __Aida_Signal__enum_result    sig_enum_result () { return __Aida_Signal__enum_result (*this, &SignalTestInterfaceHandle::__aida_connect__enum_result); }
  __Aida_Signal__record_result  sig_record_result () { return __Aida_Signal__record_result (*this, &SignalTestInterfaceHandle::__aida_connect__record_result); }
  __Aida_Signal__sequence_result sig_sequence_result () { return __Aida_Signal__sequence_result (*this, &SignalTestInterfaceHandle::__aida_connect__sequence_result); }
  __Aida_Signal__interface_result sig_interface_result () { return __Aida_Signal__interface_result (*this, &SignalTestInterfaceHandle::__aida_connect__interface_result); }
  __Aida_Signal__any_result     sig_any_result () { return __Aida_Signal__any_result (*this, &SignalTestInterfaceHandle::__aida_connect__any_result); }
  __Aida_Signal__self_result    sig_self_result () { return __Aida_Signal__self_result (*this, &SignalTestInterfaceHandle::__aida_connect__self_result); }
  __Aida_Signal__void_arg       sig_void_arg () { return __Aida_Signal__void_arg (*this, &SignalTestInterfaceHandle::__aida_connect__void_arg); }
  __Aida_Signal__bool_arg       sig_bool_arg () { return __Aida_Signal__bool_arg (*this, &SignalTestInterfaceHandle::__aida_connect__bool_arg); }
  __Aida_Signal__int32_arg      sig_int32_arg () { return __Aida_Signal__int32_arg (*this, &SignalTestInterfaceHandle::__aida_connect__int32_arg); }
  __Aida_Signal__int64_arg      sig_int64_arg () { return __Aida_Signal__int64_arg (*this, &SignalTestInterfaceHandle::__aida_connect__int64_arg); }
  __Aida_Signal__float64_arg    sig_float64_arg () { return __Aida_Signal__float64_arg (*this, &SignalTestInterfaceHandle::__aida_connect__float64_arg); }
  __Aida_Signal__string_arg     sig_string_arg () { return __Aida_Signal__string_arg (*this, &SignalTestInterfaceHandle::__aida_connect__string_arg); }
  __Aida_Signal__enum_arg       sig_enum_arg () { return __Aida_Signal__enum_arg (*this, &SignalTestInterfaceHandle::__aida_connect__enum_arg); }
  __Aida_Signal__record_arg     sig_record_arg () { return __Aida_Signal__record_arg (*this, &SignalTestInterfaceHandle::__aida_connect__record_arg); }
  __Aida_Signal__sequence_arg   sig_sequence_arg () { return __Aida_Signal__sequence_arg (*this, &SignalTestInterfaceHandle::__aida_connect__sequence_arg); }
  __Aida_Signal__interface_arg  sig_interface_arg () { return __Aida_Signal__interface_arg (*this, &SignalTestInterfaceHandle::__aida_connect__interface_arg); }
  __Aida_Signal__any_arg        sig_any_arg () { return __Aida_Signal__any_arg (*this, &SignalTestInterfaceHandle::__aida_connect__any_arg); }
  __Aida_Signal__self_args      sig_self_args () { return __Aida_Signal__self_args (*this, &SignalTestInterfaceHandle::__aida_connect__self_args); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SignalTestInterfaceHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, SignalTestInterfaceHandle&);
typedef SignalTestInterfaceHandle SignalTestInterfaceH; ///< Convenience alias for the IDL type SignalTestInterface.

/** @interface ChildInheritingSignals
 * See also the corresponding C++ stub class ChildInheritingSignalsHandle. */
/// See also the corresponding IDL class ChildInheritingSignals.
class ChildInheritingSignalsHandle : public SignalTestInterfaceHandle
{
  typedef Rapicorn::Aida::Connector<ChildInheritingSignalsHandle, void (ChildInheritingSignalsHandle &c, SignalTestInterfaceHandle &p, const Rapicorn::Aida::Any &a, int i, const QuickRecord &r, const QuickSequence &s)> __Aida_Signal__child_signal;
  size_t __aida_connect__child_signal (size_t, const std::function<void (ChildInheritingSignalsHandle &c, SignalTestInterfaceHandle &p, const Rapicorn::Aida::Any &a, int i, const QuickRecord &r, const QuickSequence &s)>&);
  static ChildInheritingSignalsHandle    __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static ChildInheritingSignalsHandle down_cast (SmartHandle smh) { return smh == NULL ? ChildInheritingSignalsHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      ChildInheritingSignalsHandle ();
  __Aida_Signal__child_signal   sig_child_signal () { return __Aida_Signal__child_signal (*this, &ChildInheritingSignalsHandle::__aida_connect__child_signal); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ChildInheritingSignalsHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, ChildInheritingSignalsHandle&);
typedef ChildInheritingSignalsHandle ChildInheritingSignalsH; ///< Convenience alias for the IDL type ChildInheritingSignals.

/** @interface AnotherChild
 * See also the corresponding C++ stub class AnotherChildHandle. */
/// See also the corresponding IDL class AnotherChild.
class AnotherChildHandle : public SignalTestInterfaceHandle
{
  static AnotherChildHandle              __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static AnotherChildHandle     down_cast (SmartHandle smh) { return smh == NULL ? AnotherChildHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      AnotherChildHandle ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const AnotherChildHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, AnotherChildHandle&);
typedef AnotherChildHandle AnotherChildH; ///< Convenience alias for the IDL type AnotherChild.

/** @interface PropertyTester
 * See also the corresponding C++ stub class PropertyTesterHandle. */
/// See also the corresponding IDL class PropertyTester.
class PropertyTesterHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static PropertyTesterHandle            __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static PropertyTesterHandle   down_cast (SmartHandle smh) { return smh == NULL ? PropertyTesterHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      PropertyTesterHandle ();
  bool                          bool_prop      () const;
  void                          bool_prop      (bool);
  int                           int32_prop     () const;
  void                          int32_prop     (int);
  Rapicorn::Aida::int64_t       int64_prop     () const;
  void                          int64_prop     (Rapicorn::Aida::int64_t);
  double                        float64_prop   () const;
  void                          float64_prop   (double);
  std::string                   string_prop    () const;
  void                          string_prop    (const std::string&);
  QuickEnum                     enum_prop      () const;
  void                          enum_prop      (QuickEnum);
  QuickRecord                   record_prop    () const;
  void                          record_prop    (const QuickRecord&);
  QuickSequence                 sequence_prop  () const;
  void                          sequence_prop  (const QuickSequence&);
  GrandChildHandle              interface_prop () const;
  void                          interface_prop (GrandChildHandle);
  PropertyTesterHandle          self_prop      () const;
  void                          self_prop      (PropertyTesterHandle);
  Rapicorn::Aida::Any           any_prop       () const;
  void                          any_prop       (const Rapicorn::Aida::Any&);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const PropertyTesterHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, PropertyTesterHandle&);
typedef PropertyTesterHandle PropertyTesterH; ///< Convenience alias for the IDL type PropertyTester.
} // InterfaceTests

namespace RapicornAidaTest {

/// @cond GeneratedEnums
enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  ClickType  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, ClickType &e) { e = ClickType (frr.pop_evalue()); }
/// @endcond

/** @interface ButtonArea
 * See also the corresponding C++ stub class ButtonAreaHandle. */
/// See also the corresponding IDL class ButtonArea.
class ButtonAreaHandle : public virtual Rapicorn::Aida::SmartHandle
{
  typedef Rapicorn::Aida::Connector<ButtonAreaHandle, bool ()> __Aida_Signal__check_activate;
  size_t __aida_connect__check_activate (size_t, const std::function<bool ()>&);
  typedef Rapicorn::Aida::Connector<ButtonAreaHandle, void ()> __Aida_Signal__activate;
  size_t __aida_connect__activate (size_t, const std::function<void ()>&);
  static ButtonAreaHandle                __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static ButtonAreaHandle       down_cast (SmartHandle smh) { return smh == NULL ? ButtonAreaHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      ButtonAreaHandle ();
  std::string                   on_click   () const;
  void                          on_click   (const std::string&);
  std::string                   on_click2  () const;
  void                          on_click2  (const std::string&);
  std::string                   on_click3  () const;
  void                          on_click3  (const std::string&);
  ClickType                     click_type () const;
  void                          click_type (ClickType);
  __Aida_Signal__check_activate sig_check_activate () { return __Aida_Signal__check_activate (*this, &ButtonAreaHandle::__aida_connect__check_activate); }
  __Aida_Signal__activate       sig_activate () { return __Aida_Signal__activate (*this, &ButtonAreaHandle::__aida_connect__activate); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ButtonAreaHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, ButtonAreaHandle&);
typedef ButtonAreaHandle ButtonAreaH; ///< Convenience alias for the IDL type ButtonArea.

class PureMethodsHandle;

/** @interface PureMethods
 * See also the corresponding C++ stub class PureMethodsHandle. */
/// See also the corresponding IDL class PureMethods.
class PureMethodsHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static PureMethodsHandle               __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static PureMethodsHandle      down_cast (SmartHandle smh) { return smh == NULL ? PureMethodsHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      PureMethodsHandle ();
  int                           pure_method       (double f);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const PureMethodsHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, PureMethodsHandle&);
typedef PureMethodsHandle PureMethodsH; ///< Convenience alias for the IDL type PureMethods.

/// @cond GeneratedEnums
enum MathExpressions {
  RESULT_2 = 2,
  RESULT_5 = 5,
  RESULT_8 = 8,
  RESULT_6 = 6,
  RESULT_7 = 7,
  RESULT_16 = 16,
  RESULT_3 = 3,
  RESULT_24 = 24,
  RESULT_13 = 13,
  RESULT_m2 = -2,
  RESULT_77 = 77,
  RESULT_511 = 511,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  MathExpressions  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, MathExpressions &e) { e = MathExpressions (frr.pop_evalue()); }
/// @endcond
} // RapicornAidaTest

namespace Other {

/** @interface NameTests
 * See also the corresponding C++ stub class NameTestsHandle. */
/// See also the corresponding IDL class NameTests.
class NameTestsHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static NameTestsHandle                 __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static NameTestsHandle        down_cast (SmartHandle smh) { return smh == NULL ? NameTestsHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      NameTestsHandle ();
  void                          args_from_other_namespace (const InterfaceTests::QuickRecord &qr,
                                                           RapicornAidaTest::ClickType qe,
                                                           const OtherNamespace::SomeRecord &sr);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NameTestsHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, NameTestsHandle&);
typedef NameTestsHandle NameTestsH; ///< Convenience alias for the IDL type NameTests.
} // Other

namespace BseTest {

/** @interface Compressor
 * See also the corresponding C++ stub class CompressorHandle. */
/// See also the corresponding IDL class Compressor.
class CompressorHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static CompressorHandle                __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static CompressorHandle       down_cast (SmartHandle smh) { return smh == NULL ? CompressorHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      CompressorHandle ();
  double                        threshold () const;
  void                          threshold (double);
  double                        ratio     () const;
  void                          ratio     (double);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const CompressorHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, CompressorHandle&);
typedef CompressorHandle CompressorH; ///< Convenience alias for the IDL type Compressor.

struct RecordForGroups
{
  /// @cond GeneratedFields
  int                           i;
  double                        ratio;
  bool                          ordinary_bool;
  double                        threshold1;
  double                        threshold2;
  /// @endcond
  inline                        RecordForGroups () { i = 0; ratio = 0; ordinary_bool = 0; threshold1 = 0; threshold2 = 0; }
  std::string                   __aida_type_name__ ()	{ return "BseTest::RecordForGroups"; }
  Rapicorn::Aida::TypeCode      __aida_type_code__ ()	{ return Rapicorn::Aida::TypeMap::lookup (__aida_type_name__()); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const RecordForGroups&);
void operator>>= (Rapicorn::Aida::FieldReader&, RecordForGroups&);

/** @interface SoundModule
 * See also the corresponding C++ stub class SoundModuleHandle. */
/// See also the corresponding IDL class SoundModule.
class SoundModuleHandle : public virtual Rapicorn::Aida::SmartHandle
{
  static SoundModuleHandle               __aida_cast__ (Rapicorn::Aida::SmartHandle&, const Rapicorn::Aida::TypeHashList&);
  static const Rapicorn::Aida::TypeHash& __aida_typeid__();
protected:
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  const Rapicorn::Aida::TypeHashList     __aida_typelist__();
  template<class SmartHandle>
  static SoundModuleHandle      down_cast (SmartHandle smh) { return smh == NULL ? SoundModuleHandle() : __aida_cast__ (smh, smh.__aida_typelist__()); }
  explicit                      SoundModuleHandle ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SoundModuleHandle&);
void operator>>= (Rapicorn::Aida::FieldReader&, SoundModuleHandle&);
typedef SoundModuleHandle SoundModuleH; ///< Convenience alias for the IDL type SoundModule.
} // BseTest

namespace Rapicorn {

namespace Aida {

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum1>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum1"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum1c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum1c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum2>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum2"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum2c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum2c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum3>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum3"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum3c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum3c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4a>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4a"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4b>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4b"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4d>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4d"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::ExtensiveEnum>() { return EnumInfo::from_nsid ("MandatoryNamespace", "ExtensiveEnum"); }

template<> inline EnumInfo enum_info<InterfaceTests::QuickEnum>() { return EnumInfo::from_nsid ("InterfaceTests", "QuickEnum"); }

template<> inline EnumInfo enum_info<RapicornAidaTest::ClickType>() { return EnumInfo::from_nsid ("RapicornAidaTest", "ClickType"); }

template<> inline EnumInfo enum_info<RapicornAidaTest::MathExpressions>() { return EnumInfo::from_nsid ("RapicornAidaTest", "MathExpressions"); }
} // Aida
} // Rapicorn

// --- Implementations ---

namespace MandatoryNamespace {

static Rapicorn::Init __aida_autoinit__Enum1 ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E1_A),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum1", enum_values);
});

static Rapicorn::Init __aida_autoinit__Enum1c ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E1C_A),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum1c", enum_values);
});

static Rapicorn::Init __aida_autoinit__Enum2 ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2_B),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum2", enum_values);
});

static Rapicorn::Init __aida_autoinit__Enum2c ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2C_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2C_B),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum2c", enum_values);
});

static Rapicorn::Init __aida_autoinit__Enum3 ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3_C),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum3", enum_values);
});

static Rapicorn::Init __aida_autoinit__Enum3c ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3C_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3C_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3C_C),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum3c", enum_values);
});

static Rapicorn::Init __aida_autoinit__Enum4a ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4a", enum_values);
});

static Rapicorn::Init __aida_autoinit__Enum4b ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4b", enum_values);
});

static Rapicorn::Init __aida_autoinit__Enum4c ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4c", enum_values);
});

static Rapicorn::Init __aida_autoinit__Enum4d ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4d", enum_values);
});

static Rapicorn::Init __aida_autoinit__ExtensiveEnum ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (V1a),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V1b),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V2),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V3),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V4),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V5),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V6),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V7),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V8),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V9),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V10),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V11),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V12),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V13),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V14),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V15),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V16),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V17),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V18),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V20),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V21),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V22),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V23),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V24),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V25),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V26),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V27),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V28),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V30),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V31),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V32),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V33),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V34),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V35),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V36),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "ExtensiveEnum", enum_values);
});
FirstInterfaceHandle::FirstInterfaceHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const FirstInterfaceHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, FirstInterfaceHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
FirstInterfaceHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x22113f623903ac14ULL, 0x3fe8e50c1a9a78d2ULL);
  return type_hash;
}
FirstInterfaceHandle
FirstInterfaceHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<FirstInterfaceHandle> (other);
  return FirstInterfaceHandle();
}
Rapicorn::Aida::BaseConnection*
FirstInterfaceHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
FirstInterfaceHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0x3080ed132845bb88ULL, 0x1ccc8bdb4dc51a6fULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
void
FirstInterfaceHandle::void_func ()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xc3f858f5171056cbULL, 0x394e47a2bcd63e16ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const XFooRecord &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (18);
  fb <<= self.single_bool;
  fb <<= self.single_num;
  fb <<= self.num64;
  fb <<= self.single_float;
  fb <<= self.single_string;
  fb <<= self.sibling1;
  fb <<= self.sibling2;
  fb <<= self.multi1;
  fb <<= self.multi2;
  fb <<= self.multi3;
  fb <<= self.multi4;
  fb <<= self.enum_field;
  fb <<= self.iface1;
  fb <<= self.iface2;
  fb <<= self.iface3;
  fb <<= self.any1;
  fb <<= self.any2;
  fb <<= self.any3;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, XFooRecord &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 18) return;
  fbr >>= self.single_bool;
  fbr >>= self.single_num;
  fbr >>= self.num64;
  fbr >>= self.single_float;
  fbr >>= self.single_string;
  fbr >>= self.sibling1;
  fbr >>= self.sibling2;
  fbr >>= self.multi1;
  fbr >>= self.multi2;
  fbr >>= self.multi3;
  fbr >>= self.multi4;
  fbr >>= self.enum_field;
  fbr >>= self.iface1;
  fbr >>= self.iface2;
  fbr >>= self.iface3;
  fbr >>= self.any1;
  fbr >>= self.any2;
  fbr >>= self.any3;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const XFooSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, XFooSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
XFooSequence::reference
XFooSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const IntSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, IntSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
IntSequence::reference
IntSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const FloatSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, FloatSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
FloatSequence::reference
FloatSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const StringSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, StringSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
StringSequence::reference
StringSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const ExtensiveEnumSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, ExtensiveEnumSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
ExtensiveEnumSequence::reference
ExtensiveEnumSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const RecordSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, RecordSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
RecordSequence::reference
RecordSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SequenceSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SequenceSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SequenceSequence::reference
SequenceSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const InterfaceSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, InterfaceSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
InterfaceSequence::reference
InterfaceSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const AnySequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, AnySequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
AnySequence::reference
AnySequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const NestedTypesRec &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (2);
  fb <<= self.rec;
  fb <<= self.seq;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, NestedTypesRec &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >>= self.rec;
  fbr >>= self.seq;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const NestedTypesSeq &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, NestedTypesSeq &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
NestedTypesSeq::reference
NestedTypesSeq::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const NewRecord &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (4);
  fb <<= self.i;
  fb <<= self.enum1;
  fb <<= self.xfs;
  fb <<= self.ntr;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, NewRecord &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >>= self.i;
  fbr >>= self.enum1;
  fbr >>= self.xfs;
  fbr >>= self.ntr;
}

namespace Inner {
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const InnerRecord &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (3);
  fb <<= self.x;
  fb <<= self.y;
  fb <<= self.rec;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, InnerRecord &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 3) return;
  fbr >>= self.x;
  fbr >>= self.y;
  fbr >>= self.rec;
}
} // Inner
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const Refer2Inner &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (1);
  fb <<= self.r;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, Refer2Inner &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 1) return;
  fbr >>= self.r;
}
} // MandatoryNamespace

namespace OtherNamespace {
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SomeRecord &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (4);
  fb <<= self.r1;
  fb <<= self.r2;
  fb <<= self.r3;
  fb <<= self.r4;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SomeRecord &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >>= self.r1;
  fbr >>= self.r2;
  fbr >>= self.r3;
  fbr >>= self.r4;
}
} // OtherNamespace

namespace InterfaceTests {
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__UIWidgetAreaHandle__void_signal (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
UIWidgetAreaHandle::__aida_connect__void_signal (size_t signal_handler_id, const std::function<void ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void ()> (func);
  return __AIDA_Local__::signal_connect (0x0774aa0ffbdf5f02ULL, 0x3f1b5247dca90c86ULL, *this, __aida_emit1__UIWidgetAreaHandle__void_signal, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__UIWidgetAreaHandle__sample_signal (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<double (UIWidgetAreaHandle &ba1, int someint)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  double  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
UIWidgetAreaHandle::__aida_connect__sample_signal (size_t signal_handler_id, const std::function<double (UIWidgetAreaHandle &ba1, int someint)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<double (UIWidgetAreaHandle &ba1, int someint)> (func);
  return __AIDA_Local__::signal_connect (0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL, *this, __aida_emit2__UIWidgetAreaHandle__sample_signal, fptr);
}
UIWidgetAreaHandle::UIWidgetAreaHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const UIWidgetAreaHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, UIWidgetAreaHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
UIWidgetAreaHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x11db82aaba1ee248ULL, 0xd2359653ff87e972ULL);
  return type_hash;
}
UIWidgetAreaHandle
UIWidgetAreaHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<UIWidgetAreaHandle> (other);
  return UIWidgetAreaHandle();
}
Rapicorn::Aida::BaseConnection*
UIWidgetAreaHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
UIWidgetAreaHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0xc7c8bc238ce4501cULL, 0xd5b65cb502c0eb4cULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
bool
UIWidgetAreaHandle::dummy () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xf67db704b9d460d6ULL, 0xd4950feab697e61eULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  bool  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::dummy (bool value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0x7aaf2f96f3042829ULL, 0x3d0391e5b72e7ba5ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
std::string
UIWidgetAreaHandle::on_click () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x58ba68f6b64584c9ULL, 0xa7d2686edb40f27aULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::on_click (const std::string &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xf0025ec0fa66e3e2ULL, 0x880c10e8e6b57cfbULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
double
UIWidgetAreaHandle::simple_method ()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xd0dd4c08ba5022c0ULL, 0xb1af31ca1ec7037aULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::single_arg (int arg_n)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xe4e890540b4c0579ULL, 0xe14a7ffaa82f1c4fULL);
  fb <<= *this;
  fb <<= arg_n;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::single_arg2 (int arg_n)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x9cfaa316ccbb6ea0ULL, 0x6cc5207c5520e081ULL);
  fb <<= *this;
  fb <<= arg_n;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::two_args (int arg_n,
                              double arg_r)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x64511c410b16c274ULL, 0x19b47eb22b4cd4d4ULL);
  fb <<= *this;
  fb <<= arg_n;
  fb <<= arg_r;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::two_args2 (int arg_n,
                               double arg_r)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x2089150ae3f7ad80ULL, 0xe6154471cb4560e0ULL);
  fb <<= *this;
  fb <<= arg_n;
  fb <<= arg_r;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::multi_args (bool arg_b,
                                Rapicorn::Aida::int64_t arg_n,
                                double arg_r,
                                int arg_i,
                                const std::string &arg_s,
                                double arg_y)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 6), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x349f073a5bad36fdULL, 0xf7a10ae13b8e391bULL);
  fb <<= *this;
  fb <<= arg_b;
  fb <<= arg_n;
  fb <<= arg_r;
  fb <<= arg_i;
  fb <<= arg_s;
  fb <<= arg_y;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
UIWidgetAreaHandle::self_method (UIWidgetAreaHandle &arg_ba1,
                                 UIWidgetAreaHandle &arg_ba2)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x4b479b2f4e3ba551ULL, 0xb7c407eee57eb21aULL);
  fb <<= *this;
  fb <<= arg_ba1;
  fb <<= arg_ba2;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::void_method ()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xdbb304ad4df15873ULL, 0xca276abf2bb1603cULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
std::string
UIWidgetAreaHandle::on_click2out ()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xb8bc20394724087aULL, 0xbc7b1e7d30aeb178ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
UIWidgetAreaHandle::on_click2in (const std::string &arg_command)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0x3432c3bb41bc72a0ULL, 0x533bc22135f973bfULL);
  fb <<= *this;
  fb <<= arg_command;
  fr = __AIDA_Local__::invoke (&fb);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
ParentHandle::ParentHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const ParentHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, ParentHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
ParentHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL);
  return type_hash;
}
ParentHandle
ParentHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<ParentHandle> (other);
  return ParentHandle();
}
Rapicorn::Aida::BaseConnection*
ParentHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
ParentHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0xf8c38a8ecbaae738ULL, 0xb3e0312627d8c473ULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
ChildHandle::ChildHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const ChildHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, ChildHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
ChildHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xacf30fad3093ffcdULL, 0x4d8c65c035fba090ULL);
  return type_hash;
}
ChildHandle
ChildHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<ChildHandle> (other);
  return ChildHandle();
}
const Rapicorn::Aida::TypeHashList
ChildHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0xf12312304ba136fdULL, 0xa77c19d1413f4e7fULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
DescendantHandle::DescendantHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const DescendantHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, DescendantHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
DescendantHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x846a6876889dd896ULL, 0xbe521465806f3d42ULL);
  return type_hash;
}
DescendantHandle
DescendantHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<DescendantHandle> (other);
  return DescendantHandle();
}
const Rapicorn::Aida::TypeHashList
DescendantHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0x25c480d73f591587ULL, 0x6dd13a33bab33967ULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
GrandChildHandle::GrandChildHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const GrandChildHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, GrandChildHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
GrandChildHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xf6975e5e92250718ULL, 0x53730d44919c46f9ULL);
  return type_hash;
}
GrandChildHandle
GrandChildHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<GrandChildHandle> (other);
  return GrandChildHandle();
}
const Rapicorn::Aida::TypeHashList
GrandChildHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0x5c0476de00912d29ULL, 0xfb69f6a1e0a78e4fULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}

static Rapicorn::Init __aida_autoinit__QuickEnum ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (ZERO),
  };
  Rapicorn::Aida::EnumInfo::enlist ("InterfaceTests", "QuickEnum", enum_values);
});
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const QuickRecord &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (2);
  fb <<= self.int1;
  fb <<= self.int2;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, QuickRecord &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >>= self.int1;
  fbr >>= self.int2;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const QuickSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, QuickSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
QuickSequence::reference
QuickSequence::append_back()
{
  resize (size() + 1);
  return back();
}
QuickIfaceHandle::QuickIfaceHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const QuickIfaceHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, QuickIfaceHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
QuickIfaceHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x4524ee119d4e454cULL, 0xbeb61f7c3cc04f7dULL);
  return type_hash;
}
QuickIfaceHandle
QuickIfaceHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<QuickIfaceHandle> (other);
  return QuickIfaceHandle();
}
Rapicorn::Aida::BaseConnection*
QuickIfaceHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
QuickIfaceHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0x9287bfc16608b62fULL, 0x4d65f47a36af14b6ULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
void
QuickIfaceHandle::simple_function (int arg_i)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0x76ac7a704663d246ULL, 0x23abac49621c6802ULL);
  fb <<= *this;
  fb <<= arg_i;
  fr = __AIDA_Local__::invoke (&fb);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
MethodTestInterfaceHandle::MethodTestInterfaceHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const MethodTestInterfaceHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, MethodTestInterfaceHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
MethodTestInterfaceHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x6bf684458ac5f01aULL, 0xf64c02611b807180ULL);
  return type_hash;
}
MethodTestInterfaceHandle
MethodTestInterfaceHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<MethodTestInterfaceHandle> (other);
  return MethodTestInterfaceHandle();
}
Rapicorn::Aida::BaseConnection*
MethodTestInterfaceHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
MethodTestInterfaceHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0xa580bd43ca21a145ULL, 0x9eefef45f90dbb0bULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
void
MethodTestInterfaceHandle::method_with_void ()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0x1addfccb0a3e01beULL, 0x314f2eb467d7a72bULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
bool
MethodTestInterfaceHandle::method_with_bools (bool arg_input,
                                              bool arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x55291a7348d14242ULL, 0x32dac90dde65a764ULL);
  fb <<= *this;
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  bool  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
int
MethodTestInterfaceHandle::method_with_ints32 (int arg_input,
                                               int arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xdc38cf6855c54108ULL, 0x328ddcdcec8f161eULL);
  fb <<= *this;
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  int  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
Rapicorn::Aida::int64_t
MethodTestInterfaceHandle::method_with_ints64 (Rapicorn::Aida::int64_t arg_input,
                                               Rapicorn::Aida::int64_t arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x678de8636167b6a1ULL, 0xb27d37ca066b5335ULL);
  fb <<= *this;
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  Rapicorn::Aida::int64_t  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
double
MethodTestInterfaceHandle::method_with_floats (double arg_input,
                                               double arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xeea6d5fb184699a3ULL, 0xce05c988a9bfd2d9ULL);
  fb <<= *this;
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
std::string
MethodTestInterfaceHandle::method_with_string (const std::string &arg_input,
                                               const std::string &arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x646f80849d732dc5ULL, 0x72fd1ede45b153e3ULL);
  fb <<= *this;
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickEnum
MethodTestInterfaceHandle::method_with_enum (QuickEnum arg_input,
                                             QuickEnum arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xee3b0b1c6eb52bdeULL, 0x13729d2db240b4f9ULL);
  fb <<= *this;
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  QuickEnum  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickRecord
MethodTestInterfaceHandle::method_with_record (const QuickRecord &arg_input,
                                               const QuickRecord &arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x852c7f5942a87cceULL, 0x487dc78cd38240f6ULL);
  fb <<= *this;
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  QuickRecord  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickSequence
MethodTestInterfaceHandle::method_with_sequence (const QuickSequence &arg_input,
                                                 const QuickSequence &arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x5534838e08bdc63dULL, 0xd852fd5abb88ab7dULL);
  fb <<= *this;
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  QuickSequence  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
GrandChildHandle
MethodTestInterfaceHandle::method_with_interface (GrandChildHandle &arg_input,
                                                  GrandChildHandle &arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xfe9af28dc9c5de7dULL, 0x418be0c0e085ea6dULL);
  fb <<= *this;
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  GrandChildHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
Rapicorn::Aida::Any
MethodTestInterfaceHandle::method_with_anys (const Rapicorn::Aida::Any &arg_input,
                                             const Rapicorn::Aida::Any &arg_optval)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x807e5dacf307a277ULL, 0x2b65069e50e63c80ULL);
  fb <<= *this;
  fb <<= arg_input;
  fb <<= arg_optval;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  Rapicorn::Aida::Any  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
QuickIfaceHandle
MethodTestInterfaceHandle::method_with_quickiface (QuickIfaceHandle &arg_input,
                                                   QuickIfaceHandle &arg_iface0)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xbe67f4e0afeafd68ULL, 0x5cdf24c075b03215ULL);
  fb <<= *this;
  fb <<= arg_input;
  fb <<= arg_iface0;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  QuickIfaceHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__void_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__void_result (size_t signal_handler_id, const std::function<void ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void ()> (func);
  return __AIDA_Local__::signal_connect (0xe2ae7c707a04333cULL, 0x420330b70d64eb5fULL, *this, __aida_emit1__SignalTestInterfaceHandle__void_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__SignalTestInterfaceHandle__bool_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<bool ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  bool  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__bool_result (size_t signal_handler_id, const std::function<bool ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<bool ()> (func);
  return __AIDA_Local__::signal_connect (0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL, *this, __aida_emit2__SignalTestInterfaceHandle__bool_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__SignalTestInterfaceHandle__int32_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<int ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  int  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__int32_result (size_t signal_handler_id, const std::function<int ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<int ()> (func);
  return __AIDA_Local__::signal_connect (0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL, *this, __aida_emit2__SignalTestInterfaceHandle__int32_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__SignalTestInterfaceHandle__int64_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<Rapicorn::Aida::int64_t ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::int64_t  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__int64_result (size_t signal_handler_id, const std::function<Rapicorn::Aida::int64_t ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<Rapicorn::Aida::int64_t ()> (func);
  return __AIDA_Local__::signal_connect (0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL, *this, __aida_emit2__SignalTestInterfaceHandle__int64_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__SignalTestInterfaceHandle__float64_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<double ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  double  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__float64_result (size_t signal_handler_id, const std::function<double ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<double ()> (func);
  return __AIDA_Local__::signal_connect (0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL, *this, __aida_emit2__SignalTestInterfaceHandle__float64_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__SignalTestInterfaceHandle__string_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<std::string ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  std::string  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__string_result (size_t signal_handler_id, const std::function<std::string ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<std::string ()> (func);
  return __AIDA_Local__::signal_connect (0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL, *this, __aida_emit2__SignalTestInterfaceHandle__string_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__SignalTestInterfaceHandle__enum_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<QuickEnum ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  QuickEnum  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__enum_result (size_t signal_handler_id, const std::function<QuickEnum ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<QuickEnum ()> (func);
  return __AIDA_Local__::signal_connect (0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL, *this, __aida_emit2__SignalTestInterfaceHandle__enum_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__SignalTestInterfaceHandle__record_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<QuickRecord ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  QuickRecord  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__record_result (size_t signal_handler_id, const std::function<QuickRecord ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<QuickRecord ()> (func);
  return __AIDA_Local__::signal_connect (0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL, *this, __aida_emit2__SignalTestInterfaceHandle__record_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__SignalTestInterfaceHandle__sequence_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<QuickSequence ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  QuickSequence  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__sequence_result (size_t signal_handler_id, const std::function<QuickSequence ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<QuickSequence ()> (func);
  return __AIDA_Local__::signal_connect (0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL, *this, __aida_emit2__SignalTestInterfaceHandle__sequence_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__SignalTestInterfaceHandle__interface_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<GrandChildHandle ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  GrandChildHandle  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__interface_result (size_t signal_handler_id, const std::function<GrandChildHandle ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<GrandChildHandle ()> (func);
  return __AIDA_Local__::signal_connect (0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL, *this, __aida_emit2__SignalTestInterfaceHandle__interface_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__SignalTestInterfaceHandle__any_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<Rapicorn::Aida::Any ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::Any  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0x296163d4220985ceULL, 0x40daacab4a841093ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__any_result (size_t signal_handler_id, const std::function<Rapicorn::Aida::Any ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<Rapicorn::Aida::Any ()> (func);
  return __AIDA_Local__::signal_connect (0x296163d4220985ceULL, 0x40daacab4a841093ULL, *this, __aida_emit2__SignalTestInterfaceHandle__any_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__SignalTestInterfaceHandle__self_result (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<SignalTestInterfaceHandle ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  SignalTestInterfaceHandle  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0x35828273200534f7ULL, 0x72873f1374d6093bULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
SignalTestInterfaceHandle::__aida_connect__self_result (size_t signal_handler_id, const std::function<SignalTestInterfaceHandle ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<SignalTestInterfaceHandle ()> (func);
  return __AIDA_Local__::signal_connect (0x35828273200534f7ULL, 0x72873f1374d6093bULL, *this, __aida_emit2__SignalTestInterfaceHandle__self_result, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__void_arg (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__void_arg (size_t signal_handler_id, const std::function<void ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void ()> (func);
  return __AIDA_Local__::signal_connect (0xe79b3592345942f6ULL, 0x6818e92df5df5befULL, *this, __aida_emit1__SignalTestInterfaceHandle__void_arg, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__bool_arg (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (bool b)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__bool_arg (size_t signal_handler_id, const std::function<void (bool b)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (bool b)> (func);
  return __AIDA_Local__::signal_connect (0x495e3d2d698caad7ULL, 0xf16b2f75ddaf3220ULL, *this, __aida_emit1__SignalTestInterfaceHandle__bool_arg, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__int32_arg (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (int i)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__int32_arg (size_t signal_handler_id, const std::function<void (int i)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (int i)> (func);
  return __AIDA_Local__::signal_connect (0x1d335377194859d1ULL, 0xfa00c7fb47bc82e4ULL, *this, __aida_emit1__SignalTestInterfaceHandle__int32_arg, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__int64_arg (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (Rapicorn::Aida::int64_t i)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__int64_arg (size_t signal_handler_id, const std::function<void (Rapicorn::Aida::int64_t i)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (Rapicorn::Aida::int64_t i)> (func);
  return __AIDA_Local__::signal_connect (0x52b8b36ec08458caULL, 0xeecdb452f6b51528ULL, *this, __aida_emit1__SignalTestInterfaceHandle__int64_arg, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__float64_arg (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (double f)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__float64_arg (size_t signal_handler_id, const std::function<void (double f)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (double f)> (func);
  return __AIDA_Local__::signal_connect (0xdcacb20b2d942f30ULL, 0x242d314085f3e44aULL, *this, __aida_emit1__SignalTestInterfaceHandle__float64_arg, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__string_arg (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (const std::string &s)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__string_arg (size_t signal_handler_id, const std::function<void (const std::string &s)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (const std::string &s)> (func);
  return __AIDA_Local__::signal_connect (0x9bb22c59672e3921ULL, 0x981c8364b2197db9ULL, *this, __aida_emit1__SignalTestInterfaceHandle__string_arg, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__enum_arg (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (QuickEnum e)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__enum_arg (size_t signal_handler_id, const std::function<void (QuickEnum e)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (QuickEnum e)> (func);
  return __AIDA_Local__::signal_connect (0x62459d25ac74ebedULL, 0xd598edad744f61b7ULL, *this, __aida_emit1__SignalTestInterfaceHandle__enum_arg, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__record_arg (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (const QuickRecord &r)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__record_arg (size_t signal_handler_id, const std::function<void (const QuickRecord &r)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (const QuickRecord &r)> (func);
  return __AIDA_Local__::signal_connect (0xe4c732769519ca6aULL, 0x8cf6e34972e875aaULL, *this, __aida_emit1__SignalTestInterfaceHandle__record_arg, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__sequence_arg (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (const QuickSequence &s)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__sequence_arg (size_t signal_handler_id, const std::function<void (const QuickSequence &s)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (const QuickSequence &s)> (func);
  return __AIDA_Local__::signal_connect (0xeca8cf0dd80dee4aULL, 0x1bb3845a0704c774ULL, *this, __aida_emit1__SignalTestInterfaceHandle__sequence_arg, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__interface_arg (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (GrandChildHandle &i)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__interface_arg (size_t signal_handler_id, const std::function<void (GrandChildHandle &i)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (GrandChildHandle &i)> (func);
  return __AIDA_Local__::signal_connect (0xc2562bdab457affdULL, 0x189f1ba486f30579ULL, *this, __aida_emit1__SignalTestInterfaceHandle__interface_arg, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__any_arg (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (const Rapicorn::Aida::Any &a)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__any_arg (size_t signal_handler_id, const std::function<void (const Rapicorn::Aida::Any &a)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (const Rapicorn::Aida::Any &a)> (func);
  return __AIDA_Local__::signal_connect (0x445abac8fb3999b7ULL, 0x422ee36946f0b021ULL, *this, __aida_emit1__SignalTestInterfaceHandle__any_arg, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__SignalTestInterfaceHandle__self_args (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (SignalTestInterfaceHandle &self_)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
SignalTestInterfaceHandle::__aida_connect__self_args (size_t signal_handler_id, const std::function<void (SignalTestInterfaceHandle &self_)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (SignalTestInterfaceHandle &self_)> (func);
  return __AIDA_Local__::signal_connect (0xf62d65c3c8ab76a7ULL, 0x7f95ce585cfc2b0cULL, *this, __aida_emit1__SignalTestInterfaceHandle__self_args, fptr);
}
SignalTestInterfaceHandle::SignalTestInterfaceHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const SignalTestInterfaceHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, SignalTestInterfaceHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
SignalTestInterfaceHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x2873064ee22c0249ULL, 0xd8fae6f300b8e408ULL);
  return type_hash;
}
SignalTestInterfaceHandle
SignalTestInterfaceHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<SignalTestInterfaceHandle> (other);
  return SignalTestInterfaceHandle();
}
Rapicorn::Aida::BaseConnection*
SignalTestInterfaceHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
SignalTestInterfaceHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0xc00775d36cf38b56ULL, 0xf927beabb9c3e702ULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__ChildInheritingSignalsHandle__child_signal (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void (ChildInheritingSignalsHandle &c, SignalTestInterfaceHandle &p, const Rapicorn::Aida::Any &a, int i, const QuickRecord &r, const QuickSequence &s)>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
ChildInheritingSignalsHandle::__aida_connect__child_signal (size_t signal_handler_id, const std::function<void (ChildInheritingSignalsHandle &c, SignalTestInterfaceHandle &p, const Rapicorn::Aida::Any &a, int i, const QuickRecord &r, const QuickSequence &s)> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void (ChildInheritingSignalsHandle &c, SignalTestInterfaceHandle &p, const Rapicorn::Aida::Any &a, int i, const QuickRecord &r, const QuickSequence &s)> (func);
  return __AIDA_Local__::signal_connect (0x0b181d52b5db5237ULL, 0xd1c6370677791f5aULL, *this, __aida_emit1__ChildInheritingSignalsHandle__child_signal, fptr);
}
ChildInheritingSignalsHandle::ChildInheritingSignalsHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const ChildInheritingSignalsHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, ChildInheritingSignalsHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
ChildInheritingSignalsHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xf20ff30241b5b694ULL, 0x9f544b2626e183f0ULL);
  return type_hash;
}
ChildInheritingSignalsHandle
ChildInheritingSignalsHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<ChildInheritingSignalsHandle> (other);
  return ChildInheritingSignalsHandle();
}
const Rapicorn::Aida::TypeHashList
ChildInheritingSignalsHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0x8b9467d7db8651a9ULL, 0x8400cc0d7089975dULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
AnotherChildHandle::AnotherChildHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const AnotherChildHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, AnotherChildHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
AnotherChildHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x9a33af1b27f7e36dULL, 0xdf625f7bd18934faULL);
  return type_hash;
}
AnotherChildHandle
AnotherChildHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<AnotherChildHandle> (other);
  return AnotherChildHandle();
}
const Rapicorn::Aida::TypeHashList
AnotherChildHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0xb0dcc7e6e41eabafULL, 0x16ed0fc13e53cf22ULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
PropertyTesterHandle::PropertyTesterHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const PropertyTesterHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, PropertyTesterHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
PropertyTesterHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xa37ab462c55a3b3cULL, 0x4f3fd1c9ad9689fbULL);
  return type_hash;
}
PropertyTesterHandle
PropertyTesterHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<PropertyTesterHandle> (other);
  return PropertyTesterHandle();
}
Rapicorn::Aida::BaseConnection*
PropertyTesterHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
PropertyTesterHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0x29c1fdbcddc3d3d5ULL, 0xcf3a30b5bf14d1f1ULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
bool
PropertyTesterHandle::bool_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x14469c03fdfc61e4ULL, 0x3bb8a3b5d9832788ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  bool  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::bool_prop (bool value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xa88d7a16adc7ad43ULL, 0x33e7a32598f08880ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
int
PropertyTesterHandle::int32_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x8a2f1538f2b852fbULL, 0x7d3e8ea6f069a1c0ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  int  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::int32_prop (int value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0x7b7b3182160469e4ULL, 0xbd3c44c3a57484ebULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
Rapicorn::Aida::int64_t
PropertyTesterHandle::int64_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xc9bb6114fc5c90deULL, 0x400dff0f59e66f63ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  Rapicorn::Aida::int64_t  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::int64_prop (Rapicorn::Aida::int64_t value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xb33bf89d2259a1dbULL, 0x0154420aebe9a16cULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
double
PropertyTesterHandle::float64_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xb3d53f6a66ba171eULL, 0xc9e2fe1ad9d2d2abULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::float64_prop (double value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xf1df5bd296ac78e2ULL, 0xbb263cff89927093ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
std::string
PropertyTesterHandle::string_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xd11acce29fa83acfULL, 0xb251b5fc0f737558ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::string_prop (const std::string &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xfadb1eed1d8d358aULL, 0x17cd2ca684080698ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
QuickEnum
PropertyTesterHandle::enum_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x42f93106aeb5af11ULL, 0xdc4094dc01da9f81ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  QuickEnum  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::enum_prop (QuickEnum value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0x99206fff699c82d6ULL, 0x1dcbc77498569411ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
QuickRecord
PropertyTesterHandle::record_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xb6ab96740d7834eeULL, 0xe7873bec722bb0c8ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  QuickRecord  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::record_prop (const QuickRecord &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0x55aaf8cee9dd7a46ULL, 0x83d8416416740bf0ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
QuickSequence
PropertyTesterHandle::sequence_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x7f96e6ff442ecdd5ULL, 0xdb054c03831fd75bULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  QuickSequence  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::sequence_prop (const QuickSequence &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xf86952a034b8bc84ULL, 0x3be169a3f0a9a07dULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
GrandChildHandle
PropertyTesterHandle::interface_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xf3cef8a00677d931ULL, 0x8733ca529b58ea4aULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  GrandChildHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::interface_prop (GrandChildHandle value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xbf62779e2a11aebbULL, 0x95547f4e29ca3814ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
PropertyTesterHandle
PropertyTesterHandle::self_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xdd2a04f6c2fc3005ULL, 0x68868b01ea78948fULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  PropertyTesterHandle  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::self_prop (PropertyTesterHandle value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0x1a1ee3ab20ab3c2fULL, 0xeeaf17826dba2891ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
Rapicorn::Aida::Any
PropertyTesterHandle::any_prop () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xb54c6ac2d1c8f932ULL, 0x1c8ea2813f2c268eULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  Rapicorn::Aida::Any  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
PropertyTesterHandle::any_prop (const Rapicorn::Aida::Any &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xe0c7d397e652f3f7ULL, 0xbbdf7826e88f4f42ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
} // InterfaceTests

namespace RapicornAidaTest {

static Rapicorn::Init __aida_autoinit__ClickType ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_ON_PRESS),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_ON_RELEASE),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_SLOW_REPEAT),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_FAST_REPEAT),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_KEY_REPEAT),
  };
  Rapicorn::Aida::EnumInfo::enlist ("RapicornAidaTest", "ClickType", enum_values);
});
static Rapicorn::Aida::FieldBuffer*
__aida_emit2__ButtonAreaHandle__check_activate (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<bool ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  bool  rval = Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_emit_result (sfb, 0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL, 2);
  rb <<= emit_result_id;
  rb <<= rval;
  return &rb;
}
size_t
ButtonAreaHandle::__aida_connect__check_activate (size_t signal_handler_id, const std::function<bool ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<bool ()> (func);
  return __AIDA_Local__::signal_connect (0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL, *this, __aida_emit2__ButtonAreaHandle__check_activate, fptr);
}
static Rapicorn::Aida::FieldBuffer*
__aida_emit1__ButtonAreaHandle__activate (const Rapicorn::Aida::FieldBuffer *sfb, void *data)
{
  auto fptr = (const std::function<void ()>*) data;
  if (AIDA_UNLIKELY (!sfb)) { delete fptr; return NULL; }
  Rapicorn::Aida::uint64_t emit_result_id;
  Rapicorn::Aida::field_buffer_emit_signal (*sfb, *fptr, emit_result_id);
  return NULL;
}
size_t
ButtonAreaHandle::__aida_connect__activate (size_t signal_handler_id, const std::function<void ()> &func)
{
  if (signal_handler_id)
    return __AIDA_Local__::signal_disconnect (signal_handler_id);
  void *fptr = new std::function<void ()> (func);
  return __AIDA_Local__::signal_connect (0x0c46b868988bad84ULL, 0xff7acbea142bbcd0ULL, *this, __aida_emit1__ButtonAreaHandle__activate, fptr);
}
ButtonAreaHandle::ButtonAreaHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const ButtonAreaHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, ButtonAreaHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
ButtonAreaHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xec371b296fa57436ULL, 0x92e4310e386fc92eULL);
  return type_hash;
}
ButtonAreaHandle
ButtonAreaHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<ButtonAreaHandle> (other);
  return ButtonAreaHandle();
}
Rapicorn::Aida::BaseConnection*
ButtonAreaHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
ButtonAreaHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0xf01d6b5002a758fcULL, 0xa481606dbc2f4257ULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
std::string
ButtonAreaHandle::on_click () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x199859aecc756e97ULL, 0xa744332174ed27f4ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::on_click (const std::string &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xdb3a24116c653985ULL, 0x2a0576faff45b4b2ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
std::string
ButtonAreaHandle::on_click2 () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x1b448d91990181daULL, 0x9751c08ae956c729ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::on_click2 (const std::string &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xfc93898ba4104662ULL, 0xc918694fe5c2bfefULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
std::string
ButtonAreaHandle::on_click3 () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0x5176fbf25dcf50f4ULL, 0x4d7ae8b51fb816b5ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  std::string  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::on_click3 (const std::string &value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0x1c1990dca0fde97cULL, 0x6cc2c7cc49d811f8ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
ClickType
ButtonAreaHandle::click_type () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xb6ab79b43e1f0df9ULL, 0xaa0f1ec5c39b704aULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  ClickType  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
ButtonAreaHandle::click_type (ClickType value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0x1f5a6d031cb7e104ULL, 0x2d4a207f0842bec8ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
PureMethodsHandle::PureMethodsHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const PureMethodsHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, PureMethodsHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
PureMethodsHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0xddc2a514d04d3af5ULL, 0xc0046740434c0486ULL);
  return type_hash;
}
PureMethodsHandle
PureMethodsHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<PureMethodsHandle> (other);
  return PureMethodsHandle();
}
Rapicorn::Aida::BaseConnection*
PureMethodsHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
PureMethodsHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0x95676eb8489beea1ULL, 0xe9444b3b7f24a24dULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
int
PureMethodsHandle::pure_method (double arg_f)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xf196563f00b6d484ULL, 0x88b59c2ed0597dccULL);
  fb <<= *this;
  fb <<= arg_f;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  int  retval;
  frr >>= retval;
  delete fr;
  return retval;
}

static Rapicorn::Init __aida_autoinit__MathExpressions ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_2),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_5),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_8),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_6),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_7),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_16),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_3),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_24),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_13),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_m2),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_77),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_511),
  };
  Rapicorn::Aida::EnumInfo::enlist ("RapicornAidaTest", "MathExpressions", enum_values);
});
} // RapicornAidaTest

namespace Other {
NameTestsHandle::NameTestsHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const NameTestsHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, NameTestsHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
NameTestsHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x542d40cd7d8fcd40ULL, 0x8c1782df29c9b936ULL);
  return type_hash;
}
NameTestsHandle
NameTestsHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<NameTestsHandle> (other);
  return NameTestsHandle();
}
Rapicorn::Aida::BaseConnection*
NameTestsHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
NameTestsHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0x18584b48b3907ce2ULL, 0xab88c262da15a085ULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
void
NameTestsHandle::args_from_other_namespace (const InterfaceTests::QuickRecord &arg_qr,
                                            RapicornAidaTest::ClickType arg_qe,
                                            const OtherNamespace::SomeRecord &arg_sr)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 3), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xd471f88e8c15081cULL, 0x963d2094339d0220ULL);
  fb <<= *this;
  fb <<= arg_qr;
  fb <<= arg_qe;
  fb <<= arg_sr;
  fr = __AIDA_Local__::invoke (&fb);
  if (AIDA_UNLIKELY (fr != NULL)) delete fr;
}
} // Other

namespace BseTest {
CompressorHandle::CompressorHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const CompressorHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, CompressorHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
CompressorHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x42057a05d51182dfULL, 0x6a0d69cda274433eULL);
  return type_hash;
}
CompressorHandle
CompressorHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<CompressorHandle> (other);
  return CompressorHandle();
}
Rapicorn::Aida::BaseConnection*
CompressorHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
CompressorHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0x4d6cadb87efc3ea8ULL, 0x2264b93a5a23a8baULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
double
CompressorHandle::threshold () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xdea15f2de1c3d8e3ULL, 0xe3fc9febf31cdc20ULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
CompressorHandle::threshold (double value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0xf40a3fd3d07b3d0bULL, 0xbae97c41e3d6a92bULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
double
CompressorHandle::ratio () const
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1), *fr = NULL;
  __AIDA_Local__::add_header2_call (fb, *this, 0xc61a8d739c7b963bULL, 0xca1ad4eeab1aa56eULL);
  fb <<= *this;
  fr = __AIDA_Local__::invoke (&fb);
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  double  retval;
  frr >>= retval;
  delete fr;
  return retval;
}
void
CompressorHandle::ratio (double value)
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1), *fr = NULL;
  __AIDA_Local__::add_header1_call (fb, *this, 0x302f0b5b99a2a6c8ULL, 0xc8b771894ecd9315ULL);
  fb <<= *this;
  fb <<= value;
  fr = __AIDA_Local__::invoke (&fb);
  if (fr) delete fr;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const RecordForGroups &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (5);
  fb <<= self.i;
  fb <<= self.ratio;
  fb <<= self.ordinary_bool;
  fb <<= self.threshold1;
  fb <<= self.threshold2;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, RecordForGroups &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 5) return;
  fbr >>= self.i;
  fbr >>= self.ratio;
  fbr >>= self.ordinary_bool;
  fbr >>= self.threshold1;
  fbr >>= self.threshold2;
}
SoundModuleHandle::SoundModuleHandle ()
{}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const SoundModuleHandle &handle)
{
  fb.add_object (__AIDA_Local__::smh2id (handle));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, SoundModuleHandle &handle)
{
  Rapicorn::Aida::ObjectBroker::pop_handle (fbr, handle);
}
const Rapicorn::Aida::TypeHash&
SoundModuleHandle::__aida_typeid__()
{
  static const Rapicorn::Aida::TypeHash type_hash = Rapicorn::Aida::TypeHash (0x06447b38b51e0198ULL, 0x848669199cc311deULL);
  return type_hash;
}
SoundModuleHandle
SoundModuleHandle::__aida_cast__ (Rapicorn::Aida::SmartHandle &other, const Rapicorn::Aida::TypeHashList &types)
{
  size_t i; const Rapicorn::Aida::TypeHash &mine = __aida_typeid__();
  for (i = 0; i < types.size(); i++)
    if (mine == types[i])
      return __AIDA_Local__::smh2cast<SoundModuleHandle> (other);
  return SoundModuleHandle();
}
Rapicorn::Aida::BaseConnection*
SoundModuleHandle::__aida_connection__()
{
  return __AIDA_Local__::client_connection;
}
const Rapicorn::Aida::TypeHashList
SoundModuleHandle::__aida_typelist__()
{
  Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
  __AIDA_Local__::add_header2_call (fb, *this, 0x6d65d3efbafc393bULL, 0x3adf67dd71b475a6ULL);
  fb <<= *this;
  Rapicorn::Aida::FieldBuffer *fr = __AIDA_Local__::invoke (&fb);
  AIDA_CHECK (fr != NULL, "missing result from 2-way call");
  Rapicorn::Aida::FieldReader frr (*fr);
  frr.skip_header();
  size_t len;
  frr >>= len;
  AIDA_CHECK (frr.remaining() == len * 2, "result truncated");
  Rapicorn::Aida::TypeHashList thl;
  Rapicorn::Aida::TypeHash thash;
  for (size_t i = 0; i < len; i++) {
    frr >>= thash;
    thl.push_back (thash);
  }
  delete fr;
  return thl;
}
} // BseTest

namespace { // Anon
static const char __aida_type_map__[] =
  "AidaTypeMap\0\0\0\0\0x!\0\0\0\0\0\0\0\0\0\0\0\0\0\0@\0\0\0 \7\0\0\30\20"
  "\0\0\0\0\0\0\20\17\0\0\0\0\0\0\0\0\0\0\0\0\0\0Y\0\0\0\30\20\0\0 \7"
  "\0\0\0\0\0\0b\0\0\0<\20\0\0 \7\0\0\0\0\0\0E\0\0\0`\20\0\0 \7\0\0$\7"
  "\0\0d\0\0\0\340\22\0\0 \7\0\0\0\0\0\0i\0\0\0\4\23\0\0 \7\0\0\0\0\0"
  "\0l\0\0\0(\23\0\0 \7\0\0\0\0\0\0b\0\0\0p\23\0\0 \7\0\0\0\0\0\0i\0\0"
  "\0\200\23\0\0 \7\0\0\0\0\0\0l\0\0\0\220\23\0\0 \7\0\0\0\0\0\0d\0\0\0"
  "\234\23\0\0 \7\0\0\0\0\0\0s\0\0\0\260\23\0\0 \7\0\0\0\0\0\0i\0\0\0"
  "\304\23\0\0 \7\0\0\0\0\0\0i\0\0\0\324\23\0\0 \7\0\0\0\0\0\0i\0\0\0\344"
  "\23\0\0 \7\0\0\0\0\0\0i\0\0\0\360\23\0\0 \7\0\0\0\0\0\0i\0\0\0\374"
  "\23\0\0 \7\0\0\0\0\0\0i\0\0\0\10\24\0\0 \7\0\0\0\0\0\0T\0\0\0\24\24"
  "\0\0 \7\0\0$\24\0\0T\0\0\0L\24\0\0 \7\0\0X\24\0\0T\0\0\0\200\24\0"
  "\0 \7\0\0X\24\0\0T\0\0\0\214\24\0\0 \7\0\0X\24\0\0Y\0\0\0\230\24\0\0"
  " \7\0\0\0\0\0\0Y\0\0\0\244\24\0\0 \7\0\0\0\0\0\0Y\0\0\0\260\24\0\0"
  " \7\0\0\0\0\0\0R\0\0\0L\23\0\0 \7\0\0\344\11\0\0Q\0\0\0\274\24\0\0 "
  "\7\0\0\240\0\0\0s\0\0\0\344\24\0\0 \7\0\0\0\0\0\0C\0\0\0\10\25\0\0 "
  "\7\0\0""0\12\0\0Y\0\0\0x\25\0\0 \7\0\0\0\0\0\0Q\0\0\0T\25\0\0 \7\0\0"
  "\0\2\0\0i\0\0\0\210\25\0\0""8\12\0\0\0\0\0\0l\0\0\0\354\25\0\0L\12"
  "\0\0\0\0\0\0b\0\0\0T\26\0\0`\12\0\0\0\0\0\0d\0\0\0\244\26\0\0t\12\0"
  "\0\0\0\0\0s\0\0\0\10\27\0\0\210\12\0\0\0\0\0\0C\0\0\0d\27\0\0 \7\0\0"
  " \7\0\0C\0\0\0\210\27\0\0 \7\0\0\234\12\0\0C\0\0\0\300\27\0\0 \7\0"
  "\0""0\12\0\0E\0\0\0\354\27\0\0 \7\0\0\244\12\0\0C\0\0\0\200\30\0\0 "
  "\7\0\0 \7\0\0C\0\0\0\230\30\0\0 \7\0\0\14\13\0\0E\0\0\0\270\30\0\0 "
  "\7\0\0\30\13\0\0E\0\0\0\344\30\0\0 \7\0\0""0\13\0\0E\0\0\0\20\31\0\0"
  " \7\0\0H\13\0\0E\0\0\0H\31\0\0 \7\0\0t\13\0\0E\0\0\0\200\31\0\0 \7"
  "\0\0\240\13\0\0E\0\0\0\304\31\0\0 \7\0\0\340\13\0\0E\0\0\0\10\32\0\0"
  " \7\0\0 \14\0\0E\0\0\0X\32\0\0 \7\0\0t\14\0\0E\0\0\0\250\32\0\0 \7"
  "\0\0\310\14\0\0E\0\0\0\370\32\0\0 \7\0\0\34\15\0\0E\0\0\0$\24\0\0 \7"
  "\0\0$\7\0\0T\0\0\0x\33\0\0 \7\0\0$\24\0\0Q\0\0\0H\33\0\0 \7\0\0\200"
  "\3\0\0C\0\0\0X\24\0\0 \7\0\0 \7\0\0d\0\0\0\264\33\0\0 \7\0\0\0\0\0"
  "\0Q\0\0\0\214\33\0\0 \7\0\0\260\3\0\0C\0\0\0\310\33\0\0 \7\0\0p\15\0"
  "\0i\0\0\0\24\34\0\0 \7\0\0\0\0\0\0i\0\0\0\34\34\0\0 \7\0\0\0\0\0\0"
  "T\0\0\0$\34\0\0 \7\0\0,\34\0\0R\0\0\0\350\33\0\0 \7\0\0\200\15\0\0i"
  "\0\0\0t\34\0\0 \7\0\0\0\0\0\0Q\0\0\0P\34\0\0 \7\0\0 \4\0\0Q\0\0\0\200"
  "\34\0\0 \7\0\0`\1\0\0E\0\0\0\254\34\0\0 \7\0\0\220\15\0\0C\0\0\0\224"
  "\35\0\0 \7\0\0 \7\0\0C\0\0\0\274\35\0\0 \7\0\0 \7\0\0T\0\0\0$\34"
  "\0\0 \7\0\0\374\35\0\0T\0\0\0 \36\0\0 \7\0\0(\36\0\0R\0\0\0\324\35\0"
  "\0 \7\0\0\204\16\0\0T\0\0\0x\36\0\0 \7\0\0\324\35\0\0Q\0\0\0P\36\0"
  "\0 \7\0\0\260\4\0\0i\0\0\0\200\36\0\0 \7\0\0\0\0\0\0T\0\0\0\210\36\0"
  "\0 \7\0\0\270\30\0\0T\0\0\0\224\36\0\0 \7\0\0(\36\0\0R\0\0\0,\34\0"
  "\0 \7\0\0\220\16\0\0C\0\0\0\244\27\0\0 \7\0\0 \7\0\0C\0\0\0\234\36\0"
  "\0 \7\0\0 \7\0\0C\0\0\0\300\36\0\0 \7\0\0 \7\0\0E\0\0\0\344\36\0\0"
  " \7\0\0\244\16\0\0C\0\0\0\20\37\0\0 \7\0\0 \7\0\0i\0\0\0P\37\0\0 \7"
  "\0\0\0\0\0\0i\0\0\0\\\37\0\0 \7\0\0\0\0\0\0R\0\0\0""0\37\0\0 \7\0\0"
  "\274\16\0\0d\0\0\0\214\37\0\0 \7\0\0\0\0\0\0Q\0\0\0h\37\0\0 \7\0\0\220"
  "\5\0\0d\0\0\0\274\37\0\0\310\16\0\0\0\0\0\0b\0\0\0\354\37\0\0 \7"
  "\0\0\0\0\0\0d\0\0\0\0 \0\0 \7\0\0\0\0\0\0d\0\0\0\20 \0\0 \7\0\0\0\0"
  "\0\0R\0\0\0\234\37\0\0 \7\0\0\334\16\0\0T\0\0\0H \0\0 \7\0\0\374\35"
  "\0\0Q\0\0\0  \0\0 \7\0\0\0\6\0\0T\0\0\0\200 \0\0 \7\0\0\350\33\0\0R"
  "\0\0\0\\ \0\0 \7\0\0\364\16\0\0T\0\0\0\264 \0\0 \7\0\0P\34\0\0Q\0\0"
  "\0\210 \0\0 \7\0\0@\6\0\0C\0\0\0,\25\0\0 \7\0\0 \7\0\0T\0\0\0\344 \0"
  "\0 \7\0\0,\34\0\0T\0\0\0\354 \0\0 \7\0\0,\34\0\0T\0\0\0\364 \0\0 \7"
  "\0\0\350\33\0\0T\0\0\0\374 \0\0 \7\0\0\350\33\0\0R\0\0\0\304 \0\0 "
  "\7\0\0\374\16\0\0C\0\0\0\4!\0\0 \7\0\0 \7\0\0s\0\0\0H!\0\0 \7\0\0\0"
  "\0\0\0Q\0\0\0 !\0\0 \7\0\0\320\6\0\0C\0\0\0T!\0\0 \7\0\0 \7\0\0R\0\0"
  "\0\374\35\0\0 \7\0\0\344\11\0\0Q\0\0\0(\36\0\0 \7\0\0\240\0\0\0\0\0"
  "\0\0\257\0\0\0\1\0\0\0\0\0\0\0\204\20\0\0\214\20\0\0\214\20\0\0\1\0"
  "\0\0\0\0\0\0\224\20\0\0\214\20\0\0\214\20\0\0\2\0\0\0\0\0\0\0\234\20"
  "\0\0\214\20\0\0\214\20\0\0\3\0\0\0\0\0\0\0\244\20\0\0\254\20\0\0\214"
  "\20\0\0\4\0\0\0\0\0\0\0\270\20\0\0\300\20\0\0\214\20\0\0\5\0\0\0"
  "\0\0\0\0\314\20\0\0\324\20\0\0\340\20\0\0\6\0\0\0\0\0\0\0\354\20\0\0"
  "\364\20\0\0\0\21\0\0\7\0\0\0\0\0\0\0\14\21\0\0\24\21\0\0 \21\0\0\10"
  "\0\0\0\0\0\0\0,\21\0\0""4\21\0\0@\21\0\0\11\0\0\0\0\0\0\0L\21\0\0\214"
  "\20\0\0\214\20\0\0\12\0\0\0\0\0\0\0T\21\0\0\\\21\0\0\214\20\0\0\13"
  "\0\0\0\0\0\0\0h\21\0\0p\21\0\0\214\20\0\0\14\0\0\0\0\0\0\0\200\21"
  "\0\0\210\21\0\0\214\20\0\0\15\0\0\0\0\0\0\0\224\21\0\0\214\20\0\0\214"
  "\20\0\0\16\0\0\0\0\0\0\0\234\21\0\0\244\21\0\0\214\20\0\0\17\0\0\0"
  "\0\0\0\0\264\21\0\0\274\21\0\0\310\21\0\0\20\0\0\0\0\0\0\0\324\21\0"
  "\0\334\21\0\0\354\21\0\0\21\0\0\0\0\0\0\0\370\21\0\0\0\22\0\0\14\22"
  "\0\0\22\0\0\0\0\0\0\0\34\22\0\0$\22\0\0""4\22\0\0\24\0\0\0\0\0\0\0"
  "D\22\0\0\214\20\0\0\214\20\0\0\25\0\0\0\0\0\0\0L\22\0\0\214\20\0\0\214"
  "\20\0\0\26\0\0\0\0\0\0\0T\22\0\0\214\20\0\0\214\20\0\0\27\0\0\0\0"
  "\0\0\0\\\22\0\0\214\20\0\0\214\20\0\0\30\0\0\0\0\0\0\0d\22\0\0\214"
  "\20\0\0\214\20\0\0\360\377\377\377\377\377\377\377l\22\0\0\214\20\0"
  "\0\214\20\0\0\20\0\0\0\0\0\0\0t\22\0\0\214\20\0\0\214\20\0\0\360\377"
  "\377\377\377\377\377\377|\22\0\0\214\20\0\0\214\20\0\0\344\377\377"
  "\377\377\377\377\377\204\22\0\0\214\20\0\0\214\20\0\0*\0\0\0\0\0\0\0"
  "\214\22\0\0\214\20\0\0\214\20\0\0+\0\0\0\0\0\0\0\224\22\0\0\234\22"
  "\0\0\214\20\0\0*\0\0\0\0\0\0\0\250\22\0\0\214\20\0\0\214\20\0\0+\0\0"
  "\0\0\0\0\0\260\22\0\0\234\22\0\0\214\20\0\0,\0\0\0\0\0\0\0\270\22\0"
  "\0\234\22\0\0\234\22\0\0*\0\0\0\0\0\0\0\300\22\0\0\234\22\0\0\214\20"
  "\0\0*\0\0\0\0\0\0\0\310\22\0\0\234\22\0\0\320\22\0\0\22\0\0\0\240"
  "\0\0\0\260\0\0\0\300\0\0\0\320\0\0\0\340\0\0\0\360\0\0\0\0\1\0\0\20"
  "\1\0\0 \1\0\0""0\1\0\0@\1\0\0P\1\0\0`\1\0\0p\1\0\0\200\1\0\0\220\1\0"
  "\0\240\1\0\0\260\1\0\0\1\0\0\0,\25\0\0\4\0\0\0\234\25\0\0\260\25\0"
  "\0\300\25\0\0\334\25\0\0\4\0\0\0\0\26\0\0 \26\0\0""0\26\0\0\334\25\0"
  "\0\4\0\0\0l\26\0\0|\26\0\0\220\26\0\0\334\25\0\0\4\0\0\0\270\26\0\0"
  "\314\26\0\0\340\26\0\0\370\26\0\0\4\0\0\0\34\27\0\0""4\27\0\0H\27\0"
  "\0\334\25\0\0\1\0\0\0\244\27\0\0\31\0\0\0\1\0\0\0\0\0\0\0\14\30\0\0"
  "\214\20\0\0\214\20\0\0\2\0\0\0\0\0\0\0 \30\0\0\214\20\0\0\214\20\0"
  "\0\3\0\0\0\0\0\0\0""8\30\0\0\214\20\0\0\214\20\0\0\4\0\0\0\0\0\0\0P"
  "\30\0\0\214\20\0\0\214\20\0\0\5\0\0\0\0\0\0\0h\30\0\0\214\20\0\0\214"
  "\20\0\0\2\0\0\0\244\27\0\0\210\27\0\0\5\0\0\0\1\0\0\0\0\0\0\0\330\30"
  "\0\0\214\20\0\0\214\20\0\0\5\0\0\0\1\0\0\0\0\0\0\0\4\31\0\0\214\20"
  "\0\0\214\20\0\0\12\0\0\0\1\0\0\0\0\0\0\0""0\31\0\0\214\20\0\0\214\20"
  "\0\0\2\0\0\0\0\0\0\0<\31\0\0\214\20\0\0\214\20\0\0\12\0\0\0\1\0\0"
  "\0\0\0\0\0h\31\0\0\214\20\0\0\214\20\0\0\2\0\0\0\0\0\0\0t\31\0\0\214"
  "\20\0\0\214\20\0\0\17\0\0\0\1\0\0\0\0\0\0\0\240\31\0\0\214\20\0\0\214"
  "\20\0\0\2\0\0\0\0\0\0\0\254\31\0\0\214\20\0\0\214\20\0\0\3\0\0\0"
  "\0\0\0\0\270\31\0\0\214\20\0\0\214\20\0\0\17\0\0\0\1\0\0\0\0\0\0\0\344"
  "\31\0\0\214\20\0\0\214\20\0\0\2\0\0\0\0\0\0\0\360\31\0\0\214\20\0"
  "\0\214\20\0\0\3\0\0\0\0\0\0\0\374\31\0\0\214\20\0\0\214\20\0\0\24\0"
  "\0\0\1\0\0\0\0\0\0\0(\32\0\0\214\20\0\0\214\20\0\0\2\0\0\0\0\0\0\0"
  "4\32\0\0\214\20\0\0\214\20\0\0\3\0\0\0\0\0\0\0@\32\0\0\214\20\0\0\214"
  "\20\0\0\4\0\0\0\0\0\0\0L\32\0\0\214\20\0\0\214\20\0\0\24\0\0\0\1\0"
  "\0\0\0\0\0\0x\32\0\0\214\20\0\0\214\20\0\0\2\0\0\0\0\0\0\0\204\32\0"
  "\0\214\20\0\0\214\20\0\0\3\0\0\0\0\0\0\0\220\32\0\0\214\20\0\0\214"
  "\20\0\0\4\0\0\0\0\0\0\0\234\32\0\0\214\20\0\0\214\20\0\0\24\0\0\0\1"
  "\0\0\0\0\0\0\0\310\32\0\0\214\20\0\0\214\20\0\0\2\0\0\0\0\0\0\0\324"
  "\32\0\0\214\20\0\0\214\20\0\0\3\0\0\0\0\0\0\0\340\32\0\0\214\20\0\0"
  "\214\20\0\0\4\0\0\0\0\0\0\0\354\32\0\0\214\20\0\0\214\20\0\0\24\0\0"
  "\0\1\0\0\0\0\0\0\0\30\33\0\0\214\20\0\0\214\20\0\0\2\0\0\0\0\0\0\0$"
  "\33\0\0\214\20\0\0\214\20\0\0\3\0\0\0\0\0\0\0""0\33\0\0\214\20\0\0\214"
  "\20\0\0\4\0\0\0\0\0\0\0<\33\0\0\214\20\0\0\214\20\0\0\3\0\0\0\244"
  "\27\0\0\210\27\0\0\230\30\0\0\3\0\0\0\340\3\0\0\360\3\0\0\0\4\0\0<"
  "\0\0\0\2\0\0\0\0\0\0\0\324\34\0\0\214\20\0\0\214\20\0\0\5\0\0\0\0\0"
  "\0\0\344\34\0\0\214\20\0\0\214\20\0\0\10\0\0\0\0\0\0\0\364\34\0\0\214"
  "\20\0\0\214\20\0\0\6\0\0\0\0\0\0\0\4\35\0\0\214\20\0\0\214\20\0\0"
  "\7\0\0\0\0\0\0\0\24\35\0\0\214\20\0\0\214\20\0\0\20\0\0\0\0\0\0\0$\35"
  "\0\0\214\20\0\0\214\20\0\0\3\0\0\0\0\0\0\0""4\35\0\0\214\20\0\0\214"
  "\20\0\0\30\0\0\0\0\0\0\0D\35\0\0\214\20\0\0\214\20\0\0\15\0\0\0\0"
  "\0\0\0T\35\0\0\214\20\0\0\214\20\0\0\376\377\377\377\377\377\377\377"
  "d\35\0\0\214\20\0\0\214\20\0\0M\0\0\0\0\0\0\0t\35\0\0\214\20\0\0\214"
  "\20\0\0\377\1\0\0\0\0\0\0\204\35\0\0\214\20\0\0\214\20\0\0\2\0\0\0"
  "\200\4\0\0\220\4\0\0\4\0\0\0\320\4\0\0\340\4\0\0\360\4\0\0\260\4\0"
  "\0\5\0\0\0\0\0\0\0\0\0\0\0\4\37\0\0\214\20\0\0\214\20\0\0\2\0\0\0`\5"
  "\0\0p\5\0\0\4\0\0\0l\26\0\0\310\37\0\0\324\37\0\0\340\37\0\0\5\0\0"
  "\0\320\4\0\0\260\5\0\0\300\5\0\0\320\5\0\0\340\5\0\0\1\0\0\0 \6\0\0"
  "\4\0\0\0p\6\0\0\200\6\0\0\220\6\0\0\240\6\0\0A\0\0\0@\0\0\0P\0\0\0`"
  "\0\0\0p\0\0\0\200\0\0\0\220\0\0\0\300\1\0\0\320\1\0\0\340\1\0\0\360"
  "\1\0\0\20\2\0\0 \2\0\0""0\2\0\0@\2\0\0P\2\0\0`\2\0\0p\2\0\0\200\2\0"
  "\0\220\2\0\0\240\2\0\0\260\2\0\0\300\2\0\0\320\2\0\0\340\2\0\0\360\2"
  "\0\0\0\3\0\0\20\3\0\0 \3\0\0""0\3\0\0@\3\0\0P\3\0\0`\3\0\0p\3\0\0\220"
  "\3\0\0\240\3\0\0\300\3\0\0\320\3\0\0\20\4\0\0""0\4\0\0@\4\0\0P\4"
  "\0\0`\4\0\0p\4\0\0\240\4\0\0\300\4\0\0\0\5\0\0\20\5\0\0 \5\0\0""0\5"
  "\0\0""0\5\0\0@\5\0\0P\5\0\0\200\5\0\0\240\5\0\0\360\5\0\0\20\6\0\0""0"
  "\6\0\0P\6\0\0`\6\0\0\260\6\0\0\300\6\0\0\340\6\0\0\360\6\0\0\0\7\0"
  "\0\20\7\0\0\34\0\0\0MandatoryNamespace::AliasAny\0   \35\0\0\0Mand"
  "atoryNamespace::AliasBool\0  \35\0\0\0MandatoryNamespace::AliasEnum"
  "\0  \3\0\0\0V1a\0\0\0\0\0\0   \3\0\0\0V1b\0\2\0\0\0V2\0 \2\0\0\0V3\0"
  " \4\0\0\0\"v3\"\0   \2\0\0\0V4\0 \7\0\0\0_(\"v4\")\0\2\0\0\0V5\0 \4"
  "\0\0\0\"v5\"\0   \4\0\0\0\"V5\"\0   \2\0\0\0V6\0 \7\0\0\0_(\"v6\")"
  "\0\4\0\0\0\"V6\"\0   \2\0\0\0V7\0 \4\0\0\0\"v7\"\0   \7\0\0\0_(\"V7"
  "\")\0\2\0\0\0V8\0 \7\0\0\0_(\"v8\")\0\7\0\0\0_(\"V8\")\0\2\0\0\0V9\0"
  " \3\0\0\0V10\0\5\0\0\0\"v10\"\0  \3\0\0\0V11\0\10\0\0\0_(\"v11\")\0"
  "   \3\0\0\0V12\0\5\0\0\0\"v12\"\0  \3\0\0\0V13\0\3\0\0\0V14\0\10\0"
  "\0\0_(\"v14\")\0   \3\0\0\0V15\0\5\0\0\0\"v15\"\0  \5\0\0\0\"V15\"\0"
  "  \3\0\0\0V16\0\10\0\0\0_(\"v16\")\0   \5\0\0\0\"V16\"\0  \3\0\0\0"
  "V17\0\5\0\0\0\"v17\"\0  \10\0\0\0_(\"V17\")\0   \3\0\0\0V18\0\10\0\0"
  "\0_(\"v18\")\0   \10\0\0\0_(\"V18\")\0   \3\0\0\0V20\0\3\0\0\0V21\0"
  "\3\0\0\0V22\0\3\0\0\0V23\0\3\0\0\0V24\0\3\0\0\0V25\0\3\0\0\0V26\0\3"
  "\0\0\0V27\0\3\0\0\0V28\0\3\0\0\0V30\0\3\0\0\0V31\0\5\0\0\0\"foo\"\0"
  "  \3\0\0\0V32\0\3\0\0\0V33\0\3\0\0\0V34\0\3\0\0\0V35\0\3\0\0\0V36\0"
  "\10\0\0\0\"foo\"\"4\"\0   \36\0\0\0MandatoryNamespace::AliasFloat\0"
  " \36\0\0\0MandatoryNamespace::AliasInt32\0 \36\0\0\0MandatoryNames"
  "pace::AliasInt64\0 \37\0\0\0MandatoryNamespace::AliasRecord\0\13\0\0"
  "\0single_bool\0\12\0\0\0single_num\0 \5\0\0\0num64\0  \14\0\0\0sin"
  "gle_float\0   \15\0\0\0single_string\0  \10\0\0\0sibling1\0   \10\0"
  "\0\0sibling2\0   \6\0\0\0multi1\0 \6\0\0\0multi2\0 \6\0\0\0multi3\0"
  " \6\0\0\0multi4\0 \12\0\0\0enum_field\0 !\0\0\0MandatoryNamespace::"
  "ExtensiveEnum\0  \6\0\0\0iface1\0 \"\0\0\0MandatoryNamespace::First"
  "Interface\0 \6\0\0\0iface2\0 \6\0\0\0iface3\0 \4\0\0\0any1\0   \4\0"
  "\0\0any2\0   \4\0\0\0any3\0   !\0\0\0MandatoryNamespace::AliasSeque"
  "nce\0  \37\0\0\0MandatoryNamespace::AliasString\0\34\0\0\0Interface"
  "Tests::AnotherChild\0   #\0\0\0InterfaceTests::SignalTestInterface\0"
  "\37\0\0\0MandatoryNamespace::AnySequence\0\11\0\0\0any_value\0  \16"
  "\0\0\0Auxdata::Aux32\0 \17\0\0\0default=10007.0\0\13\0\0\0label=Au"
  "x32\0\24\0\0\0blurb=The Bar number\0   \10\0\0\0hints=rw\0   \16\0\0"
  "\0Auxdata::Aux64\0 \33\0\0\0default=1152921504606846976\0\13\0\0\0"
  "label=Aux64\0\34\0\0\0blurb=64bit auxillary number\0   \20\0\0\0Aux"
  "data::AuxBool\0   \11\0\0\0default=0\0  \15\0\0\0label=AuxBool\0  \17"
  "\0\0\0blurb=A Boolean\0\17\0\0\0Auxdata::AuxF64\0\15\0\0\0default"
  "=0.019\0  \14\0\0\0label=AuxF64\0   \22\0\0\0blurb=X coordinate\0 \10"
  "\0\0\0hints=ro\0   \17\0\0\0Auxdata::AuxStr\0\20\0\0\0default=aux"
  "test3\0   \14\0\0\0label=AuxStr\0   \27\0\0\0blurb=Specify text her"
  "e\0\34\0\0\0RapicornAidaTest::ButtonArea\0   \25\0\0\0InterfaceTest"
  "s::Child\0  \26\0\0\0InterfaceTests::Parent\0 &\0\0\0InterfaceTests"
  "::ChildInheritingSignals\0 \33\0\0\0RapicornAidaTest::ClickType\0\16"
  "\0\0\0CLICK_ON_PRESS\0 \20\0\0\0CLICK_ON_RELEASE\0   \21\0\0\0CLIC"
  "K_SLOW_REPEAT\0  \21\0\0\0CLICK_FAST_REPEAT\0  \20\0\0\0CLICK_KEY_R"
  "EPEAT\0   \23\0\0\0BseTest::Compressor\0\32\0\0\0InterfaceTests::De"
  "scendant\0 \31\0\0\0MandatoryNamespace::Enum1\0  \4\0\0\0E1_A\0   \32"
  "\0\0\0MandatoryNamespace::Enum1c\0 \5\0\0\0E1C_A\0  \31\0\0\0Mand"
  "atoryNamespace::Enum2\0  \4\0\0\0E2_A\0   \4\0\0\0E2_B\0   \32\0\0\0"
  "MandatoryNamespace::Enum2c\0 \5\0\0\0E2C_A\0  \5\0\0\0E2C_B\0  \31"
  "\0\0\0MandatoryNamespace::Enum3\0  \4\0\0\0E3_A\0   \4\0\0\0E3_B\0 "
  "  \4\0\0\0E3_C\0   \32\0\0\0MandatoryNamespace::Enum3c\0 \5\0\0\0E3"
  "C_A\0  \5\0\0\0E3C_B\0  \5\0\0\0E3C_C\0  \32\0\0\0MandatoryNamespac"
  "e::Enum4a\0 \5\0\0\0E4A_A\0  \5\0\0\0E4A_B\0  \5\0\0\0E4A_C\0  \5\0"
  "\0\0E4A_D\0  \32\0\0\0MandatoryNamespace::Enum4b\0 \5\0\0\0E4B_A\0 "
  " \5\0\0\0E4B_B\0  \5\0\0\0E4B_C\0  \5\0\0\0E4B_D\0  \32\0\0\0Mandat"
  "oryNamespace::Enum4c\0 \5\0\0\0E4C_A\0  \5\0\0\0E4C_B\0  \5\0\0\0E4"
  "C_C\0  \5\0\0\0E4C_D\0  \32\0\0\0MandatoryNamespace::Enum4d\0 \5\0\0"
  "\0E4D_A\0  \5\0\0\0E4D_B\0  \5\0\0\0E4D_C\0  \5\0\0\0E4D_D\0  )\0\0"
  "\0MandatoryNamespace::ExtensiveEnumSequence\0  \15\0\0\0enum_eleme"
  "nts\0  !\0\0\0MandatoryNamespace::FloatSequence\0  \14\0\0\0fractal"
  "value\0   \32\0\0\0InterfaceTests::GrandChild\0 &\0\0\0MandatoryNam"
  "espace::Inner::InnerRecord\0 \1\0\0\0x\0  \1\0\0\0y\0  \3\0\0\0rec\0"
  "\35\0\0\0MandatoryNamespace::NewRecord\0  \37\0\0\0MandatoryNamesp"
  "ace::IntSequence\0\4\0\0\0numx\0   %\0\0\0MandatoryNamespace::Inter"
  "faceSequence\0  !\0\0\0RapicornAidaTest::MathExpressions\0  \10\0\0"
  "\0RESULT_2\0   \10\0\0\0RESULT_5\0   \10\0\0\0RESULT_8\0   \10\0\0\0"
  "RESULT_6\0   \10\0\0\0RESULT_7\0   \11\0\0\0RESULT_16\0  \10\0\0\0"
  "RESULT_3\0   \11\0\0\0RESULT_24\0  \11\0\0\0RESULT_13\0  \11\0\0\0R"
  "ESULT_m2\0  \11\0\0\0RESULT_77\0  \12\0\0\0RESULT_511\0 #\0\0\0Inte"
  "rfaceTests::MethodTestInterface\0\20\0\0\0Other::NameTests\0   \"\0"
  "\0\0MandatoryNamespace::NestedTypesRec\0 \36\0\0\0MandatoryNamespac"
  "e::XFooRecord\0 \3\0\0\0seq\0 \0\0\0MandatoryNamespace::XFooSequenc"
  "e\0   \"\0\0\0MandatoryNamespace::NestedTypesSeq\0 \3\0\0\0ntr\0\1\0"
  "\0\0i\0  \5\0\0\0enum1\0  \3\0\0\0xfs\0\36\0\0\0InterfaceTests::Pr"
  "opertyTester\0 \35\0\0\0RapicornAidaTest::PureMethods\0  \31\0\0\0I"
  "nterfaceTests::QuickEnum\0  \4\0\0\0ZERO\0   \32\0\0\0InterfaceTest"
  "s::QuickIface\0 \33\0\0\0InterfaceTests::QuickRecord\0\4\0\0\0int1\0"
  "   \4\0\0\0int2\0   \35\0\0\0InterfaceTests::QuickSequence\0  \11\0"
  "\0\0somefloat\0  \30\0\0\0BseTest::RecordForGroups\0   \5\0\0\0rat"
  "io\0  \6\0\0\0label=\0 \6\0\0\0blurb=\0 \7\0\0\0hints=w\0\15\0\0\0o"
  "rdinary_bool\0  \12\0\0\0threshold1\0 \12\0\0\0threshold2\0 \"\0\0\0"
  "MandatoryNamespace::RecordSequence\0 \15\0\0\0repeatedfield\0  \37"
  "\0\0\0MandatoryNamespace::Refer2Inner\0\1\0\0\0r\0  $\0\0\0Mandator"
  "yNamespace::SequenceSequence\0   \10\0\0\0moreints\0   \32\0\0\0Oth"
  "erNamespace::SomeRecord\0 \2\0\0\0r1\0 \2\0\0\0r2\0 \2\0\0\0r3\0 \2"
  "\0\0\0r4\0 \24\0\0\0BseTest::SoundModule\0   \"\0\0\0MandatoryNames"
  "pace::StringSequence\0 \5\0\0\0blurb\0  \34\0\0\0InterfaceTests::UI"
  "WidgetArea\0   \0\0\0\0";

static Rapicorn::Init __aida_autoinit_type_map__ ([]() {
  Rapicorn::Aida::TypeMap::enlist_map (__aida_type_map__);
});
} // Anon



// IDL error test file					 	-*-mode:c++;-*-
// this file is processed line by line, no statement may span multiple lines
// each line is asserted to produce an error

Const a = 5; Const a = 6; // redefining existing identifier

Const record = 5; // keyword assignment

typedef String String; // keyword redefinition (without --system-typedefs)

namespace broken$name { Const a = 5; } // invalid namespace name (without --system-typedefs)

enum E { VALUE }; Const E = 0; // typename assignment

enum E { VALUE }; Const VALUE = 0; // enum value assignment

Const TRUE = 17; // invalid constant name

Const tmp = "invalid" _("i18n string") "concatenation";

FrobCheck tmp = 1; // FrobCheck is no type

Const zzz = 1; zzz tmp = 1; // zzz is no type

record DupRecord { int32 a, b, c; }; // fail on multiple fields per type

record DupRecord { int32 b; int32 b; }; // duplicate: b

record EmptyRecord { }; // record is empty

enum ExtensiveEnum { record, }; // keyword as enum value

enum ExtensiveEnum { Foo; }; // semicolon in enum

enum ExtensiveEnum { EV1, EV2, EV1 }; // duplicate enum value

enum Enu1 { AA }; enum Enu2 { AA }; // duplicate enum value

enum Enu1 { AA }; enum Enu1 { BB }; // duplicate enum name

Const Var = 0; enum ExtensiveEnum { Var }; // constant in enum

sequence EmptySequence { }; // sequence needs 1 field

sequence MultiFieldSequence { bool one; int32 toomany; }; // sequence needs 1 field

sequence Seq { enum b; }; // keyword is not typename

sequence S1 { bool b; }; sequence S2 { _S1 s; }; // need existing typenames

sequence Dup { bool b; }; sequence Dup { bool b; }; // duplicate definition

typedef Const X; // unknown type Const

typedef bool Const; // keyword redefinition

Const class = 5; // keyword redefinition

enum Enu1 { AA }; typedef Enu1 Enu1; // type redefinition

typedef int32 x = _No_SUCH_initializer (17); // unknown type definition

typedef int32 x = Num ("too", "many", "args", 1, 2, 3, 4, 5, 6, 7, 8, 9); // too many args

typedef int32 string_for_num = String ("nick", "txt", "dflt", "rw"); // type/initializer mismatch

record R { String s = Num ("x", "X coord", 0, 0, 100.0, +.5, "ro"); }; // type/initializer mismatch

interface I { int32 method (,); }; // invalid method arg separator
interface I { int32 method (); int32 method (); }; // multiple method definitions
interface I { int32 xxx; int32 xxx (); }; // multiple member definitions
interface I { int32 method (int32 n, int32 n); }; // duplicate method argument
interface I : Unknown {}; // invalid parent interface
record R { String s; }; interface I : R {}; // invalid interface inheritance
interface I { signal int32 xxx; }; // invalidly declared as signal
Const void = 17; // invalid constant name
void xy = 17; // invalid property type
interface I { int32 method (void); }; // invalid argument type
interface I { int32 method (int32 n, void v); }; // invalid argument type

include "include-f1.idl"; // test include error messages

namespace B { enum E { E1 }; } namespace B { enum E { E1 }; } // namespaced type redefinition

namespace A { namespace B { enum E { E1 }; } namespace B { enum E { E1 }; } } // namespaced type redefinition

interface I { int32 method (I self); }; // invalid method arg name

interface I { int32 self; }; // invalid property name
interface I { int32 method (int32 a, int32 b = 2, int32 c); }; // missing subsequent default initializer
interface I { signal int32 m() = 0; }; // invalid pure decl for non-method

interface P { void void_prop; }; // invalid property type

interface I; interface I {}; interface I; interface I {}; // interface redefinition

enum Empty { }; // invalid empty enumeration

namespace U { using namespace Unknown; } // not a namespace-name

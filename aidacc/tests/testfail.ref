.../testfail.idl:5:26: TypeError: redefining existing identifier: a
>  Const a = 5; Const a = 6; // redefining existing identifier
>                           ^
.../testfail.idl:7:18: TypeError: redefining existing identifier: record
>  Const record = 5; // keyword assignment
>                   ^
.../testfail.idl:9:23: TypeError: redefining existing identifier: String
>  typedef String String; // keyword redefinition (without --system-typedefs)
>                        ^
.../testfail.idl:11:22: NameError: invalid characters in namespace: broken$name
>  namespace broken$name { Const a = 5; } // invalid namespace name (without --system-typedefs)
>                       ^
.../testfail.idl:13:31: TypeError: redefining existing identifier: E
>  enum E { VALUE }; Const E = 0; // typename assignment
>                                ^
.../testfail.idl:15:35: TypeError: redefining existing identifier: VALUE
>  enum E { VALUE }; Const VALUE = 0; // enum value assignment
>                                    ^
.../testfail.idl:17:17: TypeError: redefining existing identifier: TRUE
>  Const TRUE = 17; // invalid constant name
>                  ^
.../testfail.idl:19:24: Trying to find ';': STRING, IDENT, '\)', '_', '\*\*', '\*', '/', '%', '\+', '-', '<<', '>>', '&', '\^', '\|', ';', ',', '}', got '_'
>  Const tmp = "invalid" _("i18n string") "concatenation";
>                         ^
.../testfail.idl:21:1: Trying to find one of ...
>  FrobCheck tmp = 1; // FrobCheck is no type
>  ^
.../testfail.idl:23:16: Trying to find one of ...
>  Const zzz = 1; zzz tmp = 1; // zzz is no type
>                 ^
.../testfail.idl:25:27: Trying to find one of ...
>  record DupRecord { int32 a, b, c; }; // fail on multiple fields per type
>                            ^
.../testfail.idl:27:40: NameError: duplicate field name: b
>  record DupRecord { int32 b; int32 b; }; // duplicate: b
>                                         ^
.../testfail.idl:29:22: Trying to find one of ...
>  record EmptyRecord { }; // record is empty
>                       ^
.../testfail.idl:31:28: TypeError: redefining existing identifier: record
>  enum ExtensiveEnum { record, }; // keyword as enum value
>                             ^
.../testfail.idl:33:25: Trying to find one of ...
>  enum ExtensiveEnum { Foo; }; // semicolon in enum
>                          ^
.../testfail.idl:35:35: TypeError: redefining existing identifier: EV1
>  enum ExtensiveEnum { EV1, EV2, EV1 }; // duplicate enum value
>                                    ^
.../testfail.idl:37:33: TypeError: redefining existing identifier: AA
>  enum Enu1 { AA }; enum Enu2 { AA }; // duplicate enum value
>                                  ^
.../testfail.idl:39:35: TypeError: redefining existing identifier: Enu1
>  enum Enu1 { AA }; enum Enu1 { BB }; // duplicate enum name
>                                    ^
.../testfail.idl:41:40: TypeError: redefining existing identifier: Var
>  Const Var = 0; enum ExtensiveEnum { Var }; // constant in enum
>                                         ^
.../testfail.idl:43:26: Trying to find one of ...
>  sequence EmptySequence { }; // sequence needs 1 field
>                           ^
.../testfail.idl:45:41: Trying to find one of ...
>  sequence MultiFieldSequence { bool one; int32 toomany; }; // sequence needs 1 field
>                                          ^
.../testfail.idl:47:22: TypeError: unknown type: 'enum'
>  sequence Seq { enum b; }; // keyword is not typename
>                       ^
.../testfail.idl:49:45: TypeError: unknown type: '_S1'
>  sequence S1 { bool b; }; sequence S2 { _S1 s; }; // need existing typenames
>                                              ^
.../testfail.idl:51:52: TypeError: redefining existing identifier: Dup
>  sequence Dup { bool b; }; sequence Dup { bool b; }; // duplicate definition
>                                                     ^
.../testfail.idl:53:16: TypeError: unknown type: 'Const'
>  typedef Const X; // unknown type Const
>                 ^
.../testfail.idl:55:20: TypeError: redefining existing identifier: Const
>  typedef bool Const; // keyword redefinition
>                     ^
.../testfail.idl:57:17: TypeError: redefining existing identifier: class
>  Const class = 5; // keyword redefinition
>                  ^
.../testfail.idl:59:37: TypeError: redefining existing identifier: Enu1
>  enum Enu1 { AA }; typedef Enu1 Enu1; // type redefinition
>                                      ^
.../testfail.idl:61:45: TypeError: invalid type definition: = _No_SUCH_initializer (17,)
>  typedef int32 x = _No_SUCH_initializer (17); // unknown type definition
>                                              ^
.../testfail.idl:63:74: TypeError: too many args for type definition: = Num ('"too"', '"many"', '"args"', 1, 2, 3, 4, 5, 6, 7, 8, 9)
>  ... Num ("too", "many", "args", 1, 2, 3, 4, 5, 6, 7, 8, 9); // too many args
>                                                             ^
.../testfail.idl:65:69: TypeError: invalid type definition: = String ('"nick"', '"txt"', '"dflt"', '"rw"')
>  ...ing_for_num = String ("nick", "txt", "dflt", "rw"); // type/initializer mismatch
>                                                        ^
.../testfail.idl:67:71: TypeError: invalid type definition: = Num ('"x"', '"X coord"', 0, 0, 100.0, 0.5, '"ro"')
>  ... s = Num ("x", "X coord", 0, 0, 100.0, +.5, "ro"); }; // type/initializer mismatch
>                                                          ^
.../testfail.idl:69:29: Trying to find one of ...
>  interface I { int32 method (,); }; // invalid method arg separator
>                              ^
.../testfail.idl:70:51: NameError: duplicate member name: method
>  interface I { int32 method (); int32 method (); }; // multiple method definitions
>                                                    ^
.../testfail.idl:71:42: NameError: duplicate member name: xxx
>  interface I { int32 xxx; int32 xxx (); }; // multiple member definitions
>                                           ^
.../testfail.idl:72:50: NameError: duplicate method arg name: method (...n...)
>  interface I { int32 method (int32 n, int32 n); }; // duplicate method argument
>                                                   ^
.../testfail.idl:73:22: TypeError: no such interface type: Unknown
>  interface I : Unknown {}; // invalid parent interface
>                       ^
.../testfail.idl:74:40: TypeError: no such interface type: R
>  record R { String s; }; interface I : R {}; // invalid interface inheritance
>                                         ^
.../testfail.idl:75:32: TypeError: non-method invalidly declared as 'signal': xxx
>  interface I { signal int32 xxx; }; // invalidly declared as signal
>                                 ^
.../testfail.idl:76:17: TypeError: redefining existing identifier: void
>  Const void = 17; // invalid constant name
>                  ^
.../testfail.idl:77:1: Trying to find one of ...
>  void xy = 17; // invalid property type
>  ^
.../testfail.idl:78:33: Trying to find one of ...
>  interface I { int32 method (void); }; // invalid argument type
>                                  ^
.../testfail.idl:79:44: TypeError: unknown type: 'void'
>  interface I { int32 method (int32 n, void v); }; // invalid argument type
>                                             ^
.../include-f2.idl:2:3: Trying to find one of ...
>    unexisting_var var;
>    ^
.../include-f1.idl:1: note: included "include-f2.idl" from here
.../testfail.idl:81: note: included "include-f1.idl" from here
.../testfail.idl:83:57: TypeError: redefining existing identifier: E1
>  namespace B { enum E { E1 }; } namespace B { enum E { E1 }; } // namespaced type redefinition
>                                                          ^
.../testfail.idl:85:71: TypeError: redefining existing identifier: E1
>  ...espace B { enum E { E1 }; } namespace B { enum E { E1 }; } } // namespaced type redefinition
>                                                          ^
.../testfail.idl:87:40: NameError: invalid method arg name: method (...self...)
>  interface I { int32 method (I self); }; // invalid method arg name
>                                         ^
.../testfail.idl:89:29: NameError: invalid property name: self
>  interface I { int32 self; }; // invalid property name
>                              ^
.../testfail.idl:90:63: AttributeError: missing subsequent default initializer: method (...c...)
>  ...I { int32 method (int32 a, int32 b = 2, int32 c); }; // missing subsequent default initializer
>                                                         ^
.../testfail.idl:91:35: TypeError: non-method invalidly declared as pure: m
>  interface I { signal int32 m() = 0; }; // invalid pure decl for non-method
>                                    ^
.../testfail.idl:93:30: TypeError: unknown type: 'void'
>  interface P { void void_prop; }; // invalid property type
>                               ^
.../testfail.idl:95:56: TypeError: redefining existing identifier: I
>  interface I; interface I {}; interface I; interface I {}; // interface redefinition
>                                                         ^
.../testfail.idl:97:15: AttributeError: invalid empty enumeration: Empty
>  enum Empty { }; // invalid empty enumeration
>                ^
.../testfail.idl:99:39: NameError: not a namespace-name: Unknown
>  namespace U { using namespace Unknown; } // not a namespace-name
>                                        ^

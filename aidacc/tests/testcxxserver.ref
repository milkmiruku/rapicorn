// --- Generated by AidaCxxStub ---

// --- ServerHH Boilerplate ---
#include <rapicorn-core.hh>

namespace Rapicorn { namespace Aida {
class TestServerBase : public virtual PropertyHostInterface {
public:
  explicit             TestServerBase ()            {}
  virtual             ~TestServerBase ()            {}
  virtual uint64_t     _rpc_id        () const      { return uint64_t (this); }
};
} } // Rapicorn::Aida

#include <rapicorn-core.hh> // for rcore/signal.hh
using Rapicorn::Signals::slot;

#ifndef AIDA_CONNECTION
#define AIDA_CONNECTION()       (*(Rapicorn::Aida::ServerConnection*)NULL)
#endif // !AIDA_CONNECTION


// --- ClientCC/ServerCC Boilerplate ---
#include <string>
#include <vector>
#include <stdexcept>
#ifndef __AIDA_GENERIC_CC_BOILERPLATE__
#define __AIDA_GENERIC_CC_BOILERPLATE__

#define AIDA_CHECK(cond,errmsg) do { if (cond) break; throw std::runtime_error (std::string ("AIDA-ERROR: ") + errmsg); } while (0)

namespace { // Anon
using Rapicorn::Aida::uint64_t;

namespace __AIDA_Local__ {
using namespace Rapicorn::Aida;
static __attribute__ ((__format__ (__printf__, 1, 2), unused)) FieldBuffer*
error (const char *format, ...)
{
  va_list args;
  va_start (args, format);
  error_vprintf (format, args);
  va_end (args);
  return NULL;
}
} } // Anon::__AIDA_Local__
#endif // __AIDA_GENERIC_CC_BOILERPLATE__


namespace { // Anon
namespace __AIDA_Local__ {
  inline ptrdiff_t                obj2id (Rapicorn::Aida::TestServerBase *obj) { return reinterpret_cast<ptrdiff_t> (obj); }
  template<class Object> Object*  id2obj (ptrdiff_t oid) { return dynamic_cast<Object*> (reinterpret_cast<Rapicorn::Aida::TestServerBase*> (oid)); }
} } // Anon::__AIDA_Local__


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

enum Enum1 {
  E1_A = 1,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum1  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum1 &e) { e = Enum1 (frr.pop_evalue()); }

enum Enum1c {
  E1C_A = 1,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum1c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum1c &e) { e = Enum1c (frr.pop_evalue()); }

enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum2  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum2 &e) { e = Enum2 (frr.pop_evalue()); }

enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum2c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum2c &e) { e = Enum2c (frr.pop_evalue()); }

enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum3  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum3 &e) { e = Enum3 (frr.pop_evalue()); }

enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum3c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum3c &e) { e = Enum3c (frr.pop_evalue()); }

enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4a  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4a &e) { e = Enum4a (frr.pop_evalue()); }

enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4b  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4b &e) { e = Enum4b (frr.pop_evalue()); }

enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4c &e) { e = Enum4c (frr.pop_evalue()); }

enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4d  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4d &e) { e = Enum4d (frr.pop_evalue()); }

enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  ExtensiveEnum  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, ExtensiveEnum &e) { e = ExtensiveEnum (frr.pop_evalue()); }

/** @interface FirstInterface
 * See also the corresponding C++ class I_FirstInterface_Interface (server side). */
/// See also the corresponding IDL class FirstInterface.
class I_FirstInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_FirstInterface_Interface ();
  virtual /*Des*/                       ~I_FirstInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          void_func                  ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_FirstInterface_Interface*&);

/** @interface XFooRecord
 * See also the corresponding C++ class XFooRecordImpl (server side). */
/// See also the corresponding IDL class XFooRecord.
struct XFooRecordImpl
{
  bool                          single_bool;
  int                           single_num;
  Rapicorn::Aida::int64_t       num64;
  double                        single_float;
  std::string                   single_string;
  int                           sibling1;
  int                           sibling2;
  int                           multi1;
  int                           multi2;
  int                           multi3;
  int                           multi4;
  ExtensiveEnum                 enum_field;
  I_FirstInterface_Interface*   iface1;
  I_FirstInterface_Interface*   iface2;
  I_FirstInterface_Interface*   iface3;
  Rapicorn::Aida::Any           any1;
  Rapicorn::Aida::Any           any2;
  Rapicorn::Aida::Any           any3;
  inline                        XFooRecordImpl () { single_bool = 0; single_num = 0; num64 = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const XFooRecordImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, XFooRecordImpl&);

/** @interface XFooSequence
 * See also the corresponding C++ class XFooSequenceImpl (server side). */
/// See also the corresponding IDL class XFooSequence.
struct XFooSequenceImpl : public std::vector<bool>
{
  typedef std::vector<bool> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const XFooSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, XFooSequenceImpl&);

/** @interface IntSequence
 * See also the corresponding C++ class IntSequenceImpl (server side). */
/// See also the corresponding IDL class IntSequence.
struct IntSequenceImpl : public std::vector<int>
{
  typedef std::vector<int> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const IntSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, IntSequenceImpl&);

/** @interface FloatSequence
 * See also the corresponding C++ class FloatSequenceImpl (server side). */
/// See also the corresponding IDL class FloatSequence.
struct FloatSequenceImpl : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const FloatSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, FloatSequenceImpl&);

/** @interface StringSequence
 * See also the corresponding C++ class StringSequenceImpl (server side). */
/// See also the corresponding IDL class StringSequence.
struct StringSequenceImpl : public std::vector<std::string>
{
  typedef std::vector<std::string> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const StringSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, StringSequenceImpl&);

/** @interface ExtensiveEnumSequence
 * See also the corresponding C++ class ExtensiveEnumSequenceImpl (server side). */
/// See also the corresponding IDL class ExtensiveEnumSequence.
struct ExtensiveEnumSequenceImpl : public std::vector<ExtensiveEnum>
{
  typedef std::vector<ExtensiveEnum> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const ExtensiveEnumSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, ExtensiveEnumSequenceImpl&);

/** @interface RecordSequence
 * See also the corresponding C++ class RecordSequenceImpl (server side). */
/// See also the corresponding IDL class RecordSequence.
struct RecordSequenceImpl : public std::vector<XFooRecordImpl>
{
  typedef std::vector<XFooRecordImpl> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const RecordSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, RecordSequenceImpl&);

/** @interface SequenceSequence
 * See also the corresponding C++ class SequenceSequenceImpl (server side). */
/// See also the corresponding IDL class SequenceSequence.
struct SequenceSequenceImpl : public std::vector<IntSequenceImpl>
{
  typedef std::vector<IntSequenceImpl> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SequenceSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, SequenceSequenceImpl&);

/** @interface InterfaceSequence
 * See also the corresponding C++ class InterfaceSequenceImpl (server side). */
/// See also the corresponding IDL class InterfaceSequence.
struct InterfaceSequenceImpl : public std::vector<I_FirstInterface_Interface*>
{
  typedef std::vector<I_FirstInterface_Interface*> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const InterfaceSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, InterfaceSequenceImpl&);

/** @interface AnySequence
 * See also the corresponding C++ class AnySequenceImpl (server side). */
/// See also the corresponding IDL class AnySequence.
struct AnySequenceImpl : public std::vector<Rapicorn::Aida::Any>
{
  typedef std::vector<Rapicorn::Aida::Any> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const AnySequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, AnySequenceImpl&);

/** @interface NestedTypesRec
 * See also the corresponding C++ class NestedTypesRecImpl (server side). */
/// See also the corresponding IDL class NestedTypesRec.
struct NestedTypesRecImpl
{
  XFooRecordImpl                rec;
  XFooSequenceImpl              seq;
  inline                        NestedTypesRecImpl () { }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NestedTypesRecImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, NestedTypesRecImpl&);

/** @interface NestedTypesSeq
 * See also the corresponding C++ class NestedTypesSeqImpl (server side). */
/// See also the corresponding IDL class NestedTypesSeq.
struct NestedTypesSeqImpl : public std::vector<NestedTypesRecImpl>
{
  typedef std::vector<NestedTypesRecImpl> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NestedTypesSeqImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, NestedTypesSeqImpl&);

typedef Rapicorn::Aida::Any AliasAny;

typedef bool AliasBool;

typedef int AliasInt32;

typedef Rapicorn::Aida::int64_t AliasInt64;

typedef double AliasFloat;

typedef std::string AliasString;

typedef XFooRecordImpl AliasRecord;

typedef XFooSequenceImpl AliasSequence;

typedef ExtensiveEnum AliasEnum;

/** @interface NewRecord
 * See also the corresponding C++ class NewRecordImpl (server side). */
/// See also the corresponding IDL class NewRecord.
struct NewRecordImpl
{
  int                           i;
  Enum1                         enum1;
  XFooSequenceImpl              xfs;
  NestedTypesRecImpl            ntr;
  inline                        NewRecordImpl () { i = 0; enum1 = Enum1 (0); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const NewRecordImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, NewRecordImpl&);

namespace Inner {

/** @interface InnerRecord
 * See also the corresponding C++ class InnerRecordImpl (server side). */
/// See also the corresponding IDL class InnerRecord.
struct InnerRecordImpl
{
  int                           x;
  int                           y;
  NewRecordImpl                 rec;
  inline                        InnerRecordImpl () { x = 0; y = 0; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const InnerRecordImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, InnerRecordImpl&);
} // Inner

/** @interface Refer2Inner
 * See also the corresponding C++ class Refer2InnerImpl (server side). */
/// See also the corresponding IDL class Refer2Inner.
struct Refer2InnerImpl
{
  Inner::InnerRecordImpl        r;
  inline                        Refer2InnerImpl () { }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const Refer2InnerImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, Refer2InnerImpl&);
} // MandatoryNamespace

namespace OtherNamespace {

/** @interface SomeRecord
 * See also the corresponding C++ class SomeRecordImpl (server side). */
/// See also the corresponding IDL class SomeRecord.
struct SomeRecordImpl
{
  MandatoryNamespace::NewRecordImpl r1;
  MandatoryNamespace::NewRecordImpl r2;
  MandatoryNamespace::Inner::InnerRecordImpl r3;
  MandatoryNamespace::Inner::InnerRecordImpl r4;
  inline                        SomeRecordImpl () { }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SomeRecordImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, SomeRecordImpl&);
} // OtherNamespace

namespace Auxdata {

typedef bool AuxBool;

typedef int Aux32;

typedef Rapicorn::Aida::int64_t Aux64;

typedef double AuxF64;

typedef std::string AuxStr;
} // Auxdata

namespace InterfaceTests {

/** @interface UIWidgetArea
 * See also the corresponding C++ class I_UIWidgetArea_Interface (server side). */
/// See also the corresponding IDL class UIWidgetArea.
class I_UIWidgetArea_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_UIWidgetArea_Interface ();
  virtual /*Des*/                       ~I_UIWidgetArea_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual bool                          dummy    () const = 0;
  virtual void                          dummy    (bool) = 0;
  virtual std::string                   on_click () const = 0;
  virtual void                          on_click (const std::string&) = 0;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, double (I_UIWidgetArea_Interface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double                        simple_method            ();
  virtual double                        single_arg               (int n);
  virtual double                        single_arg2              (int n = 5);
  virtual double                        two_args                 (int n,
                                                                  double r);
  virtual double                        two_args2                (int n = 6,
                                                                  double r = 7.7);
  virtual double                        multi_args               (bool b,
                                                                  Rapicorn::Aida::int64_t n,
                                                                  double r,
                                                                  int i,
                                                                  const std::string &s = "String ding",
                                                                  double y = 5);
  virtual double                        self_method              (I_UIWidgetArea_Interface &ba1,
                                                                  I_UIWidgetArea_Interface &ba2);
  virtual void                          void_method              ();
  virtual std::string                   on_click2out             ();
  virtual void                          on_click2in              (const std::string &command);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetArea_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetArea_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_UIWidgetArea_Interface*&);

/** @interface Parent
 * See also the corresponding C++ class I_Parent_Interface (server side). */
/// See also the corresponding IDL class Parent.
class I_Parent_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_Parent_Interface ();
  virtual /*Des*/                       ~I_Parent_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Parent_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Parent_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Parent_Interface*&);

/** @interface Child
 * See also the corresponding C++ class I_Child_Interface (server side). */
/// See also the corresponding IDL class Child.
class I_Child_Interface : public virtual I_Parent_Interface
{
protected:
  explicit                               I_Child_Interface ();
  virtual /*Des*/                       ~I_Child_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Child_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Child_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Child_Interface*&);

/** @interface Descendant
 * See also the corresponding C++ class I_Descendant_Interface (server side). */
/// See also the corresponding IDL class Descendant.
class I_Descendant_Interface : public virtual I_Child_Interface
{
protected:
  explicit                               I_Descendant_Interface ();
  virtual /*Des*/                       ~I_Descendant_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Descendant_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Descendant_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Descendant_Interface*&);

/** @interface GrandChild
 * See also the corresponding C++ class I_GrandChild_Interface (server side). */
/// See also the corresponding IDL class GrandChild.
class I_GrandChild_Interface : public virtual I_Descendant_Interface
{
protected:
  explicit                               I_GrandChild_Interface ();
  virtual /*Des*/                       ~I_GrandChild_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChild_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChild_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_GrandChild_Interface*&);

enum QuickEnum {
  ZERO = 0,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  QuickEnum  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, QuickEnum &e) { e = QuickEnum (frr.pop_evalue()); }

/** @interface QuickRecord
 * See also the corresponding C++ class QuickRecordImpl (server side). */
/// See also the corresponding IDL class QuickRecord.
struct QuickRecordImpl
{
  int                           int1;
  int                           int2;
  inline                        QuickRecordImpl () { int1 = 0; int2 = 0; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const QuickRecordImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, QuickRecordImpl&);

/** @interface QuickSequence
 * See also the corresponding C++ class QuickSequenceImpl (server side). */
/// See also the corresponding IDL class QuickSequence.
struct QuickSequenceImpl : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const QuickSequenceImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, QuickSequenceImpl&);

/** @interface QuickIface
 * See also the corresponding C++ class I_QuickIface_Interface (server side). */
/// See also the corresponding IDL class QuickIface.
class I_QuickIface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_QuickIface_Interface ();
  virtual /*Des*/                       ~I_QuickIface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          simple_function        (int i = 9);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_QuickIface_Interface*&);

/** @interface MethodTestInterface
 * See also the corresponding C++ class I_MethodTestInterface_Interface (server side). */
/// See also the corresponding IDL class MethodTestInterface.
class I_MethodTestInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_MethodTestInterface_Interface ();
  virtual /*Des*/                       ~I_MethodTestInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          method_with_void                ();
  virtual bool                          method_with_bools               (bool input,
                                                                         bool optval = 0);
  virtual int                           method_with_ints32              (int input,
                                                                         int optval = -2);
  virtual Rapicorn::Aida::int64_t       method_with_ints64              (Rapicorn::Aida::int64_t input,
                                                                         Rapicorn::Aida::int64_t optval = 576460752303423488);
  virtual double                        method_with_floats              (double input,
                                                                         double optval = 309.9);
  virtual std::string                   method_with_string              (const std::string &input,
                                                                         const std::string &optval = "default");
  virtual QuickEnum                     method_with_enum                (QuickEnum input,
                                                                         QuickEnum optval = QuickEnum (0));
  virtual QuickRecordImpl               method_with_record              (const QuickRecordImpl &input,
                                                                         const QuickRecordImpl &optval = QuickRecordImpl());
  virtual QuickSequenceImpl             method_with_sequence            (const QuickSequenceImpl &input,
                                                                         const QuickSequenceImpl &optval = QuickSequenceImpl());
  virtual I_GrandChild_Interface*       method_with_interface           (I_GrandChild_Interface &input,
                                                                         I_GrandChild_Interface &optval = *(I_GrandChild_Interface*) NULL);
  virtual Rapicorn::Aida::Any           method_with_anys                (const Rapicorn::Aida::Any &input,
                                                                         const Rapicorn::Aida::Any &optval);
  virtual I_QuickIface_Interface*       method_with_quickiface          (I_QuickIface_Interface &input,
                                                                         I_QuickIface_Interface &iface0 = *(I_QuickIface_Interface*) NULL);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_MethodTestInterface_Interface*&);

/** @interface SignalTestInterface
 * See also the corresponding C++ class I_SignalTestInterface_Interface (server side). */
/// See also the corresponding IDL class SignalTestInterface.
class I_SignalTestInterface_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_SignalTestInterface_Interface ();
  virtual /*Des*/                       ~I_SignalTestInterface_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, bool ()> Signal_bool_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, int ()> Signal_int32_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, Rapicorn::Aida::int64_t ()> Signal_int64_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, double ()> Signal_float64_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, std::string ()> Signal_string_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickRecordImpl ()> Signal_record_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickSequenceImpl ()> Signal_sequence_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_GrandChild_Interface* ()> Signal_interface_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, Rapicorn::Aida::Any ()> Signal_any_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_SignalTestInterface_Interface* ()> Signal_self_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (int i)> Signal_int32_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (Rapicorn::Aida::int64_t i)> Signal_int64_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (double f)> Signal_float64_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickRecordImpl &r)> Signal_record_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickSequenceImpl &s)> Signal_sequence_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_GrandChild_Interface &i)> Signal_interface_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const Rapicorn::Aida::Any &a)> Signal_any_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_SignalTestInterface_Interface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int32_result sig_int32_result;
  Signal_int64_result sig_int64_result;
  Signal_float64_result sig_float64_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_any_result sig_any_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int32_arg sig_int32_arg;
  Signal_int64_arg sig_int64_arg;
  Signal_float64_arg sig_float64_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_any_arg sig_any_arg;
  Signal_self_args sig_self_args;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterface_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterface_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SignalTestInterface_Interface*&);

/** @interface ChildInheritingSignals
 * See also the corresponding C++ class I_ChildInheritingSignals_Interface (server side). */
/// See also the corresponding IDL class ChildInheritingSignals.
class I_ChildInheritingSignals_Interface : public virtual I_SignalTestInterface_Interface
{
protected:
  explicit                               I_ChildInheritingSignals_Interface ();
  virtual /*Des*/                       ~I_ChildInheritingSignals_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  typedef Rapicorn::Signals::Signal<I_ChildInheritingSignals_Interface, void (I_ChildInheritingSignals_Interface &c, I_SignalTestInterface_Interface &p, const Rapicorn::Aida::Any &a, int i, const QuickRecordImpl &r, const QuickSequenceImpl &s)> Signal_child_signal;
  Signal_child_signal sig_child_signal;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignals_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignals_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildInheritingSignals_Interface*&);

/** @interface AnotherChild
 * See also the corresponding C++ class I_AnotherChild_Interface (server side). */
/// See also the corresponding IDL class AnotherChild.
class I_AnotherChild_Interface : public virtual I_SignalTestInterface_Interface
{
protected:
  explicit                               I_AnotherChild_Interface ();
  virtual /*Des*/                       ~I_AnotherChild_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChild_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChild_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_AnotherChild_Interface*&);

/** @interface PropertyTester
 * See also the corresponding C++ class I_PropertyTester_Interface (server side). */
/// See also the corresponding IDL class PropertyTester.
class I_PropertyTester_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_PropertyTester_Interface ();
  virtual /*Des*/                       ~I_PropertyTester_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual bool                          bool_prop      () const = 0;
  virtual void                          bool_prop      (bool) = 0;
  virtual int                           int32_prop     () const = 0;
  virtual void                          int32_prop     (int) = 0;
  virtual Rapicorn::Aida::int64_t       int64_prop     () const = 0;
  virtual void                          int64_prop     (Rapicorn::Aida::int64_t) = 0;
  virtual double                        float64_prop   () const = 0;
  virtual void                          float64_prop   (double) = 0;
  virtual std::string                   string_prop    () const = 0;
  virtual void                          string_prop    (const std::string&) = 0;
  virtual QuickEnum                     enum_prop      () const = 0;
  virtual void                          enum_prop      (QuickEnum) = 0;
  virtual QuickRecordImpl               record_prop    () const = 0;
  virtual void                          record_prop    (const QuickRecordImpl&) = 0;
  virtual QuickSequenceImpl             sequence_prop  () const = 0;
  virtual void                          sequence_prop  (const QuickSequenceImpl&) = 0;
  virtual I_GrandChild_Interface*       interface_prop () const = 0;
  virtual void                          interface_prop (I_GrandChild_Interface*) = 0;
  virtual I_PropertyTester_Interface*   self_prop      () const = 0;
  virtual void                          self_prop      (I_PropertyTester_Interface*) = 0;
  virtual Rapicorn::Aida::Any           any_prop       () const = 0;
  virtual void                          any_prop       (const Rapicorn::Aida::Any&) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTester_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTester_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PropertyTester_Interface*&);
} // InterfaceTests

namespace RapicornAidaTest {

enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  ClickType  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, ClickType &e) { e = ClickType (frr.pop_evalue()); }

/** @interface ButtonArea
 * See also the corresponding C++ class I_ButtonArea_Interface (server side). */
/// See also the corresponding IDL class ButtonArea.
class I_ButtonArea_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_ButtonArea_Interface ();
  virtual /*Des*/                       ~I_ButtonArea_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual std::string                   on_click   () const = 0;
  virtual void                          on_click   (const std::string&) = 0;
  virtual std::string                   on_click2  () const = 0;
  virtual void                          on_click2  (const std::string&) = 0;
  virtual std::string                   on_click3  () const = 0;
  virtual void                          on_click3  (const std::string&) = 0;
  virtual ClickType                     click_type () const = 0;
  virtual void                          click_type (ClickType) = 0;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, bool (), Rapicorn::Signals::CollectorUntil0<bool> > Signal_check_activate;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonArea_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonArea_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ButtonArea_Interface*&);

class I_PureMethods_Interface;

/** @interface PureMethods
 * See also the corresponding C++ class I_PureMethods_Interface (server side). */
/// See also the corresponding IDL class PureMethods.
class I_PureMethods_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_PureMethods_Interface ();
  virtual /*Des*/                       ~I_PureMethods_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual int                           pure_method             (double f) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethods_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethods_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PureMethods_Interface*&);

enum MathExpressions {
  RESULT_2 = 2,
  RESULT_5 = 5,
  RESULT_8 = 8,
  RESULT_6 = 6,
  RESULT_7 = 7,
  RESULT_16 = 16,
  RESULT_3 = 3,
  RESULT_24 = 24,
  RESULT_13 = 13,
  RESULT_m2 = -2,
  RESULT_77 = 77,
  RESULT_511 = 511,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  MathExpressions  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, MathExpressions &e) { e = MathExpressions (frr.pop_evalue()); }
} // RapicornAidaTest

namespace Other {

/** @interface NameTests
 * See also the corresponding C++ class I_NameTests_Interface (server side). */
/// See also the corresponding IDL class NameTests.
class I_NameTests_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_NameTests_Interface ();
  virtual /*Des*/                       ~I_NameTests_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual void                          args_from_other_namespace (const InterfaceTests::QuickRecordImpl &qr,
                                                                   RapicornAidaTest::ClickType qe,
                                                                   const OtherNamespace::SomeRecordImpl &sr);
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_NameTests_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_NameTests_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_NameTests_Interface*&);
} // Other

namespace BseTest {

/** @interface Compressor
 * See also the corresponding C++ class I_Compressor_Interface (server side). */
/// See also the corresponding IDL class Compressor.
class I_Compressor_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_Compressor_Interface ();
  virtual /*Des*/                       ~I_Compressor_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
  virtual double                        threshold () const = 0;
  virtual void                          threshold (double) = 0;
  virtual double                        ratio     () const = 0;
  virtual void                          ratio     (double) = 0;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Compressor_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_Compressor_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_Compressor_Interface*&);

/** @interface RecordForGroups
 * See also the corresponding C++ class RecordForGroupsImpl (server side). */
/// See also the corresponding IDL class RecordForGroups.
struct RecordForGroupsImpl
{
  int                           i;
  double                        ratio;
  bool                          ordinary_bool;
  double                        threshold1;
  double                        threshold2;
  inline                        RecordForGroupsImpl () { i = 0; ratio = 0; ordinary_bool = 0; threshold1 = 0; threshold2 = 0; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const RecordForGroupsImpl&);
void operator>>= (Rapicorn::Aida::FieldReader&, RecordForGroupsImpl&);

/** @interface SoundModule
 * See also the corresponding C++ class I_SoundModule_Interface (server side). */
/// See also the corresponding IDL class SoundModule.
class I_SoundModule_Interface : public virtual Rapicorn::Aida::TestServerBase
{
protected:
  explicit                               I_SoundModule_Interface ();
  virtual /*Des*/                       ~I_SoundModule_Interface () = 0;
public:
  virtual void                          _list_types (Rapicorn::Aida::TypeHashList&) const;
  virtual const Rapicorn::Aida::PropertyList& _property_list ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SoundModule_Interface&);
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SoundModule_Interface*);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SoundModule_Interface*&);
} // BseTest

namespace Rapicorn {

namespace Aida {

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum1>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum1"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum1c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum1c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum2>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum2"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum2c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum2c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum3>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum3"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum3c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum3c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4a>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4a"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4b>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4b"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4c>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4c"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::Enum4d>() { return EnumInfo::from_nsid ("MandatoryNamespace", "Enum4d"); }

template<> inline EnumInfo enum_info<MandatoryNamespace::ExtensiveEnum>() { return EnumInfo::from_nsid ("MandatoryNamespace", "ExtensiveEnum"); }

template<> inline EnumInfo enum_info<InterfaceTests::QuickEnum>() { return EnumInfo::from_nsid ("InterfaceTests", "QuickEnum"); }

template<> inline EnumInfo enum_info<RapicornAidaTest::ClickType>() { return EnumInfo::from_nsid ("RapicornAidaTest", "ClickType"); }

template<> inline EnumInfo enum_info<RapicornAidaTest::MathExpressions>() { return EnumInfo::from_nsid ("RapicornAidaTest", "MathExpressions"); }
} // Aida
} // Rapicorn

// --- Implementations ---

namespace MandatoryNamespace {

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum1_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E1_A),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum1", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum1c_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E1C_A),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum1c", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum2_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2_B),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum2", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum2c_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2C_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E2C_B),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum2c", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum3_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3_C),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum3", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum3c_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3C_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3C_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E3C_C),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum3c", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum4a_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4A_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4a", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum4b_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4B_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4b", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum4c_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4C_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4c", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__Enum4d_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_A),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_B),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_C),
    RAPICORN_AIDA_ENUM_INFO_VALUE (E4D_D),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "Enum4d", enum_values);
});

static Rapicorn::Init _Rapicorn_Aida__INIT__ExtensiveEnum_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (V1a),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V1b),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V2),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V3),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V4),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V5),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V6),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V7),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V8),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V9),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V10),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V11),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V12),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V13),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V14),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V15),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V16),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V17),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V18),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V20),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V21),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V22),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V23),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V24),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V25),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V26),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V27),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V28),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V30),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V31),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V32),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V33),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V34),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V35),
    RAPICORN_AIDA_ENUM_INFO_VALUE (V36),
  };
  Rapicorn::Aida::EnumInfo::enlist ("MandatoryNamespace", "ExtensiveEnum", enum_values);
});

I_FirstInterface_Interface::I_FirstInterface_Interface ()
{}
I_FirstInterface_Interface::~I_FirstInterface_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_FirstInterface_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_FirstInterface_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_FirstInterface_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_FirstInterface_Interface> (fbr.pop_object());
}
void
I_FirstInterface_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x04be3719c81a379bULL, 0x1079454a90442f2cULL)); // FirstInterface
}
const Rapicorn::Aida::PropertyList&
I_FirstInterface_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const XFooRecordImpl &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (18);
  fb <<= self.single_bool;
  fb <<= self.single_num;
  fb <<= self.num64;
  fb <<= self.single_float;
  fb <<= self.single_string;
  fb <<= self.sibling1;
  fb <<= self.sibling2;
  fb <<= self.multi1;
  fb <<= self.multi2;
  fb <<= self.multi3;
  fb <<= self.multi4;
  fb <<= self.enum_field;
  fb <<= self.iface1;
  fb <<= self.iface2;
  fb <<= self.iface3;
  fb <<= self.any1;
  fb <<= self.any2;
  fb <<= self.any3;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, XFooRecordImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 18) return;
  fbr >>= self.single_bool;
  fbr >>= self.single_num;
  fbr >>= self.num64;
  fbr >>= self.single_float;
  fbr >>= self.single_string;
  fbr >>= self.sibling1;
  fbr >>= self.sibling2;
  fbr >>= self.multi1;
  fbr >>= self.multi2;
  fbr >>= self.multi3;
  fbr >>= self.multi4;
  fbr >>= self.enum_field;
  fbr >>= self.iface1;
  fbr >>= self.iface2;
  fbr >>= self.iface3;
  fbr >>= self.any1;
  fbr >>= self.any2;
  fbr >>= self.any3;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const XFooSequenceImpl &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, XFooSequenceImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
XFooSequenceImpl::reference
XFooSequenceImpl::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const IntSequenceImpl &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, IntSequenceImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
IntSequenceImpl::reference
IntSequenceImpl::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const FloatSequenceImpl &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, FloatSequenceImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
FloatSequenceImpl::reference
FloatSequenceImpl::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const StringSequenceImpl &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, StringSequenceImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
StringSequenceImpl::reference
StringSequenceImpl::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const ExtensiveEnumSequenceImpl &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, ExtensiveEnumSequenceImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
ExtensiveEnumSequenceImpl::reference
ExtensiveEnumSequenceImpl::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const RecordSequenceImpl &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, RecordSequenceImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
RecordSequenceImpl::reference
RecordSequenceImpl::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SequenceSequenceImpl &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SequenceSequenceImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SequenceSequenceImpl::reference
SequenceSequenceImpl::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const InterfaceSequenceImpl &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, InterfaceSequenceImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
InterfaceSequenceImpl::reference
InterfaceSequenceImpl::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const AnySequenceImpl &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, AnySequenceImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
AnySequenceImpl::reference
AnySequenceImpl::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const NestedTypesRecImpl &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (2);
  fb <<= self.rec;
  fb <<= self.seq;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, NestedTypesRecImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 2) return;
  fbr >>= self.rec;
  fbr >>= self.seq;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const NestedTypesSeqImpl &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, NestedTypesSeqImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
NestedTypesSeqImpl::reference
NestedTypesSeqImpl::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const NewRecordImpl &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (4);
  fb <<= self.i;
  fb <<= self.enum1;
  fb <<= self.xfs;
  fb <<= self.ntr;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, NewRecordImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 4) return;
  fbr >>= self.i;
  fbr >>= self.enum1;
  fbr >>= self.xfs;
  fbr >>= self.ntr;
}

namespace Inner {
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const InnerRecordImpl &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (3);
  fb <<= self.x;
  fb <<= self.y;
  fb <<= self.rec;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, InnerRecordImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 3) return;
  fbr >>= self.x;
  fbr >>= self.y;
  fbr >>= self.rec;
}
} // Inner
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const Refer2InnerImpl &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (1);
  fb <<= self.r;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, Refer2InnerImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 1) return;
  fbr >>= self.r;
}
} // MandatoryNamespace

namespace OtherNamespace {
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SomeRecordImpl &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (4);
  fb <<= self.r1;
  fb <<= self.r2;
  fb <<= self.r3;
  fb <<= self.r4;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SomeRecordImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 4) return;
  fbr >>= self.r1;
  fbr >>= self.r2;
  fbr >>= self.r3;
  fbr >>= self.r4;
}
} // OtherNamespace

namespace InterfaceTests {

I_UIWidgetArea_Interface::I_UIWidgetArea_Interface () :
  sig_void_signal (*this), sig_sample_signal (*this)
{}
I_UIWidgetArea_Interface::~I_UIWidgetArea_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_UIWidgetArea_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_UIWidgetArea_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_UIWidgetArea_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_UIWidgetArea_Interface> (fbr.pop_object());
}
void
I_UIWidgetArea_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0c1b9195fa9a5a6cULL, 0xc1f636e721317b86ULL)); // UIWidgetArea
}
const Rapicorn::Aida::PropertyList&
I_UIWidgetArea_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    // RAPICORN_AIDA_PROPERTY (I_UIWidgetArea_Interface, dummy, "dummy", "", ""),
    RAPICORN_AIDA_PROPERTY (I_UIWidgetArea_Interface, on_click, _("On CLick"), _("Command on button1 click"), "rw"),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_Parent_Interface::I_Parent_Interface ()
{}
I_Parent_Interface::~I_Parent_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Parent_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Parent_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_Parent_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_Parent_Interface> (fbr.pop_object());
}
void
I_Parent_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0d7cb4311e1f74a9ULL, 0xe1ad9d71f1c712e5ULL)); // Parent
}
const Rapicorn::Aida::PropertyList&
I_Parent_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_Child_Interface::I_Child_Interface ()
{}
I_Child_Interface::~I_Child_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Child_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Child_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_Child_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_Child_Interface> (fbr.pop_object());
}
void
I_Child_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0d7cb4311e1f74a9ULL, 0xe1ad9d71f1c712e5ULL)); // Parent
  thl.push_back (Rapicorn::Aida::TypeHash (0x0a44a1b5cf26cfc0ULL, 0xcd6e05d08ba2667eULL)); // Child
}
const Rapicorn::Aida::PropertyList&
I_Child_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_Parent_Interface::_property_list());
  return property_list;
}

I_Descendant_Interface::I_Descendant_Interface ()
{}
I_Descendant_Interface::~I_Descendant_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Descendant_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Descendant_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_Descendant_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_Descendant_Interface> (fbr.pop_object());
}
void
I_Descendant_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0a44a1b5cf26cfc0ULL, 0xcd6e05d08ba2667eULL)); // Child
  thl.push_back (Rapicorn::Aida::TypeHash (0x0d7cb4311e1f74a9ULL, 0xe1ad9d71f1c712e5ULL)); // Parent
  thl.push_back (Rapicorn::Aida::TypeHash (0x0980fc7a8521c350ULL, 0x641568ba1f461de2ULL)); // Descendant
}
const Rapicorn::Aida::PropertyList&
I_Descendant_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_Child_Interface::_property_list());
  return property_list;
}

I_GrandChild_Interface::I_GrandChild_Interface ()
{}
I_GrandChild_Interface::~I_GrandChild_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_GrandChild_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_GrandChild_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_GrandChild_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_GrandChild_Interface> (fbr.pop_object());
}
void
I_GrandChild_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0980fc7a8521c350ULL, 0x641568ba1f461de2ULL)); // Descendant
  thl.push_back (Rapicorn::Aida::TypeHash (0x0a44a1b5cf26cfc0ULL, 0xcd6e05d08ba2667eULL)); // Child
  thl.push_back (Rapicorn::Aida::TypeHash (0x0d7cb4311e1f74a9ULL, 0xe1ad9d71f1c712e5ULL)); // Parent
  thl.push_back (Rapicorn::Aida::TypeHash (0x001a87e60ed9bd66ULL, 0xfff1a96d7bab9cd9ULL)); // GrandChild
}
const Rapicorn::Aida::PropertyList&
I_GrandChild_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_Descendant_Interface::_property_list());
  return property_list;
}

static Rapicorn::Init _Rapicorn_Aida__INIT__QuickEnum_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (ZERO),
  };
  Rapicorn::Aida::EnumInfo::enlist ("InterfaceTests", "QuickEnum", enum_values);
});
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const QuickRecordImpl &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (2);
  fb <<= self.int1;
  fb <<= self.int2;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, QuickRecordImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 2) return;
  fbr >>= self.int1;
  fbr >>= self.int2;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const QuickSequenceImpl &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, QuickSequenceImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq(), AIDA_CONNECTION());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
QuickSequenceImpl::reference
QuickSequenceImpl::append_back()
{
  resize (size() + 1);
  return back();
}

I_QuickIface_Interface::I_QuickIface_Interface ()
{}
I_QuickIface_Interface::~I_QuickIface_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_QuickIface_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_QuickIface_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_QuickIface_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_QuickIface_Interface> (fbr.pop_object());
}
void
I_QuickIface_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0ce40c896cfa0177ULL, 0x5ab6faf97ff6fed2ULL)); // QuickIface
}
const Rapicorn::Aida::PropertyList&
I_QuickIface_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_MethodTestInterface_Interface::I_MethodTestInterface_Interface ()
{}
I_MethodTestInterface_Interface::~I_MethodTestInterface_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_MethodTestInterface_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_MethodTestInterface_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_MethodTestInterface_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_MethodTestInterface_Interface> (fbr.pop_object());
}
void
I_MethodTestInterface_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x03befccd5d5ee8d5ULL, 0x7f1f65a869ad267fULL)); // MethodTestInterface
}
const Rapicorn::Aida::PropertyList&
I_MethodTestInterface_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_SignalTestInterface_Interface::I_SignalTestInterface_Interface () :
  sig_void_result (*this), sig_bool_result (*this), sig_int32_result (*this), sig_int64_result (*this), sig_float64_result (*this), sig_string_result (*this), sig_enum_result (*this), sig_record_result (*this), sig_sequence_result (*this), sig_interface_result (*this), sig_any_result (*this), sig_self_result (*this), sig_void_arg (*this), sig_bool_arg (*this), sig_int32_arg (*this), sig_int64_arg (*this), sig_float64_arg (*this), sig_string_arg (*this), sig_enum_arg (*this), sig_record_arg (*this), sig_sequence_arg (*this), sig_interface_arg (*this), sig_any_arg (*this), sig_self_args (*this)
{}
I_SignalTestInterface_Interface::~I_SignalTestInterface_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_SignalTestInterface_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_SignalTestInterface_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_SignalTestInterface_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_SignalTestInterface_Interface> (fbr.pop_object());
}
void
I_SignalTestInterface_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0acc338edd01a172ULL, 0x27c5f8854a5f9458ULL)); // SignalTestInterface
}
const Rapicorn::Aida::PropertyList&
I_SignalTestInterface_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_ChildInheritingSignals_Interface::I_ChildInheritingSignals_Interface () :
  sig_child_signal (*this)
{}
I_ChildInheritingSignals_Interface::~I_ChildInheritingSignals_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ChildInheritingSignals_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ChildInheritingSignals_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ChildInheritingSignals_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_ChildInheritingSignals_Interface> (fbr.pop_object());
}
void
I_ChildInheritingSignals_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0acc338edd01a172ULL, 0x27c5f8854a5f9458ULL)); // SignalTestInterface
  thl.push_back (Rapicorn::Aida::TypeHash (0x0d6e67873f4098cbULL, 0xe7f2eb93eb46037cULL)); // ChildInheritingSignals
}
const Rapicorn::Aida::PropertyList&
I_ChildInheritingSignals_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_SignalTestInterface_Interface::_property_list());
  return property_list;
}

I_AnotherChild_Interface::I_AnotherChild_Interface ()
{}
I_AnotherChild_Interface::~I_AnotherChild_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_AnotherChild_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_AnotherChild_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_AnotherChild_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_AnotherChild_Interface> (fbr.pop_object());
}
void
I_AnotherChild_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0acc338edd01a172ULL, 0x27c5f8854a5f9458ULL)); // SignalTestInterface
  thl.push_back (Rapicorn::Aida::TypeHash (0x0e2870deaacf05f9ULL, 0x2851002b6bd14b7aULL)); // AnotherChild
}
const Rapicorn::Aida::PropertyList&
I_AnotherChild_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_SignalTestInterface_Interface::_property_list());
  return property_list;
}

I_PropertyTester_Interface::I_PropertyTester_Interface ()
{}
I_PropertyTester_Interface::~I_PropertyTester_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_PropertyTester_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_PropertyTester_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_PropertyTester_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_PropertyTester_Interface> (fbr.pop_object());
}
void
I_PropertyTester_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0de89d5c207bc662ULL, 0x846800e315917b46ULL)); // PropertyTester
}
const Rapicorn::Aida::PropertyList&
I_PropertyTester_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, bool_prop, "bool_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, int32_prop, "int32_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, int64_prop, "int64_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, float64_prop, "float64_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, string_prop, "string_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, enum_prop, "enum_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, record_prop, "record_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, sequence_prop, "sequence_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, interface_prop, "interface_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, self_prop, "self_prop", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTester_Interface, any_prop, "any_prop", "", ""),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}
} // InterfaceTests

namespace RapicornAidaTest {

static Rapicorn::Init _Rapicorn_Aida__INIT__ClickType_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_ON_PRESS),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_ON_RELEASE),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_SLOW_REPEAT),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_FAST_REPEAT),
    RAPICORN_AIDA_ENUM_INFO_VALUE (CLICK_KEY_REPEAT),
  };
  Rapicorn::Aida::EnumInfo::enlist ("RapicornAidaTest", "ClickType", enum_values);
});

I_ButtonArea_Interface::I_ButtonArea_Interface () :
  sig_check_activate (*this), sig_activate (*this)
{}
I_ButtonArea_Interface::~I_ButtonArea_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ButtonArea_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ButtonArea_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ButtonArea_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_ButtonArea_Interface> (fbr.pop_object());
}
void
I_ButtonArea_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0eb6bcdae9e87fe7ULL, 0xb2f16c34cdc20188ULL)); // ButtonArea
}
const Rapicorn::Aida::PropertyList&
I_ButtonArea_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    // RAPICORN_AIDA_PROPERTY (I_ButtonArea_Interface, on_click, "on_click", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_ButtonArea_Interface, on_click2, "on_click2", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_ButtonArea_Interface, on_click3, "on_click3", "", ""),
    // RAPICORN_AIDA_PROPERTY (I_ButtonArea_Interface, click_type, "click_type", "", ""),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

I_PureMethods_Interface::I_PureMethods_Interface ()
{}
I_PureMethods_Interface::~I_PureMethods_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_PureMethods_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_PureMethods_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_PureMethods_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_PureMethods_Interface> (fbr.pop_object());
}
void
I_PureMethods_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0e0bc42228fe9334ULL, 0x66dcee20d071f835ULL)); // PureMethods
}
const Rapicorn::Aida::PropertyList&
I_PureMethods_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

static Rapicorn::Init _Rapicorn_Aida__INIT__MathExpressions_ ([]() {
  static const Rapicorn::Aida::EnumInfo::Value enum_values[] = {
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_2),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_5),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_8),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_6),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_7),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_16),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_3),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_24),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_13),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_m2),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_77),
    RAPICORN_AIDA_ENUM_INFO_VALUE (RESULT_511),
  };
  Rapicorn::Aida::EnumInfo::enlist ("RapicornAidaTest", "MathExpressions", enum_values);
});
} // RapicornAidaTest

namespace Other {

I_NameTests_Interface::I_NameTests_Interface ()
{}
I_NameTests_Interface::~I_NameTests_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_NameTests_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_NameTests_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_NameTests_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_NameTests_Interface> (fbr.pop_object());
}
void
I_NameTests_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0ff49e5977e3e416ULL, 0x2d10a2bc2d53eab1ULL)); // NameTests
}
const Rapicorn::Aida::PropertyList&
I_NameTests_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}
} // Other

namespace BseTest {

I_Compressor_Interface::I_Compressor_Interface ()
{}
I_Compressor_Interface::~I_Compressor_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Compressor_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_Compressor_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_Compressor_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_Compressor_Interface> (fbr.pop_object());
}
void
I_Compressor_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x0491625894ae6f81ULL, 0x139b9ce73db32661ULL)); // Compressor
}
const Rapicorn::Aida::PropertyList&
I_Compressor_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    RAPICORN_AIDA_PROPERTY (I_Compressor_Interface, threshold, "", "", "w"),
    RAPICORN_AIDA_PROPERTY (I_Compressor_Interface, ratio, "", "", "w"),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const RecordForGroupsImpl &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (5);
  fb <<= self.i;
  fb <<= self.ratio;
  fb <<= self.ordinary_bool;
  fb <<= self.threshold1;
  fb <<= self.threshold2;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, RecordForGroupsImpl &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec(), AIDA_CONNECTION());
  if (fbr.remaining() < 5) return;
  fbr >>= self.i;
  fbr >>= self.ratio;
  fbr >>= self.ordinary_bool;
  fbr >>= self.threshold1;
  fbr >>= self.threshold2;
}

I_SoundModule_Interface::I_SoundModule_Interface ()
{}
I_SoundModule_Interface::~I_SoundModule_Interface () {}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_SoundModule_Interface &obj)
{
  fb.add_object (__AIDA_Local__::obj2id (&obj));
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_SoundModule_Interface *obj)
{
  fb.add_object (__AIDA_Local__::obj2id (obj));
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_SoundModule_Interface* &obj)
{
  obj = __AIDA_Local__::id2obj<I_SoundModule_Interface> (fbr.pop_object());
}
void
I_SoundModule_Interface::_list_types (Rapicorn::Aida::TypeHashList &thl) const
{
  thl.push_back (Rapicorn::Aida::TypeHash (0x06285204d12388cdULL, 0x2cf10a9d917227b5ULL)); // SoundModule
}
const Rapicorn::Aida::PropertyList&
I_SoundModule_Interface::_property_list ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::TestServerBase::_property_list());
  return property_list;
}

// --- Method Dispatchers & Registry ---
} // BseTest

namespace MandatoryNamespace {
static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__FirstInterface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_FirstInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__FirstInterface__void_func (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 0) return __AIDA_Local__::error ("invalid number of arguments");
  I_FirstInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  self->void_func ();
  return NULL;
}


namespace Inner {
} // Inner
} // MandatoryNamespace

namespace OtherNamespace {
} // OtherNamespace

namespace InterfaceTests {
static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__UIWidgetArea (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__UIWidgetArea__dummy (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  rval = self->dummy ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__UIWidgetArea__dummy (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  arg_dummy;
  fbr >>= arg_dummy;
  self->dummy (arg_dummy);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__UIWidgetArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__UIWidgetArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click;
  fbr >>= arg_on_click;
  self->on_click (arg_on_click);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__UIWidgetArea__simple_method (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 0) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  rval = self->simple_method ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__UIWidgetArea__single_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_n;
  fbr >>= arg_n;
  double  rval = self->single_arg (arg_n);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__UIWidgetArea__single_arg2 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_n;
  fbr >>= arg_n;
  double  rval = self->single_arg2 (arg_n);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__UIWidgetArea__two_args (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  double  rval = self->two_args (arg_n, arg_r);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__UIWidgetArea__two_args2 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  double  rval = self->two_args2 (arg_n, arg_r);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__UIWidgetArea__multi_args (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 6) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  arg_b;
  fbr >>= arg_b;
  Rapicorn::Aida::int64_t  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  int  arg_i;
  fbr >>= arg_i;
  std::string  arg_s;
  fbr >>= arg_s;
  double  arg_y;
  fbr >>= arg_y;
  double  rval = self->multi_args (arg_b, arg_n, arg_r, arg_i, arg_s, arg_y);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__UIWidgetArea__self_method (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_UIWidgetArea_Interface *arg_ba1;
  fbr >>= arg_ba1;
  I_UIWidgetArea_Interface *arg_ba2;
  fbr >>= arg_ba2;
  double  rval = self->self_method (*arg_ba1, *arg_ba2);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__UIWidgetArea__void_method (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 0) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  self->void_method ();
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__UIWidgetArea__on_click2out (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 0) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click2out ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__UIWidgetArea__on_click2in (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_command;
  fbr >>= arg_command;
  self->on_click2in (arg_command);
  return NULL;
}
class _$Closure__UIWidgetArea__void_signal {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__UIWidgetArea__void_signal> SharedPtr;
  _$Closure__UIWidgetArea__void_signal (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__UIWidgetArea__void_signal()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__UIWidgetArea__void_signal (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_void_signal.disconnect (con_id);
  if (handler_id) {
    _$Closure__UIWidgetArea__void_signal::SharedPtr sp (new _$Closure__UIWidgetArea__void_signal (AIDA_CONNECTION(), handler_id));
    cid = self->sig_void_signal.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__UIWidgetArea__sample_signal {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__UIWidgetArea__sample_signal> SharedPtr;
  _$Closure__UIWidgetArea__sample_signal (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__UIWidgetArea__sample_signal()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static double
  handler (I_UIWidgetArea_Interface &arg_ba1,
           int arg_someint,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 2);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_ba1;
    fb <<= arg_someint;
    sp->m_connection.send_event (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__UIWidgetArea__sample_signal (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_sample_signal.disconnect (con_id);
  if (handler_id) {
    _$Closure__UIWidgetArea__sample_signal::SharedPtr sp (new _$Closure__UIWidgetArea__sample_signal (AIDA_CONNECTION(), handler_id));
    cid = self->sig_sample_signal.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__Parent (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Parent_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__Child (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Child_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__Descendant (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Descendant_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__GrandChild (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_GrandChild_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__QuickIface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_QuickIface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__QuickIface__simple_function (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_QuickIface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_i;
  fbr >>= arg_i;
  self->simple_function (arg_i);
  return NULL;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__MethodTestInterface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_void (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 0) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  self->method_with_void ();
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_bools (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  arg_input;
  fbr >>= arg_input;
  bool  arg_optval;
  fbr >>= arg_optval;
  bool  rval = self->method_with_bools (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_ints32 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_input;
  fbr >>= arg_input;
  int  arg_optval;
  fbr >>= arg_optval;
  int  rval = self->method_with_ints32 (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_ints64 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::int64_t  arg_input;
  fbr >>= arg_input;
  Rapicorn::Aida::int64_t  arg_optval;
  fbr >>= arg_optval;
  Rapicorn::Aida::int64_t  rval = self->method_with_ints64 (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_floats (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  arg_input;
  fbr >>= arg_input;
  double  arg_optval;
  fbr >>= arg_optval;
  double  rval = self->method_with_floats (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_string (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_input;
  fbr >>= arg_input;
  std::string  arg_optval;
  fbr >>= arg_optval;
  std::string  rval = self->method_with_string (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_enum (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickEnum  arg_input;
  fbr >>= arg_input;
  QuickEnum  arg_optval;
  fbr >>= arg_optval;
  QuickEnum  rval = self->method_with_enum (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_record (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickRecordImpl  arg_input;
  fbr >>= arg_input;
  QuickRecordImpl  arg_optval;
  fbr >>= arg_optval;
  QuickRecordImpl  rval = self->method_with_record (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_sequence (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickSequenceImpl  arg_input;
  fbr >>= arg_input;
  QuickSequenceImpl  arg_optval;
  fbr >>= arg_optval;
  QuickSequenceImpl  rval = self->method_with_sequence (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_interface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_GrandChild_Interface *arg_input;
  fbr >>= arg_input;
  I_GrandChild_Interface *arg_optval;
  fbr >>= arg_optval;
  I_GrandChild_Interface *rval = self->method_with_interface (*arg_input, *arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_anys (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::Any  arg_input;
  fbr >>= arg_input;
  Rapicorn::Aida::Any  arg_optval;
  fbr >>= arg_optval;
  Rapicorn::Aida::Any  rval = self->method_with_anys (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__MethodTestInterface__method_with_quickiface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_QuickIface_Interface *arg_input;
  fbr >>= arg_input;
  I_QuickIface_Interface *arg_iface0;
  fbr >>= arg_iface0;
  I_QuickIface_Interface *rval = self->method_with_quickiface (*arg_input, *arg_iface0);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__SignalTestInterface (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
class _$Closure__SignalTestInterface__void_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__void_result> SharedPtr;
  _$Closure__SignalTestInterface__void_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__void_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__void_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_void_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__void_result::SharedPtr sp (new _$Closure__SignalTestInterface__void_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_void_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__bool_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__bool_result> SharedPtr;
  _$Closure__SignalTestInterface__bool_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__bool_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static bool
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__bool_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_bool_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__bool_result::SharedPtr sp (new _$Closure__SignalTestInterface__bool_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_bool_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__int32_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__int32_result> SharedPtr;
  _$Closure__SignalTestInterface__int32_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__int32_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static int
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__int32_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_int32_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__int32_result::SharedPtr sp (new _$Closure__SignalTestInterface__int32_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_int32_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__int64_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__int64_result> SharedPtr;
  _$Closure__SignalTestInterface__int64_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__int64_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static Rapicorn::Aida::int64_t
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__int64_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_int64_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__int64_result::SharedPtr sp (new _$Closure__SignalTestInterface__int64_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_int64_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__float64_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__float64_result> SharedPtr;
  _$Closure__SignalTestInterface__float64_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__float64_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static double
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__float64_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_float64_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__float64_result::SharedPtr sp (new _$Closure__SignalTestInterface__float64_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_float64_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__string_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__string_result> SharedPtr;
  _$Closure__SignalTestInterface__string_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__string_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static std::string
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return "";
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__string_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_string_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__string_result::SharedPtr sp (new _$Closure__SignalTestInterface__string_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_string_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__enum_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__enum_result> SharedPtr;
  _$Closure__SignalTestInterface__enum_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__enum_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static QuickEnum
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return QuickEnum (0);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__enum_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_enum_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__enum_result::SharedPtr sp (new _$Closure__SignalTestInterface__enum_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_enum_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__record_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__record_result> SharedPtr;
  _$Closure__SignalTestInterface__record_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__record_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static QuickRecordImpl
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return QuickRecordImpl();
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__record_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_record_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__record_result::SharedPtr sp (new _$Closure__SignalTestInterface__record_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_record_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__sequence_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__sequence_result> SharedPtr;
  _$Closure__SignalTestInterface__sequence_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__sequence_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static QuickSequenceImpl
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return QuickSequenceImpl();
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__sequence_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_sequence_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__sequence_result::SharedPtr sp (new _$Closure__SignalTestInterface__sequence_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_sequence_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__interface_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__interface_result> SharedPtr;
  _$Closure__SignalTestInterface__interface_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__interface_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static I_GrandChild_Interface*
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__interface_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_interface_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__interface_result::SharedPtr sp (new _$Closure__SignalTestInterface__interface_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_interface_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__any_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__any_result> SharedPtr;
  _$Closure__SignalTestInterface__any_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__any_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static Rapicorn::Aida::Any
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return Rapicorn::Aida::Any();
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__any_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_any_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__any_result::SharedPtr sp (new _$Closure__SignalTestInterface__any_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_any_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__self_result {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__self_result> SharedPtr;
  _$Closure__SignalTestInterface__self_result (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__self_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static I_SignalTestInterface_Interface*
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__self_result (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_self_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__self_result::SharedPtr sp (new _$Closure__SignalTestInterface__self_result (AIDA_CONNECTION(), handler_id));
    cid = self->sig_self_result.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__void_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__void_arg> SharedPtr;
  _$Closure__SignalTestInterface__void_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__void_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__void_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_void_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__void_arg::SharedPtr sp (new _$Closure__SignalTestInterface__void_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_void_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__bool_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__bool_arg> SharedPtr;
  _$Closure__SignalTestInterface__bool_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__bool_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (bool arg_b,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_b;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__bool_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_bool_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__bool_arg::SharedPtr sp (new _$Closure__SignalTestInterface__bool_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_bool_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__int32_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__int32_arg> SharedPtr;
  _$Closure__SignalTestInterface__int32_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__int32_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (int arg_i,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_i;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__int32_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_int32_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__int32_arg::SharedPtr sp (new _$Closure__SignalTestInterface__int32_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_int32_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__int64_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__int64_arg> SharedPtr;
  _$Closure__SignalTestInterface__int64_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__int64_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (Rapicorn::Aida::int64_t arg_i,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_i;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__int64_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_int64_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__int64_arg::SharedPtr sp (new _$Closure__SignalTestInterface__int64_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_int64_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__float64_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__float64_arg> SharedPtr;
  _$Closure__SignalTestInterface__float64_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__float64_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (double arg_f,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_f;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__float64_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_float64_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__float64_arg::SharedPtr sp (new _$Closure__SignalTestInterface__float64_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_float64_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__string_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__string_arg> SharedPtr;
  _$Closure__SignalTestInterface__string_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__string_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (const std::string &arg_s,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_s;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__string_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_string_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__string_arg::SharedPtr sp (new _$Closure__SignalTestInterface__string_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_string_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__enum_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__enum_arg> SharedPtr;
  _$Closure__SignalTestInterface__enum_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__enum_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (QuickEnum arg_e,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_e;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__enum_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_enum_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__enum_arg::SharedPtr sp (new _$Closure__SignalTestInterface__enum_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_enum_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__record_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__record_arg> SharedPtr;
  _$Closure__SignalTestInterface__record_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__record_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (const QuickRecordImpl &arg_r,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_r;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__record_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_record_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__record_arg::SharedPtr sp (new _$Closure__SignalTestInterface__record_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_record_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__sequence_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__sequence_arg> SharedPtr;
  _$Closure__SignalTestInterface__sequence_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__sequence_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (const QuickSequenceImpl &arg_s,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_s;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__sequence_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_sequence_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__sequence_arg::SharedPtr sp (new _$Closure__SignalTestInterface__sequence_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_sequence_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__interface_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__interface_arg> SharedPtr;
  _$Closure__SignalTestInterface__interface_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__interface_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (I_GrandChild_Interface &arg_i,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_i;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__interface_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_interface_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__interface_arg::SharedPtr sp (new _$Closure__SignalTestInterface__interface_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_interface_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__any_arg {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__any_arg> SharedPtr;
  _$Closure__SignalTestInterface__any_arg (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__any_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (const Rapicorn::Aida::Any &arg_a,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_a;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__any_arg (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_any_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__any_arg::SharedPtr sp (new _$Closure__SignalTestInterface__any_arg (AIDA_CONNECTION(), handler_id));
    cid = self->sig_any_arg.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__SignalTestInterface__self_args {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__SignalTestInterface__self_args> SharedPtr;
  _$Closure__SignalTestInterface__self_args (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__self_args()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (I_SignalTestInterface_Interface &arg_self_,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_self_;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__SignalTestInterface__self_args (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_self_args.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__self_args::SharedPtr sp (new _$Closure__SignalTestInterface__self_args (AIDA_CONNECTION(), handler_id));
    cid = self->sig_self_args.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__ChildInheritingSignals (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ChildInheritingSignals_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
class _$Closure__ChildInheritingSignals__child_signal {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__ChildInheritingSignals__child_signal> SharedPtr;
  _$Closure__ChildInheritingSignals__child_signal (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__ChildInheritingSignals__child_signal()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (I_ChildInheritingSignals_Interface &arg_c,
           I_SignalTestInterface_Interface &arg_p,
           const Rapicorn::Aida::Any &arg_a,
           int arg_i,
           const QuickRecordImpl &arg_r,
           const QuickSequenceImpl &arg_s,
           SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 6);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    fb <<= arg_c;
    fb <<= arg_p;
    fb <<= arg_a;
    fb <<= arg_i;
    fb <<= arg_r;
    fb <<= arg_s;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__ChildInheritingSignals__child_signal (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_ChildInheritingSignals_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_child_signal.disconnect (con_id);
  if (handler_id) {
    _$Closure__ChildInheritingSignals__child_signal::SharedPtr sp (new _$Closure__ChildInheritingSignals__child_signal (AIDA_CONNECTION(), handler_id));
    cid = self->sig_child_signal.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__AnotherChild (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_AnotherChild_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__PropertyTester (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__PropertyTester__bool_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  rval = self->bool_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__PropertyTester__bool_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  bool  arg_bool_prop;
  fbr >>= arg_bool_prop;
  self->bool_prop (arg_bool_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__PropertyTester__int32_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  rval = self->int32_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__PropertyTester__int32_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  int  arg_int32_prop;
  fbr >>= arg_int32_prop;
  self->int32_prop (arg_int32_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__PropertyTester__int64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::int64_t  rval = self->int64_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__PropertyTester__int64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::int64_t  arg_int64_prop;
  fbr >>= arg_int64_prop;
  self->int64_prop (arg_int64_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__PropertyTester__float64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  rval = self->float64_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__PropertyTester__float64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  arg_float64_prop;
  fbr >>= arg_float64_prop;
  self->float64_prop (arg_float64_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__PropertyTester__string_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->string_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__PropertyTester__string_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_string_prop;
  fbr >>= arg_string_prop;
  self->string_prop (arg_string_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__PropertyTester__enum_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickEnum  rval = self->enum_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__PropertyTester__enum_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickEnum  arg_enum_prop;
  fbr >>= arg_enum_prop;
  self->enum_prop (arg_enum_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__PropertyTester__record_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickRecordImpl  rval = self->record_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__PropertyTester__record_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickRecordImpl  arg_record_prop;
  fbr >>= arg_record_prop;
  self->record_prop (arg_record_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__PropertyTester__sequence_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickSequenceImpl  rval = self->sequence_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__PropertyTester__sequence_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  QuickSequenceImpl  arg_sequence_prop;
  fbr >>= arg_sequence_prop;
  self->sequence_prop (arg_sequence_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__PropertyTester__interface_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_GrandChild_Interface *rval = self->interface_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__PropertyTester__interface_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_GrandChild_Interface *arg_interface_prop;
  fbr >>= arg_interface_prop;
  self->interface_prop (&*arg_interface_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__PropertyTester__self_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_PropertyTester_Interface *rval = self->self_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__PropertyTester__self_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  I_PropertyTester_Interface *arg_self_prop;
  fbr >>= arg_self_prop;
  self->self_prop (&*arg_self_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__PropertyTester__any_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::Any  rval = self->any_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__PropertyTester__any_prop (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::Any  arg_any_prop;
  fbr >>= arg_any_prop;
  self->any_prop (arg_any_prop);
  return NULL;
}

} // InterfaceTests

namespace RapicornAidaTest {
static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__ButtonArea (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__ButtonArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__ButtonArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click;
  fbr >>= arg_on_click;
  self->on_click (arg_on_click);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__ButtonArea__on_click2 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click2 ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__ButtonArea__on_click2 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click2;
  fbr >>= arg_on_click2;
  self->on_click2 (arg_on_click2);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__ButtonArea__on_click3 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click3 ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__ButtonArea__on_click3 (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click3;
  fbr >>= arg_on_click3;
  self->on_click3 (arg_on_click3);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__ButtonArea__click_type (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  ClickType  rval = self->click_type ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__ButtonArea__click_type (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  ClickType  arg_click_type;
  fbr >>= arg_click_type;
  self->click_type (arg_click_type);
  return NULL;
}
class _$Closure__ButtonArea__check_activate {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__ButtonArea__check_activate> SharedPtr;
  _$Closure__ButtonArea__check_activate (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__ButtonArea__check_activate()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static bool
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
    return 0;
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__ButtonArea__check_activate (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_check_activate.disconnect (con_id);
  if (handler_id) {
    _$Closure__ButtonArea__check_activate::SharedPtr sp (new _$Closure__ButtonArea__check_activate (AIDA_CONNECTION(), handler_id));
    cid = self->sig_check_activate.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}
class _$Closure__ButtonArea__activate {
  Rapicorn::Aida::ServerConnection &m_connection; Rapicorn::Aida::uint64_t m_handler;
public:
  typedef std::shared_ptr<_$Closure__ButtonArea__activate> SharedPtr;
  _$Closure__ButtonArea__activate (Rapicorn::Aida::ServerConnection &conn, Rapicorn::Aida::uint64_t h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__ButtonArea__activate()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Rapicorn::Aida::MSGID_DISCON, 0); // FIXME: 0
    fb <<= m_handler;
    m_connection.send_event (&fb);
  }
  static void
  handler (SharedPtr sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Rapicorn::Aida::MSGID_EVENT, 0); // FIXME: 0
    fb <<= sp->m_handler;
    sp->m_connection.send_event (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
_$sigcon__ButtonArea__activate (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return __AIDA_Local__::error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::uint64_t handler_id, con_id, cid = 0;
  fbr >>= handler_id;
  fbr >>= con_id;
  if (con_id) self->sig_activate.disconnect (con_id);
  if (handler_id) {
    _$Closure__ButtonArea__activate::SharedPtr sp (new _$Closure__ButtonArea__activate (AIDA_CONNECTION(), handler_id));
    cid = self->sig_activate.connect (slot (sp->handler, sp)); }
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= cid;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__PureMethods (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PureMethods_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__PureMethods__pure_method (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_PureMethods_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  arg_f;
  fbr >>= arg_f;
  int  rval = self->pure_method (arg_f);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}

} // RapicornAidaTest

namespace Other {
static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__NameTests (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_NameTests_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$caller__NameTests__args_from_other_namespace (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 3) return __AIDA_Local__::error ("invalid number of arguments");
  I_NameTests_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  InterfaceTests::QuickRecordImpl  arg_qr;
  fbr >>= arg_qr;
  RapicornAidaTest::ClickType  arg_qe;
  fbr >>= arg_qe;
  OtherNamespace::SomeRecordImpl  arg_sr;
  fbr >>= arg_sr;
  self->args_from_other_namespace (arg_qr, arg_qe, arg_sr);
  return NULL;
}

} // Other

namespace BseTest {
static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__Compressor (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Compressor_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__Compressor__threshold (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Compressor_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  rval = self->threshold ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__Compressor__threshold (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Compressor_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  arg_threshold;
  fbr >>= arg_threshold;
  self->threshold (arg_threshold);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
_$getter__Compressor__ratio (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Compressor_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  rval = self->ratio ();
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result();
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
_$setter__Compressor__ratio (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_Compressor_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  double  arg_ratio;
  fbr >>= arg_ratio;
  self->ratio (arg_ratio);
  return NULL;
}

static Rapicorn::Aida::FieldBuffer*
__AIDA_list_types__SoundModule (Rapicorn::Aida::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return __AIDA_Local__::error ("invalid number of arguments");
  I_SoundModule_Interface *self;
  fbr >>= self;
  AIDA_CHECK (self, "self must be non-NULL");
  Rapicorn::Aida::TypeHashList thl;
  self->_list_types (thl);
  Rapicorn::Aida::FieldBuffer &rb = *Rapicorn::Aida::FieldBuffer::new_result (1 + 2 * thl.size());
  rb <<= Rapicorn::Aida::int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static const Rapicorn::Aida::ServerConnection::MethodEntry _aida_stub_entries[] = {
  { 0x3cad22e1b186d8e6ULL, 0x23cfa997842f0221ULL, MandatoryNamespace::__AIDA_list_types__FirstInterface, },
  { 0x209463c55becedadULL, 0x39ddfcb9aadc3c74ULL, MandatoryNamespace::_$caller__FirstInterface__void_func, },
  { 0x3fb268ab4c1fdceeULL, 0xa7ef7cb29317740fULL, InterfaceTests::__AIDA_list_types__UIWidgetArea, },
  { 0x311213c7f9f683fbULL, 0x5ce277b1d4ad5f84ULL, InterfaceTests::_$getter__UIWidgetArea__dummy, },
  { 0x2cd4545fdbf8e1bcULL, 0xf980e99fa9f34ab1ULL, InterfaceTests::_$setter__UIWidgetArea__dummy, },
  { 0x389d73bb93692d3eULL, 0xe60676c6ab0ecd60ULL, InterfaceTests::_$getter__UIWidgetArea__on_click, },
  { 0x201f34e07478bbcbULL, 0x7fa4069706e6233aULL, InterfaceTests::_$setter__UIWidgetArea__on_click, },
  { 0x3a2f8d1c42ac1785ULL, 0x58b20fa269c0bd5eULL, InterfaceTests::_$caller__UIWidgetArea__simple_method, },
  { 0x3ea3da9f2d46a894ULL, 0xa37baf774b855c65ULL, InterfaceTests::_$caller__UIWidgetArea__single_arg, },
  { 0x323870aec608428aULL, 0x3e4eb826e4565354ULL, InterfaceTests::_$caller__UIWidgetArea__single_arg2, },
  { 0x372d3445333b29d9ULL, 0x2a1b6a54e409ca63ULL, InterfaceTests::_$caller__UIWidgetArea__two_args, },
  { 0x3a5296dee6dca6f6ULL, 0xbe00f1270b1a7a1cULL, InterfaceTests::_$caller__UIWidgetArea__two_args2, },
  { 0x3da25289fcf7fe26ULL, 0xf2dfa2d031dd302cULL, InterfaceTests::_$caller__UIWidgetArea__multi_args, },
  { 0x3b4bb0d6b3f38abdULL, 0x80e1a7b9347c576aULL, InterfaceTests::_$caller__UIWidgetArea__self_method, },
  { 0x2e02c52c84773703ULL, 0x00027e452edb615cULL, InterfaceTests::_$caller__UIWidgetArea__void_method, },
  { 0x3550e7348466c129ULL, 0x1ea5baf75297246fULL, InterfaceTests::_$caller__UIWidgetArea__on_click2out, },
  { 0x24ee88e59b05bae4ULL, 0x879ebaad31e6d20eULL, InterfaceTests::_$caller__UIWidgetArea__on_click2in, },
  { 0x52ef738c2571d0f2ULL, 0x05b653adf0a80acfULL, InterfaceTests::_$sigcon__UIWidgetArea__void_signal, },
  { 0x506409a3044ac65eULL, 0xda804abb85f8c1e8ULL, InterfaceTests::_$sigcon__UIWidgetArea__sample_signal, },
  { 0x3327c0cc6ecd6a2dULL, 0x0de3e7721fabd150ULL, InterfaceTests::__AIDA_list_types__Parent, },
  { 0x3118068a57e2ee2aULL, 0xc4519ca878439f44ULL, InterfaceTests::__AIDA_list_types__Child, },
  { 0x3fc1dfccbeb60bb3ULL, 0xbd418b9a2af4becbULL, InterfaceTests::__AIDA_list_types__Descendant, },
  { 0x3971e4cc3544a47cULL, 0xdea4e100c7a24298ULL, InterfaceTests::__AIDA_list_types__GrandChild, },
  { 0x383dc33025fafcfaULL, 0xda0a2afdebee2319ULL, InterfaceTests::__AIDA_list_types__QuickIface, },
  { 0x2b860359fa7e3dceULL, 0x198d5fe242474308ULL, InterfaceTests::_$caller__QuickIface__simple_function, },
  { 0x3b0c3b9557d989c7ULL, 0xdc704105222c6a36ULL, InterfaceTests::__AIDA_list_types__MethodTestInterface, },
  { 0x281392e54343bee9ULL, 0x0dbeb788728dbff4ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_void, },
  { 0x3b68546991e25342ULL, 0xa71399caec9ccfc7ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_bools, },
  { 0x3c7dd838073a8a92ULL, 0xddd57eef6f36ab11ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_ints32, },
  { 0x394bb1c2a7be91fbULL, 0x3f077bb42a25d6e4ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_ints64, },
  { 0x368776130b055120ULL, 0x64281c55fbfe5bb9ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_floats, },
  { 0x378c9594060f2266ULL, 0x5331c53659132c99ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_string, },
  { 0x387f08a5c150e6a7ULL, 0x83c133fcd2be3200ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_enum, },
  { 0x3b59b493f287edf0ULL, 0x4771d353c78389d1ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_record, },
  { 0x34c9e8a686a7f261ULL, 0x9af099b173ac979cULL, InterfaceTests::_$caller__MethodTestInterface__method_with_sequence, },
  { 0x34619983babcee5bULL, 0x9875f78f28f381b7ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_interface, },
  { 0x362c672843766d85ULL, 0x6ed30851db440471ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_anys, },
  { 0x3a2ab33a8358edcbULL, 0x7c028db9464052a0ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_quickiface, },
  { 0x3570023447b98293ULL, 0x7acb17b4ba84a625ULL, InterfaceTests::__AIDA_list_types__SignalTestInterface, },
  { 0x535d5e95471873b6ULL, 0x7a9f5692ce00e007ULL, InterfaceTests::_$sigcon__SignalTestInterface__void_result, },
  { 0x51ffffa2f8db1b1bULL, 0x3e01434baf49eceeULL, InterfaceTests::_$sigcon__SignalTestInterface__bool_result, },
  { 0x503a5722f565a9faULL, 0x0c5aed4d39b9ca12ULL, InterfaceTests::_$sigcon__SignalTestInterface__int32_result, },
  { 0x5670d5594a24b2d9ULL, 0x8ad93cc1a1e9bb50ULL, InterfaceTests::_$sigcon__SignalTestInterface__int64_result, },
  { 0x51aee1ad06b0e2ffULL, 0x0a7f816f9bdaf008ULL, InterfaceTests::_$sigcon__SignalTestInterface__float64_result, },
  { 0x5daa2a4439deab5fULL, 0xc0580f71a4d7d1d6ULL, InterfaceTests::_$sigcon__SignalTestInterface__string_result, },
  { 0x56fc6f3f4946e7b2ULL, 0x0fe0cc5f83d2ab84ULL, InterfaceTests::_$sigcon__SignalTestInterface__enum_result, },
  { 0x50b723665ed298a5ULL, 0x32aa063680a4e3c0ULL, InterfaceTests::_$sigcon__SignalTestInterface__record_result, },
  { 0x5ef00325dfcf4552ULL, 0x991130ecddd21730ULL, InterfaceTests::_$sigcon__SignalTestInterface__sequence_result, },
  { 0x58e8587c542d85ceULL, 0xe2b572e902c69f7cULL, InterfaceTests::_$sigcon__SignalTestInterface__interface_result, },
  { 0x5ae2293e0b4f9854ULL, 0xbb549e7d52c43e50ULL, InterfaceTests::_$sigcon__SignalTestInterface__any_result, },
  { 0x59bb2da621bab28fULL, 0x32bc82e7eb9bc512ULL, InterfaceTests::_$sigcon__SignalTestInterface__self_result, },
  { 0x583dc36c7785c7f3ULL, 0xb330cefa4e8247a9ULL, InterfaceTests::_$sigcon__SignalTestInterface__void_arg, },
  { 0x5f7ba898d12986bfULL, 0x8a1143a5f6dc85b8ULL, InterfaceTests::_$sigcon__SignalTestInterface__bool_arg, },
  { 0x583ed84bd4d820efULL, 0x87214001f1934890ULL, InterfaceTests::_$sigcon__SignalTestInterface__int32_arg, },
  { 0x5d6ed628b051e336ULL, 0x442670f1eba34b7bULL, InterfaceTests::_$sigcon__SignalTestInterface__int64_arg, },
  { 0x5d937b3a9a059ff0ULL, 0x641851b425c3f91cULL, InterfaceTests::_$sigcon__SignalTestInterface__float64_arg, },
  { 0x524e550794aaa1e8ULL, 0x093b71ccace2863bULL, InterfaceTests::_$sigcon__SignalTestInterface__string_arg, },
  { 0x586138796f133c4dULL, 0x1c7573f2d30ac907ULL, InterfaceTests::_$sigcon__SignalTestInterface__enum_arg, },
  { 0x59cb77461ddeac82ULL, 0xfeaa98721bd8ecd3ULL, InterfaceTests::_$sigcon__SignalTestInterface__record_arg, },
  { 0x547b4dd41606b568ULL, 0x1d763791a33d2bc9ULL, InterfaceTests::_$sigcon__SignalTestInterface__sequence_arg, },
  { 0x57a5dbfbeb5a4ef9ULL, 0xb5df0c3b3bba4b22ULL, InterfaceTests::_$sigcon__SignalTestInterface__interface_arg, },
  { 0x51355ac177cc776eULL, 0x8b062ce8d8442de0ULL, InterfaceTests::_$sigcon__SignalTestInterface__any_arg, },
  { 0x5c515ee37b78a970ULL, 0xe89c2af2f29359a0ULL, InterfaceTests::_$sigcon__SignalTestInterface__self_args, },
  { 0x3de75b0bd290d267ULL, 0x69c1ca3c14a574bdULL, InterfaceTests::__AIDA_list_types__ChildInheritingSignals, },
  { 0x5ffad83b68b79139ULL, 0x7175e65d7705749fULL, InterfaceTests::_$sigcon__ChildInheritingSignals__child_signal, },
  { 0x3151395e716b65e2ULL, 0x64194778ee7320bcULL, InterfaceTests::__AIDA_list_types__AnotherChild, },
  { 0x3538d51513b2455aULL, 0x2707341b320622dfULL, InterfaceTests::__AIDA_list_types__PropertyTester, },
  { 0x396c5b1aaf49cec6ULL, 0xb6218ab5ac6b82c3ULL, InterfaceTests::_$getter__PropertyTester__bool_prop, },
  { 0x2bd3c8fc8f71f8b4ULL, 0x2dde5c2c8fcf750cULL, InterfaceTests::_$setter__PropertyTester__bool_prop, },
  { 0x3fc09bee2af126a2ULL, 0xc3a6e67a53c81eb1ULL, InterfaceTests::_$getter__PropertyTester__int32_prop, },
  { 0x26fd925ece96e768ULL, 0xac82e725f914b79dULL, InterfaceTests::_$setter__PropertyTester__int32_prop, },
  { 0x3731039da4eac87cULL, 0x78ad56f71ec3500aULL, InterfaceTests::_$getter__PropertyTester__int64_prop, },
  { 0x2231b1bcd886b3c0ULL, 0x84a1427a737bc687ULL, InterfaceTests::_$setter__PropertyTester__int64_prop, },
  { 0x36e831c918e287dfULL, 0x6bd2c7a7a75237faULL, InterfaceTests::_$getter__PropertyTester__float64_prop, },
  { 0x2e886d9d9b74fd50ULL, 0xf218d40a5edc2eb9ULL, InterfaceTests::_$setter__PropertyTester__float64_prop, },
  { 0x31541f027fda353dULL, 0x578dfb53a92c60edULL, InterfaceTests::_$getter__PropertyTester__string_prop, },
  { 0x28966e5a860d2cf1ULL, 0x23ba16b5fffc368dULL, InterfaceTests::_$setter__PropertyTester__string_prop, },
  { 0x3d09e074f5d2f8edULL, 0x38e8a275e29c3fc2ULL, InterfaceTests::_$getter__PropertyTester__enum_prop, },
  { 0x2b77a2f3a3c4d5b4ULL, 0x4d5b96d1adf5f7ccULL, InterfaceTests::_$setter__PropertyTester__enum_prop, },
  { 0x31443949c61d0fecULL, 0xeb221638d6ffd3cfULL, InterfaceTests::_$getter__PropertyTester__record_prop, },
  { 0x2a5f5c212625f446ULL, 0x30d24123307269ceULL, InterfaceTests::_$setter__PropertyTester__record_prop, },
  { 0x3f323c929c803ea8ULL, 0x6ebf49e977bfb699ULL, InterfaceTests::_$getter__PropertyTester__sequence_prop, },
  { 0x232174952090a941ULL, 0xae8b7a3e13fdfde7ULL, InterfaceTests::_$setter__PropertyTester__sequence_prop, },
  { 0x33a8b72ea92bb600ULL, 0x3837c1118556aaedULL, InterfaceTests::_$getter__PropertyTester__interface_prop, },
  { 0x29163b10631cf4b4ULL, 0xf014d69b1a1153e9ULL, InterfaceTests::_$setter__PropertyTester__interface_prop, },
  { 0x3e6b07e114fab96bULL, 0x45a97f76ee1a7bcfULL, InterfaceTests::_$getter__PropertyTester__self_prop, },
  { 0x2c1aea6b5567c7beULL, 0x8f21acd05f5030deULL, InterfaceTests::_$setter__PropertyTester__self_prop, },
  { 0x385bac7894911455ULL, 0x4d74265aa4c9d3b8ULL, InterfaceTests::_$getter__PropertyTester__any_prop, },
  { 0x25ed5049e1dab81dULL, 0x30b595a3c260b96fULL, InterfaceTests::_$setter__PropertyTester__any_prop, },
  { 0x397a884d8f22f463ULL, 0x3b07e25021b667fdULL, RapicornAidaTest::__AIDA_list_types__ButtonArea, },
  { 0x30c3d3f2b33bf581ULL, 0x79478f015decbb26ULL, RapicornAidaTest::_$getter__ButtonArea__on_click, },
  { 0x2049371318a90eaeULL, 0xaad2e3187e219eaeULL, RapicornAidaTest::_$setter__ButtonArea__on_click, },
  { 0x35b46ed6cb8f24c3ULL, 0x261d8542336e8649ULL, RapicornAidaTest::_$getter__ButtonArea__on_click2, },
  { 0x281a2b2347c96db8ULL, 0xa01a955774bc9430ULL, RapicornAidaTest::_$setter__ButtonArea__on_click2, },
  { 0x3a9709045f2195e3ULL, 0x8ac0eb7887c2a8eeULL, RapicornAidaTest::_$getter__ButtonArea__on_click3, },
  { 0x29abcf6a16721aabULL, 0xed1c45f01dbea439ULL, RapicornAidaTest::_$setter__ButtonArea__on_click3, },
  { 0x33032db41e62e30fULL, 0x92d90ac8cf899010ULL, RapicornAidaTest::_$getter__ButtonArea__click_type, },
  { 0x21058465dc0b1d3fULL, 0x7e683383d0024c74ULL, RapicornAidaTest::_$setter__ButtonArea__click_type, },
  { 0x5ed315978fdefdcaULL, 0x9efe9e4845d8907eULL, RapicornAidaTest::_$sigcon__ButtonArea__check_activate, },
  { 0x57905c3b089b970eULL, 0x3774e2d97c70a48fULL, RapicornAidaTest::_$sigcon__ButtonArea__activate, },
  { 0x3969e9b8871ee6b7ULL, 0x71149dcf4b20bd8eULL, RapicornAidaTest::__AIDA_list_types__PureMethods, },
  { 0x3e0c1c388c4a51a1ULL, 0x5f146e2e050f17e1ULL, RapicornAidaTest::_$caller__PureMethods__pure_method, },
  { 0x3676f9f233fd36dcULL, 0x9fbf4b5b329f3621ULL, Other::__AIDA_list_types__NameTests, },
  { 0x211a5debfd86209cULL, 0x3ff87e4a8201e492ULL, Other::_$caller__NameTests__args_from_other_namespace, },
  { 0x31f198df574388e9ULL, 0xcf0b48010788bdd2ULL, BseTest::__AIDA_list_types__Compressor, },
  { 0x3ffc3dfaef875d63ULL, 0xf6f4d889560ba297ULL, BseTest::_$getter__Compressor__threshold, },
  { 0x2209f452a5de4de8ULL, 0x3fb166b528077900ULL, BseTest::_$setter__Compressor__threshold, },
  { 0x3415341ee86f2c05ULL, 0xe5f3f6787cc5e436ULL, BseTest::_$getter__Compressor__ratio, },
  { 0x21b70e21f75fec8bULL, 0xbf3ad9293c93d072ULL, BseTest::_$setter__Compressor__ratio, },
  { 0x3eb7a2dcce63f895ULL, 0x9370827685d22ef8ULL, BseTest::__AIDA_list_types__SoundModule, },
};
static Rapicorn::Aida::ServerConnection::MethodRegistry _aida_stub_registry (_aida_stub_entries);

} // BseTest


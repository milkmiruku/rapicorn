// --- Generated by AidaCxxStub ---
#ifndef __SRVT____testpass_idl
#define __SRVT____testpass_idl


// --- ServerHH Boilerplate ---
#include <rapicorn-core.hh>

#include <rapicorn-core.hh> // for rcore/signal.hh


#ifndef AIDA_CHECK
#define AIDA_CHECK(cond,errmsg) do { if (cond) break; Rapicorn::Aida::fatal_error (__FILE__, __LINE__, errmsg); } while (0)
#endif

namespace { // Anon
using Rapicorn::Aida::uint64;

namespace __AIDA_Local__ {
using namespace Rapicorn::Aida;

// types
typedef ServerConnection::EmitResultHandler EmitResultHandler;
typedef ServerConnection::MethodRegistry    MethodRegistry;
typedef ServerConnection::MethodEntry       MethodEntry;

static_assert (std::is_base_of<Rapicorn::Aida::ImplicitBase, Rapicorn::Aida::ImplicitBase>::value,
               "IDL interface base 'Rapicorn::Aida::ImplicitBase' must derive 'Rapicorn::Aida::ImplicitBase'");

// connection
static Rapicorn::Aida::ServerConnection *server_connection = NULL;

// EmitResultHandler
static inline void erhandler_add (size_t id, const EmitResultHandler &function)
{
  return server_connection->emit_result_handler_add (id, function);
}

// objects
template<class Target> static inline Target*
remote_handle_to_interface (const RemoteHandle &remote)
{
  Rapicorn::Aida::ImplicitBase *instance = server_connection->interface_from_handle (remote).get();
  return dynamic_cast<Target*> (instance);
}

template<class SMH> static inline SMH
interface_to_remote_handle (Rapicorn::Aida::ImplicitBase *ibase)
{
  SMH target;
  struct CastingServerConnection : ServerConnection { using ServerConnection::cast_interface_handle; };
  CastingServerConnection *cs_con = (CastingServerConnection*) server_connection;
  cs_con->cast_interface_handle (target, ibase ? ibase->shared_from_this() : ImplicitBaseP());
  return target;
}

template<class Target> static inline void
field_buffer_add_interface (Rapicorn::Aida::FieldBuffer &fb, Target *instance)
{
  server_connection->add_interface (fb, instance ? instance->shared_from_this() : ImplicitBaseP());
}

template<class Target> static inline std::shared_ptr<Target>
field_reader_pop_interface (Rapicorn::Aida::FieldReader &fr)
{
  return std::dynamic_pointer_cast<Target> (server_connection->pop_interface (fr));
}

// messages
static inline void
post_msg (FieldBuffer *fb)
{
  ObjectBroker::post_msg (fb);
}

static inline void
add_header1_discon (FieldBuffer &fb, size_t signal_handler_id, uint64 h, uint64 l)
{
  fb.add_header1 (Rapicorn::Aida::MSGID_DISCONNECT, ObjectBroker::connection_id_from_signal_handler_id (signal_handler_id), h, l);
}

static inline void
add_header1_emit (FieldBuffer &fb, size_t signal_handler_id, uint64 h, uint64 l)
{
  fb.add_header1 (Rapicorn::Aida::MSGID_EMIT_ONEWAY, ObjectBroker::connection_id_from_signal_handler_id (signal_handler_id), h, l);
}

static inline void
add_header2_emit (FieldBuffer &fb, size_t signal_handler_id, uint64 h, uint64 l)
{
  fb.add_header2 (Rapicorn::Aida::MSGID_EMIT_TWOWAY, ObjectBroker::connection_id_from_signal_handler_id (signal_handler_id),
                  server_connection->connection_id(), h, l);
}

static inline FieldBuffer*
new_call_result (FieldReader &fbr, uint64 h, uint64 l, uint32 n = 1)
{
  return FieldBuffer::renew_into_result (fbr, Rapicorn::Aida::MSGID_CALL_RESULT, ObjectBroker::sender_connection_id (fbr.field_buffer()->first_id()), h, l, n);
}

static inline FieldBuffer*
new_connect_result (FieldReader &fbr, uint64 h, uint64 l, uint32 n = 1)
{
  return FieldBuffer::renew_into_result (fbr, Rapicorn::Aida::MSGID_CONNECT_RESULT, ObjectBroker::sender_connection_id (fbr.field_buffer()->first_id()), h, l, n);
}

// slot
template<class SharedPtr, class R, class... Args> std::function<R (Args...)>
slot (SharedPtr sp, R (*fp) (const SharedPtr&, Args...))
{
  return [sp, fp] (Args... args) { return fp (sp, args...); };
}

} } // Anon::__AIDA_Local__

namespace Rapicorn { namespace Aida {
#ifndef RAPICORN_AIDA_OPERATOR_SHLEQ_FB_ANY
#define RAPICORN_AIDA_OPERATOR_SHLEQ_FB_ANY
// namespace Rapicorn::Aida needed for argument dependent lookups of the operators
static void operator<<= (Rapicorn::Aida::FieldBuffer &fb, const Rapicorn::Aida::Any &v) __attribute__ ((unused));
static void operator>>= (Rapicorn::Aida::FieldReader &fr, Rapicorn::Aida::Any &v) __attribute__ ((unused));
static void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const Rapicorn::Any &v)
{
  fb.add_any (v, *__AIDA_Local__::server_connection);
}
static void
operator>>= (Rapicorn::Aida::FieldReader &fr, Rapicorn::Any &v)
{
  v = fr.pop_any (*__AIDA_Local__::server_connection);
}
#endif // RAPICORN_AIDA_OPERATOR_SHLEQ_FB_ANY
} } // Rapicorn::Aida


#define __SRVT____testpass_idl__ENUMS

namespace MandatoryNamespace {

/// @cond GeneratedEnums
enum Enum1 {
  E1_A = 1,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum1  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum1 &e) { e = Enum1 (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum1c {
  E1C_A = 1,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum1c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum1c &e) { e = Enum1c (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum2  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum2 &e) { e = Enum2 (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum2c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum2c &e) { e = Enum2c (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum3  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum3 &e) { e = Enum3 (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum3c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum3c &e) { e = Enum3c (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4a  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4a &e) { e = Enum4a (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4b  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4b &e) { e = Enum4b (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4c  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4c &e) { e = Enum4c (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  Enum4d  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, Enum4d &e) { e = Enum4d (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  ExtensiveEnum  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, ExtensiveEnum &e) { e = ExtensiveEnum (frr.pop_evalue()); }
/// @endcond
} // MandatoryNamespace

namespace InterfaceTests {

/// @cond GeneratedEnums
enum QuickEnum {
  ZERO = 0,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  QuickEnum  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, QuickEnum &e) { e = QuickEnum (frr.pop_evalue()); }
/// @endcond
} // InterfaceTests

namespace RapicornAidaTest {

/// @cond GeneratedEnums
enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  ClickType  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, ClickType &e) { e = ClickType (frr.pop_evalue()); }
/// @endcond

/// @cond GeneratedEnums
enum MathExpressions {
  RESULT_2 = 2,
  RESULT_5 = 5,
  RESULT_8 = 8,
  RESULT_6 = 6,
  RESULT_7 = 7,
  RESULT_16 = 16,
  RESULT_3 = 3,
  RESULT_24 = 24,
  RESULT_13 = 13,
  RESULT_m2 = -2,
  RESULT_77 = 77,
  RESULT_511 = 511,
};
inline void operator<<= (Rapicorn::Aida::FieldBuffer &fb,  MathExpressions  e) { fb <<= Rapicorn::Aida::EnumValue (e); }
inline void operator>>= (Rapicorn::Aida::FieldReader &frr, MathExpressions &e) { e = MathExpressions (frr.pop_evalue()); }
/// @endcond
} // RapicornAidaTest

namespace Rapicorn {

namespace Aida {
template<> const EnumValue* enum_value_list<MandatoryNamespace::Enum1> ();
template<> const EnumValue* enum_value_list<MandatoryNamespace::Enum1c> ();
template<> const EnumValue* enum_value_list<MandatoryNamespace::Enum2> ();
template<> const EnumValue* enum_value_list<MandatoryNamespace::Enum2c> ();
template<> const EnumValue* enum_value_list<MandatoryNamespace::Enum3> ();
template<> const EnumValue* enum_value_list<MandatoryNamespace::Enum3c> ();
template<> const EnumValue* enum_value_list<MandatoryNamespace::Enum4a> ();
template<> const EnumValue* enum_value_list<MandatoryNamespace::Enum4b> ();
template<> const EnumValue* enum_value_list<MandatoryNamespace::Enum4c> ();
template<> const EnumValue* enum_value_list<MandatoryNamespace::Enum4d> ();
template<> const EnumValue* enum_value_list<MandatoryNamespace::ExtensiveEnum> ();
template<> const EnumValue* enum_value_list<InterfaceTests::QuickEnum> ();
template<> const EnumValue* enum_value_list<RapicornAidaTest::ClickType> ();
template<> const EnumValue* enum_value_list<RapicornAidaTest::MathExpressions> ();
} // Aida
} // Rapicorn

// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

class I_FirstInterfaceIface;
typedef std::shared_ptr<I_FirstInterfaceIface> I_FirstInterfaceIfaceP;
typedef std::weak_ptr  <I_FirstInterfaceIface> I_FirstInterfaceIfaceW;

/** @interface FirstInterface
 * See also the corresponding C++ servant class I_FirstInterfaceIface. */
/// See also the corresponding IDL class FirstInterface.
class I_FirstInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_FirstInterfaceIface ();
  virtual /*Des*/                       ~I_FirstInterfaceIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "MandatoryNamespace::FirstInterface"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          void_func             (); 	///< See FirstInterface::void_func()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_FirstInterfaceIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_FirstInterfaceIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_FirstInterfaceIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_FirstInterfaceIfaceP&);

struct SrvT_XFooRecord
{
  /// @cond GeneratedFields
  bool                          single_bool;
  int                           single_num;
  int64_t                       num64;
  double                        single_float;
  std::string                   single_string;
  int                           sibling1;
  int                           sibling2;
  int                           multi1;
  int                           multi2;
  int                           multi3;
  int                           multi4;
  ExtensiveEnum                 enum_field;
  I_FirstInterfaceIfaceP        iface1;
  I_FirstInterfaceIfaceP        iface2;
  I_FirstInterfaceIfaceP        iface3;
  Rapicorn::Aida::Any           any1;
  Rapicorn::Aida::Any           any2;
  Rapicorn::Aida::Any           any3;
  /// @endcond
  inline                        SrvT_XFooRecord () { single_bool = 0; single_num = 0; num64 = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::XFooRecord"; }
  bool                          operator==  (const SrvT_XFooRecord &other) const;
  bool                          operator!=  (const SrvT_XFooRecord &other) const { return !operator== (other); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_XFooRecord&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_XFooRecord&);

struct SrvT_XFooSequence : public std::vector<bool>
{
  typedef std::vector<bool> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::XFooSequence"; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_XFooSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_XFooSequence&);

struct SrvT_IntSequence : public std::vector<int>
{
  typedef std::vector<int> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::IntSequence"; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_IntSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_IntSequence&);

struct SrvT_FloatSequence : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::FloatSequence"; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_FloatSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_FloatSequence&);

struct SrvT_StringSequence : public std::vector<std::string>
{
  typedef std::vector<std::string> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::StringSequence"; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_StringSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_StringSequence&);

struct SrvT_ExtensiveEnumSequence : public std::vector<ExtensiveEnum>
{
  typedef std::vector<ExtensiveEnum> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::ExtensiveEnumSequence"; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_ExtensiveEnumSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_ExtensiveEnumSequence&);

struct SrvT_RecordSequence : public std::vector<SrvT_XFooRecord>
{
  typedef std::vector<SrvT_XFooRecord> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::RecordSequence"; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_RecordSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_RecordSequence&);

struct SrvT_SequenceSequence : public std::vector<SrvT_IntSequence>
{
  typedef std::vector<SrvT_IntSequence> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::SequenceSequence"; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_SequenceSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_SequenceSequence&);

struct SrvT_InterfaceSequence : public std::vector<I_FirstInterfaceIfaceP>
{
  typedef std::vector<I_FirstInterfaceIfaceP> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::InterfaceSequence"; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_InterfaceSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_InterfaceSequence&);

struct SrvT_AnySequence : public std::vector<Rapicorn::Aida::Any>
{
  typedef std::vector<Rapicorn::Aida::Any> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::AnySequence"; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_AnySequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_AnySequence&);

struct SrvT_NestedTypesRec
{
  /// @cond GeneratedFields
  SrvT_XFooRecord               rec;
  SrvT_XFooSequence             seq;
  /// @endcond
  inline                        SrvT_NestedTypesRec () { }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::NestedTypesRec"; }
  bool                          operator==  (const SrvT_NestedTypesRec &other) const;
  bool                          operator!=  (const SrvT_NestedTypesRec &other) const { return !operator== (other); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_NestedTypesRec&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_NestedTypesRec&);

struct SrvT_NestedTypesSeq : public std::vector<SrvT_NestedTypesRec>
{
  typedef std::vector<SrvT_NestedTypesRec> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::NestedTypesSeq"; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_NestedTypesSeq&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_NestedTypesSeq&);

struct SrvT_NewRecord
{
  /// @cond GeneratedFields
  int                           i;
  Enum1                         enum1;
  SrvT_XFooSequence             xfs;
  SrvT_NestedTypesRec           ntr;
  /// @endcond
  inline                        SrvT_NewRecord () { i = 0; enum1 = Enum1 (0); }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::NewRecord"; }
  bool                          operator==  (const SrvT_NewRecord &other) const;
  bool                          operator!=  (const SrvT_NewRecord &other) const { return !operator== (other); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_NewRecord&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_NewRecord&);

namespace Inner {

struct SrvT_InnerRecord
{
  /// @cond GeneratedFields
  int                           x;
  int                           y;
  SrvT_NewRecord                rec;
  /// @endcond
  inline                        SrvT_InnerRecord () { x = 0; y = 0; }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::Inner::InnerRecord"; }
  bool                          operator==  (const SrvT_InnerRecord &other) const;
  bool                          operator!=  (const SrvT_InnerRecord &other) const { return !operator== (other); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_InnerRecord&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_InnerRecord&);
} // Inner

struct SrvT_Refer2Inner
{
  /// @cond GeneratedFields
  Inner::SrvT_InnerRecord       r;
  /// @endcond
  inline                        SrvT_Refer2Inner () { }
  std::string                   __aida_type_name__ () const	{ return "MandatoryNamespace::Refer2Inner"; }
  bool                          operator==  (const SrvT_Refer2Inner &other) const;
  bool                          operator!=  (const SrvT_Refer2Inner &other) const { return !operator== (other); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_Refer2Inner&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_Refer2Inner&);
} // MandatoryNamespace

namespace OtherNamespace {

struct SrvT_SomeRecord
{
  /// @cond GeneratedFields
  MandatoryNamespace::SrvT_NewRecord r1;
  MandatoryNamespace::SrvT_NewRecord r2;
  MandatoryNamespace::Inner::SrvT_InnerRecord r3;
  MandatoryNamespace::Inner::SrvT_InnerRecord r4;
  /// @endcond
  inline                        SrvT_SomeRecord () { }
  std::string                   __aida_type_name__ () const	{ return "OtherNamespace::SomeRecord"; }
  bool                          operator==  (const SrvT_SomeRecord &other) const;
  bool                          operator!=  (const SrvT_SomeRecord &other) const { return !operator== (other); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_SomeRecord&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_SomeRecord&);
} // OtherNamespace

namespace Auxdata {

struct SrvT_RecordWithAuxdata
{
  /// @cond GeneratedFields
  bool                          aux_bool;
  int                           aux32;
  int64_t                       aux64;
  double                        auxf64;
  std::string                   aux_str;
  /// @endcond
  inline                        SrvT_RecordWithAuxdata () { aux_bool = 0; aux32 = 0; aux64 = 0; auxf64 = 0; }
  std::string                   __aida_type_name__ () const	{ return "Auxdata::RecordWithAuxdata"; }
  bool                          operator==  (const SrvT_RecordWithAuxdata &other) const;
  bool                          operator!=  (const SrvT_RecordWithAuxdata &other) const { return !operator== (other); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_RecordWithAuxdata&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_RecordWithAuxdata&);
} // Auxdata

namespace InterfaceTests {

class I_UIWidgetAreaIface;
typedef std::shared_ptr<I_UIWidgetAreaIface> I_UIWidgetAreaIfaceP;
typedef std::weak_ptr  <I_UIWidgetAreaIface> I_UIWidgetAreaIfaceW;

/** @interface UIWidgetArea
 * See also the corresponding C++ servant class I_UIWidgetAreaIface. */
/// See also the corresponding IDL class UIWidgetArea.
class I_UIWidgetAreaIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_UIWidgetAreaIface ();
  virtual /*Des*/                       ~I_UIWidgetAreaIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::UIWidgetArea"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual bool                          dummy    () const = 0; 	///< See UIWidgetArea::dummy
  virtual void                          dummy    (bool) = 0; 	///< See UIWidgetArea::dummy
  virtual std::string                   on_click () const = 0; 	///< See UIWidgetArea::on_click
  virtual void                          on_click (const std::string&) = 0; 	///< See UIWidgetArea::on_click
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_signal;
  typedef Rapicorn::Aida::AsyncSignal<double (I_UIWidgetAreaIface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double                        simple_method       (); 	///< See UIWidgetArea::simple_method()
  virtual double                        single_arg          (int n); 	///< See UIWidgetArea::single_arg()
  virtual double                        single_arg2         (int n = 5); 	///< See UIWidgetArea::single_arg2()
  virtual double                        two_args            (int n,
                                                             double r); 	///< See UIWidgetArea::two_args()
  virtual double                        two_args2           (int n = 6,
                                                             double r = 7.7); 	///< See UIWidgetArea::two_args2()
  virtual double                        multi_args          (bool b,
                                                             int64_t n,
                                                             double r,
                                                             int i,
                                                             const std::string &s = "String ding",
                                                             double y = 5); 	///< See UIWidgetArea::multi_args()
  virtual double                        self_method         (I_UIWidgetAreaIface &ba1,
                                                             I_UIWidgetAreaIface &ba2); 	///< See UIWidgetArea::self_method()
  virtual void                          void_method         (); 	///< See UIWidgetArea::void_method()
  virtual std::string                   on_click2out        (); 	///< See UIWidgetArea::on_click2out()
  virtual void                          on_click2in         (const std::string &command); 	///< See UIWidgetArea::on_click2in()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_UIWidgetAreaIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_UIWidgetAreaIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_UIWidgetAreaIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_UIWidgetAreaIfaceP&);

class I_ParentIface;
typedef std::shared_ptr<I_ParentIface> I_ParentIfaceP;
typedef std::weak_ptr  <I_ParentIface> I_ParentIfaceW;

/** @interface Parent
 * See also the corresponding C++ servant class I_ParentIface. */
/// See also the corresponding IDL class Parent.
class I_ParentIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_ParentIface ();
  virtual /*Des*/                       ~I_ParentIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::Parent"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ParentIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_ParentIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ParentIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ParentIfaceP&);

class I_ChildIface;
typedef std::shared_ptr<I_ChildIface> I_ChildIfaceP;
typedef std::weak_ptr  <I_ChildIface> I_ChildIfaceW;

/** @interface Child
 * See also the corresponding C++ servant class I_ChildIface. */
/// See also the corresponding IDL class Child.
class I_ChildIface : public virtual I_ParentIface
{
protected:
  explicit                               I_ChildIface ();
  virtual /*Des*/                       ~I_ChildIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::Child"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_ChildIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildIfaceP&);

class I_DescendantIface;
typedef std::shared_ptr<I_DescendantIface> I_DescendantIfaceP;
typedef std::weak_ptr  <I_DescendantIface> I_DescendantIfaceW;

/** @interface Descendant
 * See also the corresponding C++ servant class I_DescendantIface. */
/// See also the corresponding IDL class Descendant.
class I_DescendantIface : public virtual I_ChildIface
{
protected:
  explicit                               I_DescendantIface ();
  virtual /*Des*/                       ~I_DescendantIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::Descendant"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_DescendantIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_DescendantIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_DescendantIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_DescendantIfaceP&);

class I_GrandChildIface;
typedef std::shared_ptr<I_GrandChildIface> I_GrandChildIfaceP;
typedef std::weak_ptr  <I_GrandChildIface> I_GrandChildIfaceW;

/** @interface GrandChild
 * See also the corresponding C++ servant class I_GrandChildIface. */
/// See also the corresponding IDL class GrandChild.
class I_GrandChildIface : public virtual I_DescendantIface
{
protected:
  explicit                               I_GrandChildIface ();
  virtual /*Des*/                       ~I_GrandChildIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::GrandChild"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_GrandChildIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_GrandChildIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_GrandChildIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_GrandChildIfaceP&);

struct SrvT_QuickRecord
{
  /// @cond GeneratedFields
  int                           int1;
  int                           int2;
  /// @endcond
  inline                        SrvT_QuickRecord () { int1 = 0; int2 = 0; }
  std::string                   __aida_type_name__ () const	{ return "InterfaceTests::QuickRecord"; }
  bool                          operator==  (const SrvT_QuickRecord &other) const;
  bool                          operator!=  (const SrvT_QuickRecord &other) const { return !operator== (other); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_QuickRecord&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_QuickRecord&);

struct SrvT_QuickSequence : public std::vector<double>
{
  typedef std::vector<double> Sequence;
  reference append_back(); ///< Append data at the end, returns write reference to data.
  std::string                   __aida_type_name__ () const	{ return "InterfaceTests::QuickSequence"; }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_QuickSequence&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_QuickSequence&);

class I_QuickIfaceIface;
typedef std::shared_ptr<I_QuickIfaceIface> I_QuickIfaceIfaceP;
typedef std::weak_ptr  <I_QuickIfaceIface> I_QuickIfaceIfaceW;

/** @interface QuickIface
 * See also the corresponding C++ servant class I_QuickIfaceIface. */
/// See also the corresponding IDL class QuickIface.
class I_QuickIfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_QuickIfaceIface ();
  virtual /*Des*/                       ~I_QuickIfaceIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::QuickIface"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          simple_function   (int i = 9); 	///< See QuickIface::simple_function()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_QuickIfaceIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_QuickIfaceIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_QuickIfaceIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_QuickIfaceIfaceP&);

class I_MethodTestInterfaceIface;
typedef std::shared_ptr<I_MethodTestInterfaceIface> I_MethodTestInterfaceIfaceP;
typedef std::weak_ptr  <I_MethodTestInterfaceIface> I_MethodTestInterfaceIfaceW;

/** @interface MethodTestInterface
 * See also the corresponding C++ servant class I_MethodTestInterfaceIface. */
/// See also the corresponding IDL class MethodTestInterface.
class I_MethodTestInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_MethodTestInterfaceIface ();
  virtual /*Des*/                       ~I_MethodTestInterfaceIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::MethodTestInterface"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          method_with_void           (); 	///< See MethodTestInterface::method_with_void()
  virtual bool                          method_with_bools          (bool input,
                                                                    bool optval = 0); 	///< See MethodTestInterface::method_with_bools()
  virtual int                           method_with_ints32         (int input,
                                                                    int optval = -2); 	///< See MethodTestInterface::method_with_ints32()
  virtual int64_t                       method_with_ints64         (int64_t input,
                                                                    int64_t optval = 576460752303423488); 	///< See MethodTestInterface::method_with_ints64()
  virtual double                        method_with_floats         (double input,
                                                                    double optval = 309.9); 	///< See MethodTestInterface::method_with_floats()
  virtual std::string                   method_with_string         (const std::string &input,
                                                                    const std::string &optval = "default"); 	///< See MethodTestInterface::method_with_string()
  virtual QuickEnum                     method_with_enum           (QuickEnum input,
                                                                    QuickEnum optval = QuickEnum (0)); 	///< See MethodTestInterface::method_with_enum()
  virtual SrvT_QuickRecord              method_with_record         (const SrvT_QuickRecord &input,
                                                                    const SrvT_QuickRecord &optval = SrvT_QuickRecord()); 	///< See MethodTestInterface::method_with_record()
  virtual SrvT_QuickSequence            method_with_sequence       (const SrvT_QuickSequence &input,
                                                                    const SrvT_QuickSequence &optval = SrvT_QuickSequence()); 	///< See MethodTestInterface::method_with_sequence()
  virtual I_GrandChildIfaceP            method_with_interface      (I_GrandChildIface &input,
                                                                    I_GrandChildIface &optval = *(I_GrandChildIface*) NULL); 	///< See MethodTestInterface::method_with_interface()
  virtual Rapicorn::Aida::Any           method_with_anys           (const Rapicorn::Aida::Any &input,
                                                                    const Rapicorn::Aida::Any &optval); 	///< See MethodTestInterface::method_with_anys()
  virtual I_QuickIfaceIfaceP            method_with_quickiface     (I_QuickIfaceIface &input,
                                                                    I_QuickIfaceIface &iface0 = *(I_QuickIfaceIface*) NULL); 	///< See MethodTestInterface::method_with_quickiface()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_MethodTestInterfaceIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_MethodTestInterfaceIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_MethodTestInterfaceIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_MethodTestInterfaceIfaceP&);

class I_SignalTestInterfaceIface;
typedef std::shared_ptr<I_SignalTestInterfaceIface> I_SignalTestInterfaceIfaceP;
typedef std::weak_ptr  <I_SignalTestInterfaceIface> I_SignalTestInterfaceIfaceW;

/** @interface SignalTestInterface
 * See also the corresponding C++ servant class I_SignalTestInterfaceIface. */
/// See also the corresponding IDL class SignalTestInterface.
class I_SignalTestInterfaceIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_SignalTestInterfaceIface ();
  virtual /*Des*/                       ~I_SignalTestInterfaceIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::SignalTestInterface"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_result;
  typedef Rapicorn::Aida::AsyncSignal<bool ()> Signal_bool_result;
  typedef Rapicorn::Aida::AsyncSignal<int ()> Signal_int32_result;
  typedef Rapicorn::Aida::AsyncSignal<int64_t ()> Signal_int64_result;
  typedef Rapicorn::Aida::AsyncSignal<double ()> Signal_float64_result;
  typedef Rapicorn::Aida::AsyncSignal<std::string ()> Signal_string_result;
  typedef Rapicorn::Aida::AsyncSignal<QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Aida::AsyncSignal<SrvT_QuickRecord ()> Signal_record_result;
  typedef Rapicorn::Aida::AsyncSignal<SrvT_QuickSequence ()> Signal_sequence_result;
  typedef Rapicorn::Aida::AsyncSignal<I_GrandChildIfaceP ()> Signal_interface_result;
  typedef Rapicorn::Aida::AsyncSignal<Rapicorn::Aida::Any ()> Signal_any_result;
  typedef Rapicorn::Aida::AsyncSignal<I_SignalTestInterfaceIfaceP ()> Signal_self_result;
  typedef Rapicorn::Aida::Signal<void ()> Signal_void_arg;
  typedef Rapicorn::Aida::Signal<void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Aida::Signal<void (int i)> Signal_int32_arg;
  typedef Rapicorn::Aida::Signal<void (int64_t i)> Signal_int64_arg;
  typedef Rapicorn::Aida::Signal<void (double f)> Signal_float64_arg;
  typedef Rapicorn::Aida::Signal<void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Aida::Signal<void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Aida::Signal<void (const SrvT_QuickRecord &r)> Signal_record_arg;
  typedef Rapicorn::Aida::Signal<void (const SrvT_QuickSequence &s)> Signal_sequence_arg;
  typedef Rapicorn::Aida::Signal<void (I_GrandChildIface &i)> Signal_interface_arg;
  typedef Rapicorn::Aida::Signal<void (const Rapicorn::Aida::Any &a)> Signal_any_arg;
  typedef Rapicorn::Aida::Signal<void (I_SignalTestInterfaceIface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int32_result sig_int32_result;
  Signal_int64_result sig_int64_result;
  Signal_float64_result sig_float64_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_any_result sig_any_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int32_arg sig_int32_arg;
  Signal_int64_arg sig_int64_arg;
  Signal_float64_arg sig_float64_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_any_arg sig_any_arg;
  Signal_self_args sig_self_args;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SignalTestInterfaceIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_SignalTestInterfaceIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SignalTestInterfaceIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SignalTestInterfaceIfaceP&);

class I_ChildInheritingSignalsIface;
typedef std::shared_ptr<I_ChildInheritingSignalsIface> I_ChildInheritingSignalsIfaceP;
typedef std::weak_ptr  <I_ChildInheritingSignalsIface> I_ChildInheritingSignalsIfaceW;

/** @interface ChildInheritingSignals
 * See also the corresponding C++ servant class I_ChildInheritingSignalsIface. */
/// See also the corresponding IDL class ChildInheritingSignals.
class I_ChildInheritingSignalsIface : public virtual I_SignalTestInterfaceIface
{
protected:
  explicit                               I_ChildInheritingSignalsIface ();
  virtual /*Des*/                       ~I_ChildInheritingSignalsIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::ChildInheritingSignals"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  typedef Rapicorn::Aida::Signal<void (I_ChildInheritingSignalsIface &c, I_SignalTestInterfaceIface &p, const Rapicorn::Aida::Any &a, int i, const SrvT_QuickRecord &r, const SrvT_QuickSequence &s)> Signal_child_signal;
  Signal_child_signal sig_child_signal;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ChildInheritingSignalsIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_ChildInheritingSignalsIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildInheritingSignalsIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ChildInheritingSignalsIfaceP&);

class I_AnotherChildIface;
typedef std::shared_ptr<I_AnotherChildIface> I_AnotherChildIfaceP;
typedef std::weak_ptr  <I_AnotherChildIface> I_AnotherChildIfaceW;

/** @interface AnotherChild
 * See also the corresponding C++ servant class I_AnotherChildIface. */
/// See also the corresponding IDL class AnotherChild.
class I_AnotherChildIface : public virtual I_SignalTestInterfaceIface
{
protected:
  explicit                               I_AnotherChildIface ();
  virtual /*Des*/                       ~I_AnotherChildIface () override = 0;
public:
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::AnotherChild"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_AnotherChildIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_AnotherChildIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_AnotherChildIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_AnotherChildIfaceP&);

class I_PropertyTesterIface;
typedef std::shared_ptr<I_PropertyTesterIface> I_PropertyTesterIfaceP;
typedef std::weak_ptr  <I_PropertyTesterIface> I_PropertyTesterIfaceW;

/** @interface PropertyTester
 * See also the corresponding C++ servant class I_PropertyTesterIface. */
/// See also the corresponding IDL class PropertyTester.
class I_PropertyTesterIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_PropertyTesterIface ();
  virtual /*Des*/                       ~I_PropertyTesterIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "InterfaceTests::PropertyTester"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual bool                          bool_prop      () const = 0; 	///< See PropertyTester::bool_prop
  virtual void                          bool_prop      (bool) = 0; 	///< See PropertyTester::bool_prop
  virtual int                           int32_prop     () const = 0; 	///< See PropertyTester::int32_prop
  virtual void                          int32_prop     (int) = 0; 	///< See PropertyTester::int32_prop
  virtual int64_t                       int64_prop     () const = 0; 	///< See PropertyTester::int64_prop
  virtual void                          int64_prop     (int64_t) = 0; 	///< See PropertyTester::int64_prop
  virtual double                        float64_prop   () const = 0; 	///< See PropertyTester::float64_prop
  virtual void                          float64_prop   (double) = 0; 	///< See PropertyTester::float64_prop
  virtual std::string                   string_prop    () const = 0; 	///< See PropertyTester::string_prop
  virtual void                          string_prop    (const std::string&) = 0; 	///< See PropertyTester::string_prop
  virtual QuickEnum                     enum_prop      () const = 0; 	///< See PropertyTester::enum_prop
  virtual void                          enum_prop      (QuickEnum) = 0; 	///< See PropertyTester::enum_prop
  virtual SrvT_QuickRecord              record_prop    () const = 0; 	///< See PropertyTester::record_prop
  virtual void                          record_prop    (const SrvT_QuickRecord&) = 0; 	///< See PropertyTester::record_prop
  virtual SrvT_QuickSequence            sequence_prop  () const = 0; 	///< See PropertyTester::sequence_prop
  virtual void                          sequence_prop  (const SrvT_QuickSequence&) = 0; 	///< See PropertyTester::sequence_prop
  virtual I_GrandChildIfaceP            interface_prop () const = 0; 	///< See PropertyTester::interface_prop
  virtual void                          interface_prop (I_GrandChildIface*) = 0; 	///< See PropertyTester::interface_prop
  virtual I_PropertyTesterIfaceP        self_prop      () const = 0; 	///< See PropertyTester::self_prop
  virtual void                          self_prop      (I_PropertyTesterIface*) = 0; 	///< See PropertyTester::self_prop
  virtual Rapicorn::Aida::Any           any_prop       () const = 0; 	///< See PropertyTester::any_prop
  virtual void                          any_prop       (const Rapicorn::Aida::Any&) = 0; 	///< See PropertyTester::any_prop
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PropertyTesterIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_PropertyTesterIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PropertyTesterIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PropertyTesterIfaceP&);
} // InterfaceTests

namespace RapicornAidaTest {

class I_ButtonAreaIface;
typedef std::shared_ptr<I_ButtonAreaIface> I_ButtonAreaIfaceP;
typedef std::weak_ptr  <I_ButtonAreaIface> I_ButtonAreaIfaceW;

/** @interface ButtonArea
 * See also the corresponding C++ servant class I_ButtonAreaIface. */
/// See also the corresponding IDL class ButtonArea.
class I_ButtonAreaIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_ButtonAreaIface ();
  virtual /*Des*/                       ~I_ButtonAreaIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "RapicornAidaTest::ButtonArea"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual std::string                   on_click   () const = 0; 	///< See ButtonArea::on_click
  virtual void                          on_click   (const std::string&) = 0; 	///< See ButtonArea::on_click
  virtual std::string                   on_click2  () const = 0; 	///< See ButtonArea::on_click2
  virtual void                          on_click2  (const std::string&) = 0; 	///< See ButtonArea::on_click2
  virtual std::string                   on_click3  () const = 0; 	///< See ButtonArea::on_click3
  virtual void                          on_click3  (const std::string&) = 0; 	///< See ButtonArea::on_click3
  virtual ClickType                     click_type () const = 0; 	///< See ButtonArea::click_type
  virtual void                          click_type (ClickType) = 0; 	///< See ButtonArea::click_type
  typedef Rapicorn::Aida::AsyncSignal<bool ()> Signal_check_activate;
  typedef Rapicorn::Aida::Signal<void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_ButtonAreaIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_ButtonAreaIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ButtonAreaIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_ButtonAreaIfaceP&);

class I_PureMethodsIface;
typedef std::shared_ptr<I_PureMethodsIface> I_PureMethodsIfaceP;
typedef std::weak_ptr  <I_PureMethodsIface> I_PureMethodsIfaceW;


class I_PureMethodsIface;
typedef std::shared_ptr<I_PureMethodsIface> I_PureMethodsIfaceP;
typedef std::weak_ptr  <I_PureMethodsIface> I_PureMethodsIfaceW;

/** @interface PureMethods
 * See also the corresponding C++ servant class I_PureMethodsIface. */
/// See also the corresponding IDL class PureMethods.
class I_PureMethodsIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_PureMethodsIface ();
  virtual /*Des*/                       ~I_PureMethodsIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "RapicornAidaTest::PureMethods"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual int                           pure_method        (double f) = 0; 	///< See PureMethods::pure_method()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_PureMethodsIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_PureMethodsIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PureMethodsIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_PureMethodsIfaceP&);
} // RapicornAidaTest

namespace Other {

class I_NameTestsIface;
typedef std::shared_ptr<I_NameTestsIface> I_NameTestsIfaceP;
typedef std::weak_ptr  <I_NameTestsIface> I_NameTestsIfaceW;

/** @interface NameTests
 * See also the corresponding C++ servant class I_NameTestsIface. */
/// See also the corresponding IDL class NameTests.
class I_NameTestsIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_NameTestsIface ();
  virtual /*Des*/                       ~I_NameTestsIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "Other::NameTests"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual void                          args_from_other_namespace (const InterfaceTests::SrvT_QuickRecord &qr,
                                                                   RapicornAidaTest::ClickType qe,
                                                                   const OtherNamespace::SrvT_SomeRecord &sr); 	///< See NameTests::args_from_other_namespace()
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_NameTestsIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_NameTestsIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_NameTestsIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_NameTestsIfaceP&);
} // Other

namespace BseTest {

class I_CompressorIface;
typedef std::shared_ptr<I_CompressorIface> I_CompressorIfaceP;
typedef std::weak_ptr  <I_CompressorIface> I_CompressorIfaceW;

/** @interface Compressor
 * See also the corresponding C++ servant class I_CompressorIface. */
/// See also the corresponding IDL class Compressor.
class I_CompressorIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_CompressorIface ();
  virtual /*Des*/                       ~I_CompressorIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "BseTest::Compressor"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
  virtual double                        threshold () const = 0; 	///< See Compressor::threshold
  virtual void                          threshold (double) = 0; 	///< See Compressor::threshold
  virtual double                        ratio     () const = 0; 	///< See Compressor::ratio
  virtual void                          ratio     (double) = 0; 	///< See Compressor::ratio
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_CompressorIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_CompressorIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_CompressorIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_CompressorIfaceP&);

struct SrvT_RecordForGroups
{
  /// @cond GeneratedFields
  int                           i;
  double                        ratio;
  bool                          ordinary_bool;
  double                        threshold1;
  double                        threshold2;
  /// @endcond
  inline                        SrvT_RecordForGroups () { i = 0; ratio = 0; ordinary_bool = 0; threshold1 = 0; threshold2 = 0; }
  std::string                   __aida_type_name__ () const	{ return "BseTest::RecordForGroups"; }
  bool                          operator==  (const SrvT_RecordForGroups &other) const;
  bool                          operator!=  (const SrvT_RecordForGroups &other) const { return !operator== (other); }
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, const SrvT_RecordForGroups&);
void operator>>= (Rapicorn::Aida::FieldReader&, SrvT_RecordForGroups&);

class I_SoundModuleIface;
typedef std::shared_ptr<I_SoundModuleIface> I_SoundModuleIfaceP;
typedef std::weak_ptr  <I_SoundModuleIface> I_SoundModuleIfaceW;

/** @interface SoundModule
 * See also the corresponding C++ servant class I_SoundModuleIface. */
/// See also the corresponding IDL class SoundModule.
class I_SoundModuleIface : public virtual Rapicorn::Aida::ImplicitBase
{
protected:
  explicit                               I_SoundModuleIface ();
  virtual /*Des*/                       ~I_SoundModuleIface () override = 0;
public:
  static Rapicorn::Aida::BaseConnection* __aida_connection__();
  virtual Rapicorn::Aida::TypeHashList   __aida_typelist__  () const override;
  virtual std::string                    __aida_type_name__ () const override	{ return "BseTest::SoundModule"; }
  virtual const Rapicorn::Aida::PropertyList& __aida_properties__ ();
};
void operator<<= (Rapicorn::Aida::FieldBuffer&, I_SoundModuleIface*);
void operator<<= (Rapicorn::Aida::FieldBuffer&, const I_SoundModuleIfaceP&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SoundModuleIface*&);
void operator>>= (Rapicorn::Aida::FieldReader&, I_SoundModuleIfaceP&);
} // BseTest

#define __testpass_idl_INTERFACE_LIST \
	  __testpass_idl_INTERFACE_NAME (MandatoryNamespace::FirstInterface) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::UIWidgetArea) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::Parent) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::Child) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::Descendant) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::GrandChild) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::QuickIface) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::MethodTestInterface) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::SignalTestInterface) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::ChildInheritingSignals) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::AnotherChild) \
	  __testpass_idl_INTERFACE_NAME (InterfaceTests::PropertyTester) \
	  __testpass_idl_INTERFACE_NAME (RapicornAidaTest::ButtonArea) \
	  __testpass_idl_INTERFACE_NAME (RapicornAidaTest::PureMethods) \
	  __testpass_idl_INTERFACE_NAME (Other::NameTests) \
	  __testpass_idl_INTERFACE_NAME (BseTest::Compressor) \
	  __testpass_idl_INTERFACE_NAME (BseTest::SoundModule)

// --- Implementations ---

namespace MandatoryNamespace {

I_FirstInterfaceIface::I_FirstInterfaceIface ()
{}
I_FirstInterfaceIface::~I_FirstInterfaceIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_FirstInterfaceIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_FirstInterfaceIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_FirstInterfaceIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_FirstInterfaceIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_FirstInterfaceIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_FirstInterfaceIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_FirstInterfaceIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_FirstInterfaceIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0x22113f623903ac14ULL, 0x3fe8e50c1a9a78d2ULL)); // FirstInterface
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_FirstInterfaceIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}
bool
SrvT_XFooRecord::operator== (const SrvT_XFooRecord &other) const
{
  if (this->single_bool != other.single_bool) return false;
  if (this->single_num != other.single_num) return false;
  if (this->num64 != other.num64) return false;
  if (this->single_float != other.single_float) return false;
  if (this->single_string != other.single_string) return false;
  if (this->sibling1 != other.sibling1) return false;
  if (this->sibling2 != other.sibling2) return false;
  if (this->multi1 != other.multi1) return false;
  if (this->multi2 != other.multi2) return false;
  if (this->multi3 != other.multi3) return false;
  if (this->multi4 != other.multi4) return false;
  if (this->enum_field != other.enum_field) return false;
  if (this->iface1 != other.iface1) return false;
  if (this->iface2 != other.iface2) return false;
  if (this->iface3 != other.iface3) return false;
  if (this->any1 != other.any1) return false;
  if (this->any2 != other.any2) return false;
  if (this->any3 != other.any3) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_XFooRecord &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (18);
  fb <<= self.single_bool;
  fb <<= self.single_num;
  fb <<= self.num64;
  fb <<= self.single_float;
  fb <<= self.single_string;
  fb <<= self.sibling1;
  fb <<= self.sibling2;
  fb <<= self.multi1;
  fb <<= self.multi2;
  fb <<= self.multi3;
  fb <<= self.multi4;
  fb <<= self.enum_field;
  fb <<= self.iface1;
  fb <<= self.iface2;
  fb <<= self.iface3;
  fb <<= self.any1;
  fb <<= self.any2;
  fb <<= self.any3;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_XFooRecord &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 18) return;
  fbr >>= self.single_bool;
  fbr >>= self.single_num;
  fbr >>= self.num64;
  fbr >>= self.single_float;
  fbr >>= self.single_string;
  fbr >>= self.sibling1;
  fbr >>= self.sibling2;
  fbr >>= self.multi1;
  fbr >>= self.multi2;
  fbr >>= self.multi3;
  fbr >>= self.multi4;
  fbr >>= self.enum_field;
  fbr >>= self.iface1;
  fbr >>= self.iface2;
  fbr >>= self.iface3;
  fbr >>= self.any1;
  fbr >>= self.any2;
  fbr >>= self.any3;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_XFooSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_XFooSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SrvT_XFooSequence::reference
SrvT_XFooSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_IntSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_IntSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SrvT_IntSequence::reference
SrvT_IntSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_FloatSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_FloatSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SrvT_FloatSequence::reference
SrvT_FloatSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_StringSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_StringSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SrvT_StringSequence::reference
SrvT_StringSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_ExtensiveEnumSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_ExtensiveEnumSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SrvT_ExtensiveEnumSequence::reference
SrvT_ExtensiveEnumSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_RecordSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_RecordSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SrvT_RecordSequence::reference
SrvT_RecordSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_SequenceSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_SequenceSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SrvT_SequenceSequence::reference
SrvT_SequenceSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_InterfaceSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_InterfaceSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SrvT_InterfaceSequence::reference
SrvT_InterfaceSequence::append_back()
{
  resize (size() + 1);
  return back();
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_AnySequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_AnySequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SrvT_AnySequence::reference
SrvT_AnySequence::append_back()
{
  resize (size() + 1);
  return back();
}
bool
SrvT_NestedTypesRec::operator== (const SrvT_NestedTypesRec &other) const
{
  if (this->rec != other.rec) return false;
  if (this->seq != other.seq) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_NestedTypesRec &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (2);
  fb <<= self.rec;
  fb <<= self.seq;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_NestedTypesRec &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >>= self.rec;
  fbr >>= self.seq;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_NestedTypesSeq &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_NestedTypesSeq &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SrvT_NestedTypesSeq::reference
SrvT_NestedTypesSeq::append_back()
{
  resize (size() + 1);
  return back();
}
bool
SrvT_NewRecord::operator== (const SrvT_NewRecord &other) const
{
  if (this->i != other.i) return false;
  if (this->enum1 != other.enum1) return false;
  if (this->xfs != other.xfs) return false;
  if (this->ntr != other.ntr) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_NewRecord &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (4);
  fb <<= self.i;
  fb <<= self.enum1;
  fb <<= self.xfs;
  fb <<= self.ntr;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_NewRecord &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >>= self.i;
  fbr >>= self.enum1;
  fbr >>= self.xfs;
  fbr >>= self.ntr;
}

namespace Inner {
bool
SrvT_InnerRecord::operator== (const SrvT_InnerRecord &other) const
{
  if (this->x != other.x) return false;
  if (this->y != other.y) return false;
  if (this->rec != other.rec) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_InnerRecord &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (3);
  fb <<= self.x;
  fb <<= self.y;
  fb <<= self.rec;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_InnerRecord &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 3) return;
  fbr >>= self.x;
  fbr >>= self.y;
  fbr >>= self.rec;
}
} // Inner
bool
SrvT_Refer2Inner::operator== (const SrvT_Refer2Inner &other) const
{
  if (this->r != other.r) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_Refer2Inner &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (1);
  fb <<= self.r;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_Refer2Inner &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 1) return;
  fbr >>= self.r;
}
} // MandatoryNamespace

namespace OtherNamespace {
bool
SrvT_SomeRecord::operator== (const SrvT_SomeRecord &other) const
{
  if (this->r1 != other.r1) return false;
  if (this->r2 != other.r2) return false;
  if (this->r3 != other.r3) return false;
  if (this->r4 != other.r4) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_SomeRecord &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (4);
  fb <<= self.r1;
  fb <<= self.r2;
  fb <<= self.r3;
  fb <<= self.r4;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_SomeRecord &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >>= self.r1;
  fbr >>= self.r2;
  fbr >>= self.r3;
  fbr >>= self.r4;
}
} // OtherNamespace

namespace Auxdata {
bool
SrvT_RecordWithAuxdata::operator== (const SrvT_RecordWithAuxdata &other) const
{
  if (this->aux_bool != other.aux_bool) return false;
  if (this->aux32 != other.aux32) return false;
  if (this->aux64 != other.aux64) return false;
  if (this->auxf64 != other.auxf64) return false;
  if (this->aux_str != other.aux_str) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_RecordWithAuxdata &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (5);
  fb <<= self.aux_bool;
  fb <<= self.aux32;
  fb <<= self.aux64;
  fb <<= self.auxf64;
  fb <<= self.aux_str;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_RecordWithAuxdata &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 5) return;
  fbr >>= self.aux_bool;
  fbr >>= self.aux32;
  fbr >>= self.aux64;
  fbr >>= self.auxf64;
  fbr >>= self.aux_str;
}
} // Auxdata

namespace InterfaceTests {

I_UIWidgetAreaIface::I_UIWidgetAreaIface ()
{}
I_UIWidgetAreaIface::~I_UIWidgetAreaIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_UIWidgetAreaIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_UIWidgetAreaIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_UIWidgetAreaIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_UIWidgetAreaIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_UIWidgetAreaIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_UIWidgetAreaIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_UIWidgetAreaIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_UIWidgetAreaIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0x11db82aaba1ee248ULL, 0xd2359653ff87e972ULL)); // UIWidgetArea
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_UIWidgetAreaIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    RAPICORN_AIDA_PROPERTY (I_UIWidgetAreaIface, dummy, "dummy", "", "rw"),
    RAPICORN_AIDA_PROPERTY (I_UIWidgetAreaIface, on_click, _("On CLick"), _("Command on button1 click"), "rw"),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}

I_ParentIface::I_ParentIface ()
{}
I_ParentIface::~I_ParentIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_ParentIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ParentIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ParentIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_ParentIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ParentIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_ParentIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_ParentIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_ParentIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_ParentIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}

I_ChildIface::I_ChildIface ()
{}
I_ChildIface::~I_ChildIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_ChildIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ChildIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ChildIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_ChildIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ChildIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_ChildIface> (fbr).get();
}
Rapicorn::Aida::TypeHashList
I_ChildIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0xacf30fad3093ffcdULL, 0x4d8c65c035fba090ULL)); // Child
  thl.push_back (Rapicorn::Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_ChildIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_ParentIface::__aida_properties__());
  return property_list;
}

I_DescendantIface::I_DescendantIface ()
{}
I_DescendantIface::~I_DescendantIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_DescendantIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_DescendantIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_DescendantIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_DescendantIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_DescendantIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_DescendantIface> (fbr).get();
}
Rapicorn::Aida::TypeHashList
I_DescendantIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0x846a6876889dd896ULL, 0xbe521465806f3d42ULL)); // Descendant
  thl.push_back (Rapicorn::Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
  thl.push_back (Rapicorn::Aida::TypeHash (0xacf30fad3093ffcdULL, 0x4d8c65c035fba090ULL)); // Child
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_DescendantIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_ChildIface::__aida_properties__());
  return property_list;
}

I_GrandChildIface::I_GrandChildIface ()
{}
I_GrandChildIface::~I_GrandChildIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_GrandChildIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_GrandChildIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_GrandChildIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_GrandChildIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_GrandChildIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_GrandChildIface> (fbr).get();
}
Rapicorn::Aida::TypeHashList
I_GrandChildIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0xf6975e5e92250718ULL, 0x53730d44919c46f9ULL)); // GrandChild
  thl.push_back (Rapicorn::Aida::TypeHash (0xf3967d3ac61708d2ULL, 0x4043a82003ee6f1eULL)); // Parent
  thl.push_back (Rapicorn::Aida::TypeHash (0xacf30fad3093ffcdULL, 0x4d8c65c035fba090ULL)); // Child
  thl.push_back (Rapicorn::Aida::TypeHash (0x846a6876889dd896ULL, 0xbe521465806f3d42ULL)); // Descendant
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_GrandChildIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_DescendantIface::__aida_properties__());
  return property_list;
}
bool
SrvT_QuickRecord::operator== (const SrvT_QuickRecord &other) const
{
  if (this->int1 != other.int1) return false;
  if (this->int2 != other.int2) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_QuickRecord &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (2);
  fb <<= self.int1;
  fb <<= self.int2;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_QuickRecord &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >>= self.int1;
  fbr >>= self.int2;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_QuickSequence &self)
{
  const size_t len = self.size();
  Rapicorn::Aida::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb <<= self[k];
  }
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_QuickSequence &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >>= self[k];
  }
}
SrvT_QuickSequence::reference
SrvT_QuickSequence::append_back()
{
  resize (size() + 1);
  return back();
}

I_QuickIfaceIface::I_QuickIfaceIface ()
{}
I_QuickIfaceIface::~I_QuickIfaceIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_QuickIfaceIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_QuickIfaceIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_QuickIfaceIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_QuickIfaceIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_QuickIfaceIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_QuickIfaceIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_QuickIfaceIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_QuickIfaceIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0x4524ee119d4e454cULL, 0xbeb61f7c3cc04f7dULL)); // QuickIface
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_QuickIfaceIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}

I_MethodTestInterfaceIface::I_MethodTestInterfaceIface ()
{}
I_MethodTestInterfaceIface::~I_MethodTestInterfaceIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_MethodTestInterfaceIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_MethodTestInterfaceIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_MethodTestInterfaceIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_MethodTestInterfaceIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_MethodTestInterfaceIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_MethodTestInterfaceIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_MethodTestInterfaceIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_MethodTestInterfaceIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0x6bf684458ac5f01aULL, 0xf64c02611b807180ULL)); // MethodTestInterface
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_MethodTestInterfaceIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}

I_SignalTestInterfaceIface::I_SignalTestInterfaceIface ()
{}
I_SignalTestInterfaceIface::~I_SignalTestInterfaceIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_SignalTestInterfaceIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_SignalTestInterfaceIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_SignalTestInterfaceIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_SignalTestInterfaceIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_SignalTestInterfaceIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_SignalTestInterfaceIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_SignalTestInterfaceIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_SignalTestInterfaceIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0x2873064ee22c0249ULL, 0xd8fae6f300b8e408ULL)); // SignalTestInterface
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_SignalTestInterfaceIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}

I_ChildInheritingSignalsIface::I_ChildInheritingSignalsIface ()
{}
I_ChildInheritingSignalsIface::~I_ChildInheritingSignalsIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_ChildInheritingSignalsIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ChildInheritingSignalsIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ChildInheritingSignalsIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_ChildInheritingSignalsIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ChildInheritingSignalsIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_ChildInheritingSignalsIface> (fbr).get();
}
Rapicorn::Aida::TypeHashList
I_ChildInheritingSignalsIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0xf20ff30241b5b694ULL, 0x9f544b2626e183f0ULL)); // ChildInheritingSignals
  thl.push_back (Rapicorn::Aida::TypeHash (0x2873064ee22c0249ULL, 0xd8fae6f300b8e408ULL)); // SignalTestInterface
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_ChildInheritingSignalsIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_SignalTestInterfaceIface::__aida_properties__());
  return property_list;
}

I_AnotherChildIface::I_AnotherChildIface ()
{}
I_AnotherChildIface::~I_AnotherChildIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_AnotherChildIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_AnotherChildIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_AnotherChildIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_AnotherChildIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_AnotherChildIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_AnotherChildIface> (fbr).get();
}
Rapicorn::Aida::TypeHashList
I_AnotherChildIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0x9a33af1b27f7e36dULL, 0xdf625f7bd18934faULL)); // AnotherChild
  thl.push_back (Rapicorn::Aida::TypeHash (0x2873064ee22c0249ULL, 0xd8fae6f300b8e408ULL)); // SignalTestInterface
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_AnotherChildIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, I_SignalTestInterfaceIface::__aida_properties__());
  return property_list;
}

I_PropertyTesterIface::I_PropertyTesterIface ()
{}
I_PropertyTesterIface::~I_PropertyTesterIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_PropertyTesterIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_PropertyTesterIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_PropertyTesterIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_PropertyTesterIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_PropertyTesterIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_PropertyTesterIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_PropertyTesterIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_PropertyTesterIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0xa37ab462c55a3b3cULL, 0x4f3fd1c9ad9689fbULL)); // PropertyTester
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_PropertyTesterIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    RAPICORN_AIDA_PROPERTY (I_PropertyTesterIface, bool_prop, "bool_prop", "", "rw"),
    RAPICORN_AIDA_PROPERTY (I_PropertyTesterIface, int32_prop, "int32_prop", "", INT32_MIN, INT32_MAX, 1, "rw"),
    RAPICORN_AIDA_PROPERTY (I_PropertyTesterIface, int64_prop, "int64_prop", "", INT64_MIN, INT64_MAX, 1, "rw"),
    RAPICORN_AIDA_PROPERTY (I_PropertyTesterIface, float64_prop, "float64_prop", "", DBL_MIN, DBL_MAX, 0, "rw"),
    RAPICORN_AIDA_PROPERTY (I_PropertyTesterIface, string_prop, "string_prop", "", "rw"),
    RAPICORN_AIDA_PROPERTY (I_PropertyTesterIface, enum_prop, "enum_prop", "", "rw"),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTesterIface, record_prop, "record_prop", "", "rw"),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTesterIface, sequence_prop, "sequence_prop", "", "rw"),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTesterIface, interface_prop, "interface_prop", "", "rw"),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTesterIface, self_prop, "self_prop", "", "rw"),
    // RAPICORN_AIDA_PROPERTY (I_PropertyTesterIface, any_prop, "any_prop", "", "rw"),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}
} // InterfaceTests

namespace RapicornAidaTest {

I_ButtonAreaIface::I_ButtonAreaIface ()
{}
I_ButtonAreaIface::~I_ButtonAreaIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_ButtonAreaIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_ButtonAreaIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ButtonAreaIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_ButtonAreaIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_ButtonAreaIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_ButtonAreaIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_ButtonAreaIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_ButtonAreaIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0xec371b296fa57436ULL, 0x92e4310e386fc92eULL)); // ButtonArea
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_ButtonAreaIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    RAPICORN_AIDA_PROPERTY (I_ButtonAreaIface, on_click, "on_click", "", "rw"),
    RAPICORN_AIDA_PROPERTY (I_ButtonAreaIface, on_click2, "on_click2", "", "rw"),
    RAPICORN_AIDA_PROPERTY (I_ButtonAreaIface, on_click3, "on_click3", "", "rw"),
    RAPICORN_AIDA_PROPERTY (I_ButtonAreaIface, click_type, "click_type", "", "rw"),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}

I_PureMethodsIface::I_PureMethodsIface ()
{}
I_PureMethodsIface::~I_PureMethodsIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_PureMethodsIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_PureMethodsIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_PureMethodsIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_PureMethodsIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_PureMethodsIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_PureMethodsIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_PureMethodsIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_PureMethodsIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0xddc2a514d04d3af5ULL, 0xc0046740434c0486ULL)); // PureMethods
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_PureMethodsIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}
} // RapicornAidaTest

namespace Other {

I_NameTestsIface::I_NameTestsIface ()
{}
I_NameTestsIface::~I_NameTestsIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_NameTestsIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_NameTestsIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_NameTestsIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_NameTestsIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_NameTestsIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_NameTestsIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_NameTestsIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_NameTestsIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0x542d40cd7d8fcd40ULL, 0x8c1782df29c9b936ULL)); // NameTests
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_NameTestsIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}
} // Other

namespace BseTest {

I_CompressorIface::I_CompressorIface ()
{}
I_CompressorIface::~I_CompressorIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_CompressorIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_CompressorIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_CompressorIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_CompressorIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_CompressorIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_CompressorIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_CompressorIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_CompressorIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0x42057a05d51182dfULL, 0x6a0d69cda274433eULL)); // Compressor
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_CompressorIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
    RAPICORN_AIDA_PROPERTY (I_CompressorIface, threshold, "", "", DBL_MIN, DBL_MAX, 0, "w"),
    RAPICORN_AIDA_PROPERTY (I_CompressorIface, ratio, "", "", DBL_MIN, DBL_MAX, 0, "w"),
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}
bool
SrvT_RecordForGroups::operator== (const SrvT_RecordForGroups &other) const
{
  if (this->i != other.i) return false;
  if (this->ratio != other.ratio) return false;
  if (this->ordinary_bool != other.ordinary_bool) return false;
  if (this->threshold1 != other.threshold1) return false;
  if (this->threshold2 != other.threshold2) return false;
  return true;
}
inline void __attribute__ ((used))
operator<<= (Rapicorn::Aida::FieldBuffer &dst, const SrvT_RecordForGroups &self)
{
  Rapicorn::Aida::FieldBuffer &fb = dst.add_rec (5);
  fb <<= self.i;
  fb <<= self.ratio;
  fb <<= self.ordinary_bool;
  fb <<= self.threshold1;
  fb <<= self.threshold2;
}
inline void __attribute__ ((used))
operator>>= (Rapicorn::Aida::FieldReader &src, SrvT_RecordForGroups &self)
{
  Rapicorn::Aida::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 5) return;
  fbr >>= self.i;
  fbr >>= self.ratio;
  fbr >>= self.ordinary_bool;
  fbr >>= self.threshold1;
  fbr >>= self.threshold2;
}

I_SoundModuleIface::I_SoundModuleIface ()
{}
I_SoundModuleIface::~I_SoundModuleIface ()
{} // define empty dtor to emit vtable
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, const I_SoundModuleIfaceP &ptr)
{
  fb <<= ptr.get();
}
void
operator<<= (Rapicorn::Aida::FieldBuffer &fb, I_SoundModuleIface *obj)
{
  __AIDA_Local__::field_buffer_add_interface (fb, obj);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_SoundModuleIfaceP &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_SoundModuleIface> (fbr);
}
void
operator>>= (Rapicorn::Aida::FieldReader &fbr, I_SoundModuleIface* &obj)
{
  obj = __AIDA_Local__::field_reader_pop_interface<I_SoundModuleIface> (fbr).get();
}
Rapicorn::Aida::BaseConnection*
I_SoundModuleIface::__aida_connection__()
{
  return ::Rapicorn::Aida::ObjectBroker::get_server_connection (__AIDA_Local__::server_connection);
}
Rapicorn::Aida::TypeHashList
I_SoundModuleIface::__aida_typelist__ () const
{
  Rapicorn::Aida::TypeHashList thl;
  thl.push_back (Rapicorn::Aida::TypeHash (0x06447b38b51e0198ULL, 0x848669199cc311deULL)); // SoundModule
  return thl;
}
const Rapicorn::Aida::PropertyList&
I_SoundModuleIface::__aida_properties__ ()
{
  static Rapicorn::Aida::PropertyList::Property *properties[] = {
  };
  static const Rapicorn::Aida::PropertyList property_list (properties, Rapicorn::Aida::ImplicitBase::__aida_properties__());
  return property_list;
}

// --- Method Dispatchers & Registry ---
} // BseTest

namespace MandatoryNamespace {
static Rapicorn::Aida::FieldBuffer*
__aida_call__FirstInterface____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_FirstInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x3080ed132845bb88ULL, 0x1ccc8bdb4dc51a6fULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__FirstInterface__void_func (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 0);
  I_FirstInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  self->void_func ();
  return NULL;
}


namespace Inner {
} // Inner
} // MandatoryNamespace

namespace OtherNamespace {
} // OtherNamespace

namespace Auxdata {
} // Auxdata

namespace InterfaceTests {
static Rapicorn::Aida::FieldBuffer*
__aida_call__UIWidgetArea____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xc7c8bc238ce4501cULL, 0xd5b65cb502c0eb4cULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__UIWidgetArea__dummy (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  bool rval = self->dummy ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xf67db704b9d460d6ULL, 0xd4950feab697e61eULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__UIWidgetArea__dummy (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  bool  arg_dummy;
  fbr >>= arg_dummy;
  self->dummy (arg_dummy);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__UIWidgetArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string rval = self->on_click ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x58ba68f6b64584c9ULL, 0xa7d2686edb40f27aULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__UIWidgetArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string  arg_on_click;
  fbr >>= arg_on_click;
  self->on_click (arg_on_click);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__UIWidgetArea__simple_method (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 0);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  double rval = self->simple_method ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xd0dd4c08ba5022c0ULL, 0xb1af31ca1ec7037aULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__UIWidgetArea__single_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  int  arg_n;
  fbr >>= arg_n;
  double rval = self->single_arg (arg_n);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xe4e890540b4c0579ULL, 0xe14a7ffaa82f1c4fULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__UIWidgetArea__single_arg2 (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  int  arg_n;
  fbr >>= arg_n;
  double rval = self->single_arg2 (arg_n);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x9cfaa316ccbb6ea0ULL, 0x6cc5207c5520e081ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__UIWidgetArea__two_args (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  int  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  double rval = self->two_args (arg_n, arg_r);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x64511c410b16c274ULL, 0x19b47eb22b4cd4d4ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__UIWidgetArea__two_args2 (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  int  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  double rval = self->two_args2 (arg_n, arg_r);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x2089150ae3f7ad80ULL, 0xe6154471cb4560e0ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__UIWidgetArea__multi_args (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 6);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  bool  arg_b;
  fbr >>= arg_b;
  int64_t  arg_n;
  fbr >>= arg_n;
  double  arg_r;
  fbr >>= arg_r;
  int  arg_i;
  fbr >>= arg_i;
  std::string  arg_s;
  fbr >>= arg_s;
  double  arg_y;
  fbr >>= arg_y;
  double rval = self->multi_args (arg_b, arg_n, arg_r, arg_i, arg_s, arg_y);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x349f073a5bad36fdULL, 0xf7a10ae13b8e391bULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__UIWidgetArea__self_method (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  I_UIWidgetAreaIface *arg_ba1;
  fbr >>= arg_ba1;
  I_UIWidgetAreaIface *arg_ba2;
  fbr >>= arg_ba2;
  double rval = self->self_method (*arg_ba1, *arg_ba2);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x4b479b2f4e3ba551ULL, 0xb7c407eee57eb21aULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__UIWidgetArea__void_method (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 0);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  self->void_method ();
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__UIWidgetArea__on_click2out (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 0);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string rval = self->on_click2out ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xb8bc20394724087aULL, 0xbc7b1e7d30aeb178ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__UIWidgetArea__on_click2in (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string  arg_command;
  fbr >>= arg_command;
  self->on_click2in (arg_command);
  return NULL;
}
class __AIDA_Closure__UIWidgetArea__void_signal {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__UIWidgetArea__void_signal> SharedPtr;
  __AIDA_Closure__UIWidgetArea__void_signal (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__UIWidgetArea__void_signal()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x0774aa0ffbdf5f02ULL, 0x3f1b5247dca90c86ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0x0774aa0ffbdf5f02ULL, 0x3f1b5247dca90c86ULL);
    fb <<= sp->handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__UIWidgetArea__void_signal (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_void_signal() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__UIWidgetArea__void_signal::SharedPtr sp (new __AIDA_Closure__UIWidgetArea__void_signal (handler_id));
    result = self->sig_void_signal() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x0774aa0ffbdf5f02ULL, 0x3f1b5247dca90c86ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__UIWidgetArea__sample_signal {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__UIWidgetArea__sample_signal> SharedPtr;
  __AIDA_Closure__UIWidgetArea__sample_signal (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__UIWidgetArea__sample_signal()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<double>
  handler (const SharedPtr &sp,
           I_UIWidgetAreaIface &arg_ba1,
           int arg_someint)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 2 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<double>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      double retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    fb <<= &arg_ba1;
    fb <<= arg_someint;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__UIWidgetArea__sample_signal (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_UIWidgetAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_sample_signal() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__UIWidgetArea__sample_signal::SharedPtr sp (new __AIDA_Closure__UIWidgetArea__sample_signal (handler_id));
    result = self->sig_sample_signal().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL);
  rb <<= result;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__Parent____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_ParentIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xf8c38a8ecbaae738ULL, 0xb3e0312627d8c473ULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__Child____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_ChildIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xf12312304ba136fdULL, 0xa77c19d1413f4e7fULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__Descendant____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_DescendantIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x25c480d73f591587ULL, 0x6dd13a33bab33967ULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__GrandChild____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_GrandChildIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x5c0476de00912d29ULL, 0xfb69f6a1e0a78e4fULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__QuickIface____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_QuickIfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x9287bfc16608b62fULL, 0x4d65f47a36af14b6ULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__QuickIface__simple_function (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_QuickIfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  int  arg_i;
  fbr >>= arg_i;
  self->simple_function (arg_i);
  return NULL;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xa580bd43ca21a145ULL, 0x9eefef45f90dbb0bULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_void (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 0);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  self->method_with_void ();
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_bools (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  bool  arg_input;
  fbr >>= arg_input;
  bool  arg_optval;
  fbr >>= arg_optval;
  bool rval = self->method_with_bools (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x55291a7348d14242ULL, 0x32dac90dde65a764ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_ints32 (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  int  arg_input;
  fbr >>= arg_input;
  int  arg_optval;
  fbr >>= arg_optval;
  int rval = self->method_with_ints32 (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xdc38cf6855c54108ULL, 0x328ddcdcec8f161eULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_ints64 (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  int64_t  arg_input;
  fbr >>= arg_input;
  int64_t  arg_optval;
  fbr >>= arg_optval;
  int64_t rval = self->method_with_ints64 (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x678de8636167b6a1ULL, 0xb27d37ca066b5335ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_floats (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  double  arg_input;
  fbr >>= arg_input;
  double  arg_optval;
  fbr >>= arg_optval;
  double rval = self->method_with_floats (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xeea6d5fb184699a3ULL, 0xce05c988a9bfd2d9ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_string (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string  arg_input;
  fbr >>= arg_input;
  std::string  arg_optval;
  fbr >>= arg_optval;
  std::string rval = self->method_with_string (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x646f80849d732dc5ULL, 0x72fd1ede45b153e3ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_enum (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  QuickEnum  arg_input;
  fbr >>= arg_input;
  QuickEnum  arg_optval;
  fbr >>= arg_optval;
  QuickEnum rval = self->method_with_enum (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xee3b0b1c6eb52bdeULL, 0x13729d2db240b4f9ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_record (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  SrvT_QuickRecord  arg_input;
  fbr >>= arg_input;
  SrvT_QuickRecord  arg_optval;
  fbr >>= arg_optval;
  SrvT_QuickRecord rval = self->method_with_record (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x852c7f5942a87cceULL, 0x487dc78cd38240f6ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_sequence (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  SrvT_QuickSequence  arg_input;
  fbr >>= arg_input;
  SrvT_QuickSequence  arg_optval;
  fbr >>= arg_optval;
  SrvT_QuickSequence rval = self->method_with_sequence (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x5534838e08bdc63dULL, 0xd852fd5abb88ab7dULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_interface (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  I_GrandChildIface *arg_input;
  fbr >>= arg_input;
  I_GrandChildIface *arg_optval;
  fbr >>= arg_optval;
  I_GrandChildIfaceP rval = self->method_with_interface (*arg_input, *arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xfe9af28dc9c5de7dULL, 0x418be0c0e085ea6dULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_anys (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  Rapicorn::Aida::Any  arg_input;
  fbr >>= arg_input;
  Rapicorn::Aida::Any  arg_optval;
  fbr >>= arg_optval;
  Rapicorn::Aida::Any rval = self->method_with_anys (arg_input, arg_optval);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x807e5dacf307a277ULL, 0x2b65069e50e63c80ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__MethodTestInterface__method_with_quickiface (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_MethodTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  I_QuickIfaceIface *arg_input;
  fbr >>= arg_input;
  I_QuickIfaceIface *arg_iface0;
  fbr >>= arg_iface0;
  I_QuickIfaceIfaceP rval = self->method_with_quickiface (*arg_input, *arg_iface0);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xbe67f4e0afeafd68ULL, 0x5cdf24c075b03215ULL);
  rb <<= rval;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__SignalTestInterface____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xc00775d36cf38b56ULL, 0xf927beabb9c3e702ULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__void_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__void_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__void_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__void_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0xe2ae7c707a04333cULL, 0x420330b70d64eb5fULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0xe2ae7c707a04333cULL, 0x420330b70d64eb5fULL);
    fb <<= sp->handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__void_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_void_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__void_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__void_result (handler_id));
    result = self->sig_void_result() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0xe2ae7c707a04333cULL, 0x420330b70d64eb5fULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__bool_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__bool_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__bool_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__bool_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<bool>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<bool>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      bool retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__bool_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_bool_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__bool_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__bool_result (handler_id));
    result = self->sig_bool_result().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__int32_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__int32_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__int32_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__int32_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<int>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<int>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      int retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__int32_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_int32_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__int32_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__int32_result (handler_id));
    result = self->sig_int32_result().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__int64_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__int64_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__int64_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__int64_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<int64_t>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<int64_t>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      int64_t retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__int64_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_int64_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__int64_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__int64_result (handler_id));
    result = self->sig_int64_result().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__float64_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__float64_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__float64_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__float64_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<double>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<double>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      double retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__float64_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_float64_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__float64_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__float64_result (handler_id));
    result = self->sig_float64_result().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__string_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__string_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__string_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__string_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<std::string>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<std::string>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      std::string retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__string_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_string_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__string_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__string_result (handler_id));
    result = self->sig_string_result().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__enum_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__enum_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__enum_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__enum_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<QuickEnum>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<QuickEnum>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      QuickEnum retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__enum_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_enum_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__enum_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__enum_result (handler_id));
    result = self->sig_enum_result().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__record_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__record_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__record_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__record_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<SrvT_QuickRecord>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<SrvT_QuickRecord>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      SrvT_QuickRecord retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__record_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_record_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__record_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__record_result (handler_id));
    result = self->sig_record_result().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__sequence_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__sequence_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__sequence_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__sequence_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<SrvT_QuickSequence>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<SrvT_QuickSequence>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      SrvT_QuickSequence retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__sequence_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_sequence_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__sequence_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__sequence_result (handler_id));
    result = self->sig_sequence_result().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__interface_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__interface_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__interface_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__interface_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<I_GrandChildIfaceP>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<I_GrandChildIfaceP>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      I_GrandChildIfaceP retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__interface_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_interface_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__interface_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__interface_result (handler_id));
    result = self->sig_interface_result().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__any_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__any_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__any_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__any_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x296163d4220985ceULL, 0x40daacab4a841093ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<Rapicorn::Aida::Any>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0x296163d4220985ceULL, 0x40daacab4a841093ULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<Rapicorn::Aida::Any>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      Rapicorn::Aida::Any retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__any_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_any_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__any_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__any_result (handler_id));
    result = self->sig_any_result().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x296163d4220985ceULL, 0x40daacab4a841093ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__self_result {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__self_result> SharedPtr;
  __AIDA_Closure__SignalTestInterface__self_result (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__self_result()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x35828273200534f7ULL, 0x72873f1374d6093bULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<I_SignalTestInterfaceIfaceP>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0x35828273200534f7ULL, 0x72873f1374d6093bULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<I_SignalTestInterfaceIfaceP>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      I_SignalTestInterfaceIfaceP retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__self_result (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_self_result() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__self_result::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__self_result (handler_id));
    result = self->sig_self_result().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x35828273200534f7ULL, 0x72873f1374d6093bULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__void_arg {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__void_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__void_arg (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__void_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0xe79b3592345942f6ULL, 0x6818e92df5df5befULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0xe79b3592345942f6ULL, 0x6818e92df5df5befULL);
    fb <<= sp->handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__void_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_void_arg() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__void_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__void_arg (handler_id));
    result = self->sig_void_arg() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0xe79b3592345942f6ULL, 0x6818e92df5df5befULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__bool_arg {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__bool_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__bool_arg (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__bool_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x495e3d2d698caad7ULL, 0xf16b2f75ddaf3220ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           bool arg_b)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0x495e3d2d698caad7ULL, 0xf16b2f75ddaf3220ULL);
    fb <<= sp->handler_id_;
    fb <<= arg_b;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__bool_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_bool_arg() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__bool_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__bool_arg (handler_id));
    result = self->sig_bool_arg() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x495e3d2d698caad7ULL, 0xf16b2f75ddaf3220ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__int32_arg {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__int32_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__int32_arg (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__int32_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x1d335377194859d1ULL, 0xfa00c7fb47bc82e4ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           int arg_i)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0x1d335377194859d1ULL, 0xfa00c7fb47bc82e4ULL);
    fb <<= sp->handler_id_;
    fb <<= arg_i;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__int32_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_int32_arg() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__int32_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__int32_arg (handler_id));
    result = self->sig_int32_arg() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x1d335377194859d1ULL, 0xfa00c7fb47bc82e4ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__int64_arg {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__int64_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__int64_arg (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__int64_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x52b8b36ec08458caULL, 0xeecdb452f6b51528ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           int64_t arg_i)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0x52b8b36ec08458caULL, 0xeecdb452f6b51528ULL);
    fb <<= sp->handler_id_;
    fb <<= arg_i;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__int64_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_int64_arg() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__int64_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__int64_arg (handler_id));
    result = self->sig_int64_arg() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x52b8b36ec08458caULL, 0xeecdb452f6b51528ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__float64_arg {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__float64_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__float64_arg (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__float64_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0xdcacb20b2d942f30ULL, 0x242d314085f3e44aULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           double arg_f)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0xdcacb20b2d942f30ULL, 0x242d314085f3e44aULL);
    fb <<= sp->handler_id_;
    fb <<= arg_f;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__float64_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_float64_arg() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__float64_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__float64_arg (handler_id));
    result = self->sig_float64_arg() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0xdcacb20b2d942f30ULL, 0x242d314085f3e44aULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__string_arg {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__string_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__string_arg (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__string_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x9bb22c59672e3921ULL, 0x981c8364b2197db9ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           const std::string &arg_s)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0x9bb22c59672e3921ULL, 0x981c8364b2197db9ULL);
    fb <<= sp->handler_id_;
    fb <<= arg_s;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__string_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_string_arg() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__string_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__string_arg (handler_id));
    result = self->sig_string_arg() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x9bb22c59672e3921ULL, 0x981c8364b2197db9ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__enum_arg {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__enum_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__enum_arg (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__enum_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x62459d25ac74ebedULL, 0xd598edad744f61b7ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           QuickEnum arg_e)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0x62459d25ac74ebedULL, 0xd598edad744f61b7ULL);
    fb <<= sp->handler_id_;
    fb <<= arg_e;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__enum_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_enum_arg() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__enum_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__enum_arg (handler_id));
    result = self->sig_enum_arg() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x62459d25ac74ebedULL, 0xd598edad744f61b7ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__record_arg {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__record_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__record_arg (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__record_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0xe4c732769519ca6aULL, 0x8cf6e34972e875aaULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           const SrvT_QuickRecord &arg_r)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0xe4c732769519ca6aULL, 0x8cf6e34972e875aaULL);
    fb <<= sp->handler_id_;
    fb <<= arg_r;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__record_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_record_arg() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__record_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__record_arg (handler_id));
    result = self->sig_record_arg() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0xe4c732769519ca6aULL, 0x8cf6e34972e875aaULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__sequence_arg {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__sequence_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__sequence_arg (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__sequence_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0xeca8cf0dd80dee4aULL, 0x1bb3845a0704c774ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           const SrvT_QuickSequence &arg_s)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0xeca8cf0dd80dee4aULL, 0x1bb3845a0704c774ULL);
    fb <<= sp->handler_id_;
    fb <<= arg_s;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__sequence_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_sequence_arg() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__sequence_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__sequence_arg (handler_id));
    result = self->sig_sequence_arg() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0xeca8cf0dd80dee4aULL, 0x1bb3845a0704c774ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__interface_arg {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__interface_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__interface_arg (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__interface_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0xc2562bdab457affdULL, 0x189f1ba486f30579ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           I_GrandChildIface &arg_i)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0xc2562bdab457affdULL, 0x189f1ba486f30579ULL);
    fb <<= sp->handler_id_;
    fb <<= &arg_i;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__interface_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_interface_arg() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__interface_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__interface_arg (handler_id));
    result = self->sig_interface_arg() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0xc2562bdab457affdULL, 0x189f1ba486f30579ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__any_arg {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__any_arg> SharedPtr;
  __AIDA_Closure__SignalTestInterface__any_arg (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__any_arg()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x445abac8fb3999b7ULL, 0x422ee36946f0b021ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           const Rapicorn::Aida::Any &arg_a)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0x445abac8fb3999b7ULL, 0x422ee36946f0b021ULL);
    fb <<= sp->handler_id_;
    fb <<= arg_a;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__any_arg (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_any_arg() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__any_arg::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__any_arg (handler_id));
    result = self->sig_any_arg() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x445abac8fb3999b7ULL, 0x422ee36946f0b021ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__SignalTestInterface__self_args {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__SignalTestInterface__self_args> SharedPtr;
  __AIDA_Closure__SignalTestInterface__self_args (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__SignalTestInterface__self_args()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0xf62d65c3c8ab76a7ULL, 0x7f95ce585cfc2b0cULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           I_SignalTestInterfaceIface &arg_self_)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 1 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0xf62d65c3c8ab76a7ULL, 0x7f95ce585cfc2b0cULL);
    fb <<= sp->handler_id_;
    fb <<= &arg_self_;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__SignalTestInterface__self_args (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_SignalTestInterfaceIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_self_args() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__SignalTestInterface__self_args::SharedPtr sp (new __AIDA_Closure__SignalTestInterface__self_args (handler_id));
    result = self->sig_self_args() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0xf62d65c3c8ab76a7ULL, 0x7f95ce585cfc2b0cULL);
  rb <<= result;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__ChildInheritingSignals____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_ChildInheritingSignalsIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x8b9467d7db8651a9ULL, 0x8400cc0d7089975dULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
class __AIDA_Closure__ChildInheritingSignals__child_signal {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__ChildInheritingSignals__child_signal> SharedPtr;
  __AIDA_Closure__ChildInheritingSignals__child_signal (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__ChildInheritingSignals__child_signal()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x0b181d52b5db5237ULL, 0xd1c6370677791f5aULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp,
           I_ChildInheritingSignalsIface &arg_c,
           I_SignalTestInterfaceIface &arg_p,
           const Rapicorn::Aida::Any &arg_a,
           int arg_i,
           const SrvT_QuickRecord &arg_r,
           const SrvT_QuickSequence &arg_s)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 6 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0x0b181d52b5db5237ULL, 0xd1c6370677791f5aULL);
    fb <<= sp->handler_id_;
    fb <<= &arg_c;
    fb <<= &arg_p;
    fb <<= arg_a;
    fb <<= arg_i;
    fb <<= arg_r;
    fb <<= arg_s;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__ChildInheritingSignals__child_signal (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_ChildInheritingSignalsIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_child_signal() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__ChildInheritingSignals__child_signal::SharedPtr sp (new __AIDA_Closure__ChildInheritingSignals__child_signal (handler_id));
    result = self->sig_child_signal() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x0b181d52b5db5237ULL, 0xd1c6370677791f5aULL);
  rb <<= result;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__AnotherChild____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_AnotherChildIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xb0dcc7e6e41eabafULL, 0x16ed0fc13e53cf22ULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__PropertyTester____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x29c1fdbcddc3d3d5ULL, 0xcf3a30b5bf14d1f1ULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__PropertyTester__bool_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  bool rval = self->bool_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x14469c03fdfc61e4ULL, 0x3bb8a3b5d9832788ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__PropertyTester__bool_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  bool  arg_bool_prop;
  fbr >>= arg_bool_prop;
  self->bool_prop (arg_bool_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__PropertyTester__int32_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  int rval = self->int32_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x8a2f1538f2b852fbULL, 0x7d3e8ea6f069a1c0ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__PropertyTester__int32_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  int  arg_int32_prop;
  fbr >>= arg_int32_prop;
  self->int32_prop (arg_int32_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__PropertyTester__int64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  int64_t rval = self->int64_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xc9bb6114fc5c90deULL, 0x400dff0f59e66f63ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__PropertyTester__int64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  int64_t  arg_int64_prop;
  fbr >>= arg_int64_prop;
  self->int64_prop (arg_int64_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__PropertyTester__float64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  double rval = self->float64_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xb3d53f6a66ba171eULL, 0xc9e2fe1ad9d2d2abULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__PropertyTester__float64_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  double  arg_float64_prop;
  fbr >>= arg_float64_prop;
  self->float64_prop (arg_float64_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__PropertyTester__string_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string rval = self->string_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xd11acce29fa83acfULL, 0xb251b5fc0f737558ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__PropertyTester__string_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string  arg_string_prop;
  fbr >>= arg_string_prop;
  self->string_prop (arg_string_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__PropertyTester__enum_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  QuickEnum rval = self->enum_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x42f93106aeb5af11ULL, 0xdc4094dc01da9f81ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__PropertyTester__enum_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  QuickEnum  arg_enum_prop;
  fbr >>= arg_enum_prop;
  self->enum_prop (arg_enum_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__PropertyTester__record_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  SrvT_QuickRecord rval = self->record_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xb6ab96740d7834eeULL, 0xe7873bec722bb0c8ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__PropertyTester__record_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  SrvT_QuickRecord  arg_record_prop;
  fbr >>= arg_record_prop;
  self->record_prop (arg_record_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__PropertyTester__sequence_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  SrvT_QuickSequence rval = self->sequence_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x7f96e6ff442ecdd5ULL, 0xdb054c03831fd75bULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__PropertyTester__sequence_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  SrvT_QuickSequence  arg_sequence_prop;
  fbr >>= arg_sequence_prop;
  self->sequence_prop (arg_sequence_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__PropertyTester__interface_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  I_GrandChildIfaceP rval = self->interface_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xf3cef8a00677d931ULL, 0x8733ca529b58ea4aULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__PropertyTester__interface_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  I_GrandChildIface *arg_interface_prop;
  fbr >>= arg_interface_prop;
  self->interface_prop (&*arg_interface_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__PropertyTester__self_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  I_PropertyTesterIfaceP rval = self->self_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xdd2a04f6c2fc3005ULL, 0x68868b01ea78948fULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__PropertyTester__self_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  I_PropertyTesterIface *arg_self_prop;
  fbr >>= arg_self_prop;
  self->self_prop (&*arg_self_prop);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__PropertyTester__any_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  Rapicorn::Aida::Any rval = self->any_prop ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xb54c6ac2d1c8f932ULL, 0x1c8ea2813f2c268eULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__PropertyTester__any_prop (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PropertyTesterIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  Rapicorn::Aida::Any  arg_any_prop;
  fbr >>= arg_any_prop;
  self->any_prop (arg_any_prop);
  return NULL;
}

} // InterfaceTests

namespace RapicornAidaTest {
static Rapicorn::Aida::FieldBuffer*
__aida_call__ButtonArea____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xf01d6b5002a758fcULL, 0xa481606dbc2f4257ULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__ButtonArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string rval = self->on_click ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x199859aecc756e97ULL, 0xa744332174ed27f4ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__ButtonArea__on_click (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string  arg_on_click;
  fbr >>= arg_on_click;
  self->on_click (arg_on_click);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__ButtonArea__on_click2 (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string rval = self->on_click2 ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x1b448d91990181daULL, 0x9751c08ae956c729ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__ButtonArea__on_click2 (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string  arg_on_click2;
  fbr >>= arg_on_click2;
  self->on_click2 (arg_on_click2);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__ButtonArea__on_click3 (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string rval = self->on_click3 ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x5176fbf25dcf50f4ULL, 0x4d7ae8b51fb816b5ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__ButtonArea__on_click3 (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  std::string  arg_on_click3;
  fbr >>= arg_on_click3;
  self->on_click3 (arg_on_click3);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__ButtonArea__click_type (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  ClickType rval = self->click_type ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xb6ab79b43e1f0df9ULL, 0xaa0f1ec5c39b704aULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__ButtonArea__click_type (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  ClickType  arg_click_type;
  fbr >>= arg_click_type;
  self->click_type (arg_click_type);
  return NULL;
}
class __AIDA_Closure__ButtonArea__check_activate {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__ButtonArea__check_activate> SharedPtr;
  __AIDA_Closure__ButtonArea__check_activate (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__ButtonArea__check_activate()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static std::future<bool>
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 1);
    __AIDA_Local__::add_header2_emit (fb, sp->handler_id_, 0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL);
    fb <<= sp->handler_id_;
    auto promise = std::make_shared<std::promise<bool>> ();
    auto future = promise->get_future();
    const size_t lambda_id = 1 + size_t (promise.get());
    auto lambda = [promise] (Rapicorn::Aida::FieldReader &frr) {
      bool retval;
      frr >>= retval;
      promise->set_value (retval);
    };
    __AIDA_Local__::erhandler_add (lambda_id, lambda);
    fb <<= lambda_id;
    __AIDA_Local__::post_msg (&fb);
    return future;
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__ButtonArea__check_activate (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_check_activate() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__ButtonArea__check_activate::SharedPtr sp (new __AIDA_Closure__ButtonArea__check_activate (handler_id));
    result = self->sig_check_activate().connect_future (__AIDA_Local__::slot (sp, sp->handler));
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL);
  rb <<= result;
  return &rb;
}
class __AIDA_Closure__ButtonArea__activate {
  size_t handler_id_;
public:
  typedef std::shared_ptr<__AIDA_Closure__ButtonArea__activate> SharedPtr;
  __AIDA_Closure__ButtonArea__activate (size_t h) : handler_id_ (h) {}
  ~__AIDA_Closure__ButtonArea__activate()
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1);
    __AIDA_Local__::add_header1_discon (fb, handler_id_, 0x0c46b868988bad84ULL, 0xff7acbea142bbcd0ULL);
    fb <<= handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
  static void
  handler (const SharedPtr &sp)
  {
    Rapicorn::Aida::FieldBuffer &fb = *Rapicorn::Aida::FieldBuffer::_new (3 + 1 + 0 + 0);
    __AIDA_Local__::add_header1_emit (fb, sp->handler_id_, 0x0c46b868988bad84ULL, 0xff7acbea142bbcd0ULL);
    fb <<= sp->handler_id_;
    __AIDA_Local__::post_msg (&fb);
  }
};
static Rapicorn::Aida::FieldBuffer*
__aida_connect__ButtonArea__activate (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 2);
  I_ButtonAreaIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  size_t handler_id;
  Rapicorn::Aida::uint64 signal_connection, result = 0;
  fbr >>= handler_id;
  fbr >>= signal_connection;
  if (signal_connection)
    result = self->sig_activate() -= signal_connection;
  if (handler_id) {
    __AIDA_Closure__ButtonArea__activate::SharedPtr sp (new __AIDA_Closure__ButtonArea__activate (handler_id));
    result = self->sig_activate() += __AIDA_Local__::slot (sp, sp->handler);
  }
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_connect_result (fbr, 0x0c46b868988bad84ULL, 0xff7acbea142bbcd0ULL);
  rb <<= result;
  return &rb;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__PureMethods____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_PureMethodsIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x95676eb8489beea1ULL, 0xe9444b3b7f24a24dULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__PureMethods__pure_method (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_PureMethodsIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  double  arg_f;
  fbr >>= arg_f;
  int rval = self->pure_method (arg_f);
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xf196563f00b6d484ULL, 0x88b59c2ed0597dccULL);
  rb <<= rval;
  return &rb;
}

} // RapicornAidaTest

namespace Other {
static Rapicorn::Aida::FieldBuffer*
__aida_call__NameTests____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_NameTestsIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x18584b48b3907ce2ULL, 0xab88c262da15a085ULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_call__NameTests__args_from_other_namespace (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 3);
  I_NameTestsIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  InterfaceTests::SrvT_QuickRecord  arg_qr;
  fbr >>= arg_qr;
  RapicornAidaTest::ClickType  arg_qe;
  fbr >>= arg_qe;
  OtherNamespace::SrvT_SomeRecord  arg_sr;
  fbr >>= arg_sr;
  self->args_from_other_namespace (arg_qr, arg_qe, arg_sr);
  return NULL;
}

} // Other

namespace BseTest {
static Rapicorn::Aida::FieldBuffer*
__aida_call__Compressor____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_CompressorIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x4d6cadb87efc3ea8ULL, 0x2264b93a5a23a8baULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__Compressor__threshold (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_CompressorIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  double rval = self->threshold ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xdea15f2de1c3d8e3ULL, 0xe3fc9febf31cdc20ULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__Compressor__threshold (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_CompressorIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  double  arg_threshold;
  fbr >>= arg_threshold;
  self->threshold (arg_threshold);
  return NULL;
}
static Rapicorn::Aida::FieldBuffer*
__aida_get__Compressor__ratio (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  I_CompressorIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  double rval = self->ratio ();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0xc61a8d739c7b963bULL, 0xca1ad4eeab1aa56eULL);
  rb <<= rval;
  return &rb;
}
static Rapicorn::Aida::FieldBuffer*
__aida_set__Compressor__ratio (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1 + 1);
  I_CompressorIface *self;
  fbr.skip_header();
  fbr >>= self;
  AIDA_CHECK (self, "invalid 'this' pointer");
  double  arg_ratio;
  fbr >>= arg_ratio;
  self->ratio (arg_ratio);
  return NULL;
}

static Rapicorn::Aida::FieldBuffer*
__aida_call__SoundModule____aida_typelist__ (Rapicorn::Aida::FieldReader &fbr)
{
  AIDA_ASSERT (fbr.remaining() == 3 + 1);
  Rapicorn::Aida::TypeHashList thl;
  I_SoundModuleIface *self;
  fbr.skip_header();
  fbr >>= self;
  if (self) // guard against invalid casts
    thl = self->__aida_typelist__();
  Rapicorn::Aida::FieldBuffer &rb = *__AIDA_Local__::new_call_result (fbr, 0x6d65d3efbafc393bULL, 0x3adf67dd71b475a6ULL, 1 + 2 * thl.size());
  rb <<= int64_t (thl.size());
  for (size_t i = 0; i < thl.size(); i++)
    rb <<= thl[i];
  return &rb;
}

} // BseTest
static const __AIDA_Local__::MethodEntry _aida_stub_entries[] = {
  { 0x3080ed132845bb88ULL, 0x1ccc8bdb4dc51a6fULL, MandatoryNamespace::__aida_call__FirstInterface____aida_typelist__, },
  { 0xc3f858f5171056cbULL, 0x394e47a2bcd63e16ULL, MandatoryNamespace::__aida_call__FirstInterface__void_func, },
  { 0xc7c8bc238ce4501cULL, 0xd5b65cb502c0eb4cULL, InterfaceTests::__aida_call__UIWidgetArea____aida_typelist__, },
  { 0xf67db704b9d460d6ULL, 0xd4950feab697e61eULL, InterfaceTests::__aida_get__UIWidgetArea__dummy, },
  { 0x7aaf2f96f3042829ULL, 0x3d0391e5b72e7ba5ULL, InterfaceTests::__aida_set__UIWidgetArea__dummy, },
  { 0x58ba68f6b64584c9ULL, 0xa7d2686edb40f27aULL, InterfaceTests::__aida_get__UIWidgetArea__on_click, },
  { 0xf0025ec0fa66e3e2ULL, 0x880c10e8e6b57cfbULL, InterfaceTests::__aida_set__UIWidgetArea__on_click, },
  { 0xd0dd4c08ba5022c0ULL, 0xb1af31ca1ec7037aULL, InterfaceTests::__aida_call__UIWidgetArea__simple_method, },
  { 0xe4e890540b4c0579ULL, 0xe14a7ffaa82f1c4fULL, InterfaceTests::__aida_call__UIWidgetArea__single_arg, },
  { 0x9cfaa316ccbb6ea0ULL, 0x6cc5207c5520e081ULL, InterfaceTests::__aida_call__UIWidgetArea__single_arg2, },
  { 0x64511c410b16c274ULL, 0x19b47eb22b4cd4d4ULL, InterfaceTests::__aida_call__UIWidgetArea__two_args, },
  { 0x2089150ae3f7ad80ULL, 0xe6154471cb4560e0ULL, InterfaceTests::__aida_call__UIWidgetArea__two_args2, },
  { 0x349f073a5bad36fdULL, 0xf7a10ae13b8e391bULL, InterfaceTests::__aida_call__UIWidgetArea__multi_args, },
  { 0x4b479b2f4e3ba551ULL, 0xb7c407eee57eb21aULL, InterfaceTests::__aida_call__UIWidgetArea__self_method, },
  { 0xdbb304ad4df15873ULL, 0xca276abf2bb1603cULL, InterfaceTests::__aida_call__UIWidgetArea__void_method, },
  { 0xb8bc20394724087aULL, 0xbc7b1e7d30aeb178ULL, InterfaceTests::__aida_call__UIWidgetArea__on_click2out, },
  { 0x3432c3bb41bc72a0ULL, 0x533bc22135f973bfULL, InterfaceTests::__aida_call__UIWidgetArea__on_click2in, },
  { 0x0774aa0ffbdf5f02ULL, 0x3f1b5247dca90c86ULL, InterfaceTests::__aida_connect__UIWidgetArea__void_signal, },
  { 0x219d8339499d690eULL, 0x08bca1e9a82f86b0ULL, InterfaceTests::__aida_connect__UIWidgetArea__sample_signal, },
  { 0xf8c38a8ecbaae738ULL, 0xb3e0312627d8c473ULL, InterfaceTests::__aida_call__Parent____aida_typelist__, },
  { 0xf12312304ba136fdULL, 0xa77c19d1413f4e7fULL, InterfaceTests::__aida_call__Child____aida_typelist__, },
  { 0x25c480d73f591587ULL, 0x6dd13a33bab33967ULL, InterfaceTests::__aida_call__Descendant____aida_typelist__, },
  { 0x5c0476de00912d29ULL, 0xfb69f6a1e0a78e4fULL, InterfaceTests::__aida_call__GrandChild____aida_typelist__, },
  { 0x9287bfc16608b62fULL, 0x4d65f47a36af14b6ULL, InterfaceTests::__aida_call__QuickIface____aida_typelist__, },
  { 0x76ac7a704663d246ULL, 0x23abac49621c6802ULL, InterfaceTests::__aida_call__QuickIface__simple_function, },
  { 0xa580bd43ca21a145ULL, 0x9eefef45f90dbb0bULL, InterfaceTests::__aida_call__MethodTestInterface____aida_typelist__, },
  { 0x1addfccb0a3e01beULL, 0x314f2eb467d7a72bULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_void, },
  { 0x55291a7348d14242ULL, 0x32dac90dde65a764ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_bools, },
  { 0xdc38cf6855c54108ULL, 0x328ddcdcec8f161eULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_ints32, },
  { 0x678de8636167b6a1ULL, 0xb27d37ca066b5335ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_ints64, },
  { 0xeea6d5fb184699a3ULL, 0xce05c988a9bfd2d9ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_floats, },
  { 0x646f80849d732dc5ULL, 0x72fd1ede45b153e3ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_string, },
  { 0xee3b0b1c6eb52bdeULL, 0x13729d2db240b4f9ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_enum, },
  { 0x852c7f5942a87cceULL, 0x487dc78cd38240f6ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_record, },
  { 0x5534838e08bdc63dULL, 0xd852fd5abb88ab7dULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_sequence, },
  { 0xfe9af28dc9c5de7dULL, 0x418be0c0e085ea6dULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_interface, },
  { 0x807e5dacf307a277ULL, 0x2b65069e50e63c80ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_anys, },
  { 0xbe67f4e0afeafd68ULL, 0x5cdf24c075b03215ULL, InterfaceTests::__aida_call__MethodTestInterface__method_with_quickiface, },
  { 0xc00775d36cf38b56ULL, 0xf927beabb9c3e702ULL, InterfaceTests::__aida_call__SignalTestInterface____aida_typelist__, },
  { 0xe2ae7c707a04333cULL, 0x420330b70d64eb5fULL, InterfaceTests::__aida_connect__SignalTestInterface__void_result, },
  { 0x31529d809bd68e6bULL, 0xa11d55517d4325aeULL, InterfaceTests::__aida_connect__SignalTestInterface__bool_result, },
  { 0xac712d196d3466f3ULL, 0xeb06bf4f2b2a414cULL, InterfaceTests::__aida_connect__SignalTestInterface__int32_result, },
  { 0x1439d37d87e2668bULL, 0x57ded621e6b0cde6ULL, InterfaceTests::__aida_connect__SignalTestInterface__int64_result, },
  { 0x4c5a782eaa76edb0ULL, 0xb66fbaa524004fd9ULL, InterfaceTests::__aida_connect__SignalTestInterface__float64_result, },
  { 0xbc5c00f41d7c710dULL, 0x368d920fb6c136e6ULL, InterfaceTests::__aida_connect__SignalTestInterface__string_result, },
  { 0x60702e53aca1b772ULL, 0xeac0d39852c951fbULL, InterfaceTests::__aida_connect__SignalTestInterface__enum_result, },
  { 0x755d247d6abfde87ULL, 0x093ff68bbb0f5257ULL, InterfaceTests::__aida_connect__SignalTestInterface__record_result, },
  { 0xb5c453295aa72207ULL, 0x7c0fa1c12417b139ULL, InterfaceTests::__aida_connect__SignalTestInterface__sequence_result, },
  { 0xe8ef1fe5de31f95bULL, 0xc0e4bcc410120585ULL, InterfaceTests::__aida_connect__SignalTestInterface__interface_result, },
  { 0x296163d4220985ceULL, 0x40daacab4a841093ULL, InterfaceTests::__aida_connect__SignalTestInterface__any_result, },
  { 0x35828273200534f7ULL, 0x72873f1374d6093bULL, InterfaceTests::__aida_connect__SignalTestInterface__self_result, },
  { 0xe79b3592345942f6ULL, 0x6818e92df5df5befULL, InterfaceTests::__aida_connect__SignalTestInterface__void_arg, },
  { 0x495e3d2d698caad7ULL, 0xf16b2f75ddaf3220ULL, InterfaceTests::__aida_connect__SignalTestInterface__bool_arg, },
  { 0x1d335377194859d1ULL, 0xfa00c7fb47bc82e4ULL, InterfaceTests::__aida_connect__SignalTestInterface__int32_arg, },
  { 0x52b8b36ec08458caULL, 0xeecdb452f6b51528ULL, InterfaceTests::__aida_connect__SignalTestInterface__int64_arg, },
  { 0xdcacb20b2d942f30ULL, 0x242d314085f3e44aULL, InterfaceTests::__aida_connect__SignalTestInterface__float64_arg, },
  { 0x9bb22c59672e3921ULL, 0x981c8364b2197db9ULL, InterfaceTests::__aida_connect__SignalTestInterface__string_arg, },
  { 0x62459d25ac74ebedULL, 0xd598edad744f61b7ULL, InterfaceTests::__aida_connect__SignalTestInterface__enum_arg, },
  { 0xe4c732769519ca6aULL, 0x8cf6e34972e875aaULL, InterfaceTests::__aida_connect__SignalTestInterface__record_arg, },
  { 0xeca8cf0dd80dee4aULL, 0x1bb3845a0704c774ULL, InterfaceTests::__aida_connect__SignalTestInterface__sequence_arg, },
  { 0xc2562bdab457affdULL, 0x189f1ba486f30579ULL, InterfaceTests::__aida_connect__SignalTestInterface__interface_arg, },
  { 0x445abac8fb3999b7ULL, 0x422ee36946f0b021ULL, InterfaceTests::__aida_connect__SignalTestInterface__any_arg, },
  { 0xf62d65c3c8ab76a7ULL, 0x7f95ce585cfc2b0cULL, InterfaceTests::__aida_connect__SignalTestInterface__self_args, },
  { 0x8b9467d7db8651a9ULL, 0x8400cc0d7089975dULL, InterfaceTests::__aida_call__ChildInheritingSignals____aida_typelist__, },
  { 0x0b181d52b5db5237ULL, 0xd1c6370677791f5aULL, InterfaceTests::__aida_connect__ChildInheritingSignals__child_signal, },
  { 0xb0dcc7e6e41eabafULL, 0x16ed0fc13e53cf22ULL, InterfaceTests::__aida_call__AnotherChild____aida_typelist__, },
  { 0x29c1fdbcddc3d3d5ULL, 0xcf3a30b5bf14d1f1ULL, InterfaceTests::__aida_call__PropertyTester____aida_typelist__, },
  { 0x14469c03fdfc61e4ULL, 0x3bb8a3b5d9832788ULL, InterfaceTests::__aida_get__PropertyTester__bool_prop, },
  { 0xa88d7a16adc7ad43ULL, 0x33e7a32598f08880ULL, InterfaceTests::__aida_set__PropertyTester__bool_prop, },
  { 0x8a2f1538f2b852fbULL, 0x7d3e8ea6f069a1c0ULL, InterfaceTests::__aida_get__PropertyTester__int32_prop, },
  { 0x7b7b3182160469e4ULL, 0xbd3c44c3a57484ebULL, InterfaceTests::__aida_set__PropertyTester__int32_prop, },
  { 0xc9bb6114fc5c90deULL, 0x400dff0f59e66f63ULL, InterfaceTests::__aida_get__PropertyTester__int64_prop, },
  { 0xb33bf89d2259a1dbULL, 0x0154420aebe9a16cULL, InterfaceTests::__aida_set__PropertyTester__int64_prop, },
  { 0xb3d53f6a66ba171eULL, 0xc9e2fe1ad9d2d2abULL, InterfaceTests::__aida_get__PropertyTester__float64_prop, },
  { 0xf1df5bd296ac78e2ULL, 0xbb263cff89927093ULL, InterfaceTests::__aida_set__PropertyTester__float64_prop, },
  { 0xd11acce29fa83acfULL, 0xb251b5fc0f737558ULL, InterfaceTests::__aida_get__PropertyTester__string_prop, },
  { 0xfadb1eed1d8d358aULL, 0x17cd2ca684080698ULL, InterfaceTests::__aida_set__PropertyTester__string_prop, },
  { 0x42f93106aeb5af11ULL, 0xdc4094dc01da9f81ULL, InterfaceTests::__aida_get__PropertyTester__enum_prop, },
  { 0x99206fff699c82d6ULL, 0x1dcbc77498569411ULL, InterfaceTests::__aida_set__PropertyTester__enum_prop, },
  { 0xb6ab96740d7834eeULL, 0xe7873bec722bb0c8ULL, InterfaceTests::__aida_get__PropertyTester__record_prop, },
  { 0x55aaf8cee9dd7a46ULL, 0x83d8416416740bf0ULL, InterfaceTests::__aida_set__PropertyTester__record_prop, },
  { 0x7f96e6ff442ecdd5ULL, 0xdb054c03831fd75bULL, InterfaceTests::__aida_get__PropertyTester__sequence_prop, },
  { 0xf86952a034b8bc84ULL, 0x3be169a3f0a9a07dULL, InterfaceTests::__aida_set__PropertyTester__sequence_prop, },
  { 0xf3cef8a00677d931ULL, 0x8733ca529b58ea4aULL, InterfaceTests::__aida_get__PropertyTester__interface_prop, },
  { 0xbf62779e2a11aebbULL, 0x95547f4e29ca3814ULL, InterfaceTests::__aida_set__PropertyTester__interface_prop, },
  { 0xdd2a04f6c2fc3005ULL, 0x68868b01ea78948fULL, InterfaceTests::__aida_get__PropertyTester__self_prop, },
  { 0x1a1ee3ab20ab3c2fULL, 0xeeaf17826dba2891ULL, InterfaceTests::__aida_set__PropertyTester__self_prop, },
  { 0xb54c6ac2d1c8f932ULL, 0x1c8ea2813f2c268eULL, InterfaceTests::__aida_get__PropertyTester__any_prop, },
  { 0xe0c7d397e652f3f7ULL, 0xbbdf7826e88f4f42ULL, InterfaceTests::__aida_set__PropertyTester__any_prop, },
  { 0xf01d6b5002a758fcULL, 0xa481606dbc2f4257ULL, RapicornAidaTest::__aida_call__ButtonArea____aida_typelist__, },
  { 0x199859aecc756e97ULL, 0xa744332174ed27f4ULL, RapicornAidaTest::__aida_get__ButtonArea__on_click, },
  { 0xdb3a24116c653985ULL, 0x2a0576faff45b4b2ULL, RapicornAidaTest::__aida_set__ButtonArea__on_click, },
  { 0x1b448d91990181daULL, 0x9751c08ae956c729ULL, RapicornAidaTest::__aida_get__ButtonArea__on_click2, },
  { 0xfc93898ba4104662ULL, 0xc918694fe5c2bfefULL, RapicornAidaTest::__aida_set__ButtonArea__on_click2, },
  { 0x5176fbf25dcf50f4ULL, 0x4d7ae8b51fb816b5ULL, RapicornAidaTest::__aida_get__ButtonArea__on_click3, },
  { 0x1c1990dca0fde97cULL, 0x6cc2c7cc49d811f8ULL, RapicornAidaTest::__aida_set__ButtonArea__on_click3, },
  { 0xb6ab79b43e1f0df9ULL, 0xaa0f1ec5c39b704aULL, RapicornAidaTest::__aida_get__ButtonArea__click_type, },
  { 0x1f5a6d031cb7e104ULL, 0x2d4a207f0842bec8ULL, RapicornAidaTest::__aida_set__ButtonArea__click_type, },
  { 0x528a0b92de4a958cULL, 0x4d47eecbae62f654ULL, RapicornAidaTest::__aida_connect__ButtonArea__check_activate, },
  { 0x0c46b868988bad84ULL, 0xff7acbea142bbcd0ULL, RapicornAidaTest::__aida_connect__ButtonArea__activate, },
  { 0x95676eb8489beea1ULL, 0xe9444b3b7f24a24dULL, RapicornAidaTest::__aida_call__PureMethods____aida_typelist__, },
  { 0xf196563f00b6d484ULL, 0x88b59c2ed0597dccULL, RapicornAidaTest::__aida_call__PureMethods__pure_method, },
  { 0x18584b48b3907ce2ULL, 0xab88c262da15a085ULL, Other::__aida_call__NameTests____aida_typelist__, },
  { 0xd471f88e8c15081cULL, 0x963d2094339d0220ULL, Other::__aida_call__NameTests__args_from_other_namespace, },
  { 0x4d6cadb87efc3ea8ULL, 0x2264b93a5a23a8baULL, BseTest::__aida_call__Compressor____aida_typelist__, },
  { 0xdea15f2de1c3d8e3ULL, 0xe3fc9febf31cdc20ULL, BseTest::__aida_get__Compressor__threshold, },
  { 0xf40a3fd3d07b3d0bULL, 0xbae97c41e3d6a92bULL, BseTest::__aida_set__Compressor__threshold, },
  { 0xc61a8d739c7b963bULL, 0xca1ad4eeab1aa56eULL, BseTest::__aida_get__Compressor__ratio, },
  { 0x302f0b5b99a2a6c8ULL, 0xc8b771894ecd9315ULL, BseTest::__aida_set__Compressor__ratio, },
  { 0x6d65d3efbafc393bULL, 0x3adf67dd71b475a6ULL, BseTest::__aida_call__SoundModule____aida_typelist__, },
};
static __AIDA_Local__::MethodRegistry _aida_stub_registry (_aida_stub_entries);

#endif /* __SRVT____testpass_idl */

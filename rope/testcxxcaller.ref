/* --- Generated by PLIC-CxxCaller --- */

// #include <rcore/rapicornsignal.hh>
// #include <ui/interface.hh>
#include <rapicorn.hh>
#include <ui/protocol-pb2.hh>
#include <rcore/plicutils.hh>

#include <string>
#include <vector>

#if     __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)
#define __UNUSED__      __attribute__ ((__unused__))
#else
#define __UNUSED__
#endif

namespace { // Anonymous

// FIXME:
typedef Rapicorn::ProtoRecord ProtoRecord;
typedef Rapicorn::ProtoSequence ProtoSequence;
typedef Rapicorn::ProtoArg ProtoArg;
typedef Rapicorn::ProtoMessage ProtoMessage;
typedef Rapicorn::Rope::RemoteProcedure RemoteProcedure;
typedef Rapicorn::Rope::RemoteProcedure_Sequence RemoteProcedure_Sequence;
typedef Rapicorn::Rope::RemoteProcedure_Record RemoteProcedure_Record;
typedef Rapicorn::Rope::RemoteProcedure_Argument RemoteProcedure_Argument;
static inline RemoteProcedure_Record&
RPRecordCast (ProtoRecord &r)
{
  return *(RemoteProcedure_Record*) &r;
}
static inline const RemoteProcedure_Record&
RPRecordCast (const ProtoRecord &r)
{
  return *(const RemoteProcedure_Record*) &r;
}
static inline ProtoRecord&
ProtoRecordCast (RemoteProcedure_Record &r)
{
  return *(ProtoRecord*) &r;
}
static inline const ProtoRecord&
ProtoRecordCast (const RemoteProcedure_Record &r)
{
  return *(const ProtoRecord*) &r;
}
static inline RemoteProcedure_Sequence&
RPSequenceCast (ProtoSequence &r)
{
  return *(RemoteProcedure_Sequence*) &r;
}
static inline const RemoteProcedure_Sequence&
RPSequenceCast (const ProtoSequence &r)
{
  return *(const RemoteProcedure_Sequence*) &r;
}
static inline ProtoSequence&
ProtoSequenceCast (RemoteProcedure_Sequence &r)
{
  return *(ProtoSequence*) &r;
}
static inline const ProtoSequence&
ProtoSequenceCast (const RemoteProcedure_Sequence &r)
{
  return *(const ProtoSequence*) &r;
}
template<class CLASS> static inline std::string
Instance2StringCast (CLASS *obj)
{
  return dynamic_cast<const Rapicorn::Deletable*> (obj)->object_url();
}
template<class CLASS> static inline std::string
Instance2StringCast (const CLASS &obj)
{
  return dynamic_cast<const Rapicorn::Deletable*> (&obj)->object_url();
}
template<class CLASS> static inline CLASS*
Instance4StringCast (const std::string &objstring)
{
  struct _DeletableWrapper : public Rapicorn::Deletable {
    static Deletable* _from_object_url (const std::string &ou) { return from_object_url (ou); }
  };
  Rapicorn::Deletable *dobj = _DeletableWrapper::_from_object_url (objstring);
  CLASS *target = dobj ? dynamic_cast<CLASS*> (dobj) : NULL;
  if (!target)
    printerr ("NULL-CAST: %s -> %p -> %p\n", objstring.c_str(), dobj, target); // FIXME
  return target;
}
#define die()      (void) 0 // FIXME
#define rope_check(cond,errmsg) do { if (!(cond)) { Rapicorn::printerr ("ROPE:error: %s\n", errmsg); return false; } } while (0)

} // Anonymous


// --- Interfaces ---

namespace MandatoryNamespace {
enum Empty {
};
enum Enum1 {
  E1_A = 1,
};
enum Enum1c {
  E1C_A = 1,
};
enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
struct XFooRecord {
  bool            single_bool;
  int             single_num;
  double          single_float;
  std::string     single_string;
  int             sibling1;
  int             sibling2;
  int             multi1;
  int             multi2;
  int             multi3;
  int             multi4;
  ExtensiveEnum   enum_field;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline XFooRecord () { single_bool = 0; single_num = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
struct XFooSequence {
  std::vector<bool> single_bool;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct IntSequence {
  std::vector<int> numx;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct FloatSequence {
  std::vector<double> fractalvalue;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct StringSequence {
  std::vector<std::string> blurb;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct ExtensiveEnumSequence {
  std::vector<ExtensiveEnum> enum_elements;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct RecordSequence {
  std::vector<XFooRecord> repeatedfield;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct SequenceSequence {
  std::vector<IntSequence> moreints;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
struct NestedTypesRec {
  XFooRecord      rec;
  XFooSequence    seq;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline NestedTypesRec () { }
};
struct NestedTypesSeq {
  std::vector<NestedTypesRec> ntr;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};
typedef int AliasInt;
typedef double AliasFloat;
typedef bool AliasBool;
typedef std::string AliasString;
typedef XFooRecord AliasRecord;
typedef XFooSequence AliasSequence;
typedef ExtensiveEnum AliasEnum;
struct NewRecord {
  int             i;
  Enum1           enum1;
  XFooSequence    xfs;
  NestedTypesRec  ntr;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline NewRecord () { i = 0; enum1 = Enum1 (0); }
};

namespace Inner {
struct InnerRecord {
  int             x;
  int             y;
  NewRecord       rec;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline InnerRecord () { x = 0; y = 0; }
};
} // Inner
struct Refer2Inner {
  Inner::InnerRecord r;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline Refer2Inner () { }
};
} // MandatoryNamespace

namespace OtherNamespace {
struct SomeRecord {
  MandatoryNamespace::NewRecord r1;
  MandatoryNamespace::NewRecord r2;
  MandatoryNamespace::Inner::InnerRecord r3;
  MandatoryNamespace::Inner::InnerRecord r4;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline SomeRecord () { }
};
} // OtherNamespace

namespace Auxdata {
typedef int bar;
typedef double x;
typedef std::string s;
} // Auxdata

namespace InterfaceTests {

class UIWidgetArea {
protected:
  virtual /*Des*/         ~UIWidgetArea () = 0;
public:
  typedef Rapicorn::Signals::Signal<UIWidgetArea, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::Signal<UIWidgetArea, double (UIWidgetArea &ba1, int someint)> Signal_sample_signal;
  // Signal_void_signal sig_void_signal;
  // Signal_sample_signal sig_sample_signal;
  virtual double          simple_method ();
  virtual double          single_arg    (int n);
  virtual double          single_arg2   (int n = 5);
  virtual double          two_args      (int n,
                                         double r);
  virtual double          two_args2     (int n = 6,
                                         double r = 7.7);
  virtual double          multi_args    (int n,
                                         double r,
                                         int i,
                                         const std::string &s = "String ding",
                                         double y = 5);
  virtual double          self_method   (UIWidgetArea &ba1,
                                         UIWidgetArea &ba2);
  virtual void            void_method   ();
  virtual std::string     on_click2out  ();
  virtual void            on_click2in   (const std::string &command);
};

class Parent {
protected:
  virtual /*Des*/         ~Parent () = 0;
public:
};

class Child : public virtual Parent {
protected:
  virtual /*Des*/         ~Child () = 0;
public:
};

class Descendant : public virtual Child {
protected:
  virtual /*Des*/         ~Descendant () = 0;
public:
};

class GrandChild : public virtual Descendant {
protected:
  virtual /*Des*/         ~GrandChild () = 0;
public:
};
enum QuickEnum {
  ZERO = 0,
};
struct QuickRecord {
  int             int1;
  int             int2;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoRecord &) const;
  bool from_proto (const ProtoRecord &);
  inline QuickRecord () { int1 = 0; int2 = 0; }
};
struct QuickSequence {
  std::vector<double> somefloat;
  bool proto_add  (Rapicorn::Plic::FieldBuffer&) const;
  bool proto_pop  (Rapicorn::Plic::FieldBufferReader&);
  bool to_proto   (ProtoSequence &) const;
  bool from_proto (const ProtoSequence &);
};

class MethodTestInterface {
protected:
  virtual /*Des*/         ~MethodTestInterface () = 0;
public:
  virtual void            method_with_void      ();
  virtual bool            method_with_bools     (bool input,
                                                 bool optval = 0);
  virtual int             method_with_ints      (int input,
                                                 int optval = -2);
  virtual double          method_with_floats    (double input,
                                                 double optval = 309.9);
  virtual std::string     method_with_string    (const std::string &input,
                                                 const std::string &optval = "default");
  virtual QuickEnum       method_with_enum      (QuickEnum input,
                                                 QuickEnum optval = QuickEnum (0));
  virtual QuickRecord     method_with_record    (const QuickRecord &input,
                                                 const QuickRecord &optval = QuickRecord());
  virtual QuickSequence   method_with_sequence  (const QuickSequence &input,
                                                 const QuickSequence &optval = QuickSequence());
  virtual GrandChild*     method_with_interface (GrandChild &input,
                                                 GrandChild &optval = *(GrandChild*) NULL);
};
} // InterfaceTests

namespace RapicornPlicTest {
enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};

class ButtonArea {
protected:
  virtual /*Des*/         ~ButtonArea () = 0;
public:
  typedef Rapicorn::Signals::Signal<ButtonArea, bool (), Rapicorn::Signals::CollectorUntil0<bool> > Signal_check_activate;
  typedef Rapicorn::Signals::Signal<ButtonArea, void ()> Signal_activate;
  // Signal_check_activate sig_check_activate;
  // Signal_activate sig_activate;
};

class PureMethods {
protected:
  virtual /*Des*/         ~PureMethods () = 0;
public:
  virtual int             pure_method (double f) = 0;
};
} // RapicornPlicTest

// --- Client Stubs ---

namespace MandatoryNamespace {
bool
XFooRecord::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (11);
  fb.add_int64 (this->single_bool);
  fb.add_int64 (this->single_num);
  fb.add_double (this->single_float);
  fb.add_string (this->single_string);
  fb.add_int64 (this->sibling1);
  fb.add_int64 (this->sibling2);
  fb.add_int64 (this->multi1);
  fb.add_int64 (this->multi2);
  fb.add_int64 (this->multi3);
  fb.add_int64 (this->multi4);
  fb.add_evalue (this->enum_field);
  return true;
}
bool
XFooRecord::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 11) return false;
  this->single_bool = fbr.pop_int64();
  this->single_num = fbr.pop_int64();
  this->single_float = fbr.pop_double();
  this->single_string = fbr.pop_string();
  this->sibling1 = fbr.pop_int64();
  this->sibling2 = fbr.pop_int64();
  this->multi1 = fbr.pop_int64();
  this->multi2 = fbr.pop_int64();
  this->multi3 = fbr.pop_int64();
  this->multi4 = fbr.pop_int64();
  this->enum_field = ExtensiveEnum (fbr.pop_evalue());
  return true;
}
bool
XFooRecord::to_proto (ProtoRecord &dst) const
{
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  field->set_vint64 (single_bool);
  field = rpr.add_fields();
  field->set_vint64 (single_num);
  field = rpr.add_fields();
  field->set_vdouble (single_float);
  field = rpr.add_fields();
  field->set_vstring (single_string);
  field = rpr.add_fields();
  field->set_vint64 (sibling1);
  field = rpr.add_fields();
  field->set_vint64 (sibling2);
  field = rpr.add_fields();
  field->set_vint64 (multi1);
  field = rpr.add_fields();
  field->set_vint64 (multi2);
  field = rpr.add_fields();
  field->set_vint64 (multi3);
  field = rpr.add_fields();
  field->set_vint64 (multi4);
  field = rpr.add_fields();
  field->set_vint64 (enum_field);
  return true;
}
bool
XFooRecord::from_proto (const ProtoRecord &src)
{
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 11) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (!field->has_vint64()) return false;
  single_bool = field->vint64();
  field = &rpr.fields (1);
  if (!field->has_vint64()) return false;
  single_num = field->vint64();
  field = &rpr.fields (2);
  if (!field->has_vdouble()) return false;
  single_float = field->vdouble();
  field = &rpr.fields (3);
  if (!field->has_vstring()) return false;
  single_string = field->vstring();
  field = &rpr.fields (4);
  if (!field->has_vint64()) return false;
  sibling1 = field->vint64();
  field = &rpr.fields (5);
  if (!field->has_vint64()) return false;
  sibling2 = field->vint64();
  field = &rpr.fields (6);
  if (!field->has_vint64()) return false;
  multi1 = field->vint64();
  field = &rpr.fields (7);
  if (!field->has_vint64()) return false;
  multi2 = field->vint64();
  field = &rpr.fields (8);
  if (!field->has_vint64()) return false;
  multi3 = field->vint64();
  field = &rpr.fields (9);
  if (!field->has_vint64()) return false;
  multi4 = field->vint64();
  field = &rpr.fields (10);
  if (!field->has_vint64()) return false;
  enum_field = ExtensiveEnum (field->vint64());
  return true;
}

bool
XFooSequence::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  const size_t len = single_bool.size();
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_int64 (this->single_bool[k]);
  }
  return true;
}
bool
XFooSequence::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->single_bool.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->single_bool.push_back (fbr.pop_int64());
  }
  return true;
}
bool
XFooSequence::to_proto (ProtoSequence &dst) const
{
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = single_bool.size();
  for (size_t k = 0; k < len; k++) {
    rps.add_vint64 (single_bool[k]);
  }
  return true;
}
bool
XFooSequence::from_proto (const ProtoSequence &src)
{
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vint64_size();
  for (size_t k = 0; k < len; k++) {
    single_bool.push_back (rps.vint64 (k));
  }
  return true;
}

bool
IntSequence::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  const size_t len = numx.size();
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_int64 (this->numx[k]);
  }
  return true;
}
bool
IntSequence::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->numx.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->numx.push_back (fbr.pop_int64());
  }
  return true;
}
bool
IntSequence::to_proto (ProtoSequence &dst) const
{
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = numx.size();
  for (size_t k = 0; k < len; k++) {
    rps.add_vint64 (numx[k]);
  }
  return true;
}
bool
IntSequence::from_proto (const ProtoSequence &src)
{
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vint64_size();
  for (size_t k = 0; k < len; k++) {
    numx.push_back (rps.vint64 (k));
  }
  return true;
}

bool
FloatSequence::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  const size_t len = fractalvalue.size();
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_double (this->fractalvalue[k]);
  }
  return true;
}
bool
FloatSequence::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->fractalvalue.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->fractalvalue.push_back (fbr.pop_double());
  }
  return true;
}
bool
FloatSequence::to_proto (ProtoSequence &dst) const
{
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = fractalvalue.size();
  for (size_t k = 0; k < len; k++) {
    rps.add_vdouble (fractalvalue[k]);
  }
  return true;
}
bool
FloatSequence::from_proto (const ProtoSequence &src)
{
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vdouble_size();
  for (size_t k = 0; k < len; k++) {
    fractalvalue.push_back (rps.vdouble (k));
  }
  return true;
}

bool
StringSequence::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  const size_t len = blurb.size();
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_string (this->blurb[k]);
  }
  return true;
}
bool
StringSequence::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->blurb.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->blurb.push_back (fbr.pop_string());
  }
  return true;
}
bool
StringSequence::to_proto (ProtoSequence &dst) const
{
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = blurb.size();
  for (size_t k = 0; k < len; k++) {
    rps.add_vstring (blurb[k]);
  }
  return true;
}
bool
StringSequence::from_proto (const ProtoSequence &src)
{
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vstring_size();
  for (size_t k = 0; k < len; k++) {
    blurb.push_back (rps.vstring (k));
  }
  return true;
}

bool
ExtensiveEnumSequence::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  const size_t len = enum_elements.size();
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_evalue (this->enum_elements[k]);
  }
  return true;
}
bool
ExtensiveEnumSequence::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->enum_elements.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->enum_elements.push_back (ExtensiveEnum (fbr.pop_evalue()));
  }
  return true;
}
bool
ExtensiveEnumSequence::to_proto (ProtoSequence &dst) const
{
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = enum_elements.size();
  for (size_t k = 0; k < len; k++) {
    rps.add_vint64 (enum_elements[k]);
  }
  return true;
}
bool
ExtensiveEnumSequence::from_proto (const ProtoSequence &src)
{
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vint64_size();
  for (size_t k = 0; k < len; k++) {
    enum_elements.push_back (ExtensiveEnum (rps.vint64 (k)));
  }
  return true;
}

bool
RecordSequence::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  const size_t len = repeatedfield.size();
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->repeatedfield[k].proto_add (fb)) return false;
  }
  return true;
}
bool
RecordSequence::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->repeatedfield.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->repeatedfield[k].proto_pop (fbr)) return false;
  }
  return true;
}
bool
RecordSequence::to_proto (ProtoSequence &dst) const
{
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = repeatedfield.size();
  for (size_t k = 0; k < len; k++) {
    if (!repeatedfield[k].to_proto (ProtoRecordCast (*rps.add_vrec()))) return false;
  }
  return true;
}
bool
RecordSequence::from_proto (const ProtoSequence &src)
{
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vrec_size();
  repeatedfield.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!repeatedfield[k].from_proto (ProtoRecordCast (rps.vrec (k)))) return false;
  }
  return true;
}

bool
SequenceSequence::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  const size_t len = moreints.size();
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->moreints[k].proto_add (fb)) return false;
  }
  return true;
}
bool
SequenceSequence::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->moreints.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->moreints[k].proto_pop (fbr)) return false;
  }
  return true;
}
bool
SequenceSequence::to_proto (ProtoSequence &dst) const
{
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = moreints.size();
  for (size_t k = 0; k < len; k++) {
    if (!moreints[k].to_proto (ProtoSequenceCast (*rps.add_vseq()))) return false;
  }
  return true;
}
bool
SequenceSequence::from_proto (const ProtoSequence &src)
{
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vseq_size();
  moreints.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!moreints[k].from_proto (ProtoSequenceCast (rps.vseq (k)))) return false;
  }
  return true;
}

bool
NestedTypesRec::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (2);
  if (!this->rec.proto_add (fb)) return false;
  if (!this->seq.proto_add (fb)) return false;
  return true;
}
bool
NestedTypesRec::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 2) return false;
  if (!this->rec.proto_pop (fbr)) return false;
  if (!this->seq.proto_pop (fbr)) return false;
  return true;
}
bool
NestedTypesRec::to_proto (ProtoRecord &dst) const
{
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  if (!rec.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  field = rpr.add_fields();
  if (!seq.to_proto (ProtoSequenceCast (*field->mutable_vseq()))) return false;
  return true;
}
bool
NestedTypesRec::from_proto (const ProtoRecord &src)
{
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 2) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (!field->has_vrec() || !rec.from_proto (ProtoRecordCast (field->vrec()))) return false;
  field = &rpr.fields (1);
  if (!field->has_vseq() || !seq.from_proto (ProtoSequenceCast (field->vseq()))) return false;
  return true;
}

bool
NestedTypesSeq::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  const size_t len = ntr.size();
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->ntr[k].proto_add (fb)) return false;
  }
  return true;
}
bool
NestedTypesSeq::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->ntr.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->ntr[k].proto_pop (fbr)) return false;
  }
  return true;
}
bool
NestedTypesSeq::to_proto (ProtoSequence &dst) const
{
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = ntr.size();
  for (size_t k = 0; k < len; k++) {
    if (!ntr[k].to_proto (ProtoRecordCast (*rps.add_vrec()))) return false;
  }
  return true;
}
bool
NestedTypesSeq::from_proto (const ProtoSequence &src)
{
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vrec_size();
  ntr.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!ntr[k].from_proto (ProtoRecordCast (rps.vrec (k)))) return false;
  }
  return true;
}

bool
NewRecord::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (4);
  fb.add_int64 (this->i);
  fb.add_evalue (this->enum1);
  if (!this->xfs.proto_add (fb)) return false;
  if (!this->ntr.proto_add (fb)) return false;
  return true;
}
bool
NewRecord::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 4) return false;
  this->i = fbr.pop_int64();
  this->enum1 = Enum1 (fbr.pop_evalue());
  if (!this->xfs.proto_pop (fbr)) return false;
  if (!this->ntr.proto_pop (fbr)) return false;
  return true;
}
bool
NewRecord::to_proto (ProtoRecord &dst) const
{
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  field->set_vint64 (i);
  field = rpr.add_fields();
  field->set_vint64 (enum1);
  field = rpr.add_fields();
  if (!xfs.to_proto (ProtoSequenceCast (*field->mutable_vseq()))) return false;
  field = rpr.add_fields();
  if (!ntr.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  return true;
}
bool
NewRecord::from_proto (const ProtoRecord &src)
{
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 4) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (!field->has_vint64()) return false;
  i = field->vint64();
  field = &rpr.fields (1);
  if (!field->has_vint64()) return false;
  enum1 = Enum1 (field->vint64());
  field = &rpr.fields (2);
  if (!field->has_vseq() || !xfs.from_proto (ProtoSequenceCast (field->vseq()))) return false;
  field = &rpr.fields (3);
  if (!field->has_vrec() || !ntr.from_proto (ProtoRecordCast (field->vrec()))) return false;
  return true;
}


namespace Inner {
bool
InnerRecord::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (3);
  fb.add_int64 (this->x);
  fb.add_int64 (this->y);
  if (!this->rec.proto_add (fb)) return false;
  return true;
}
bool
InnerRecord::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 3) return false;
  this->x = fbr.pop_int64();
  this->y = fbr.pop_int64();
  if (!this->rec.proto_pop (fbr)) return false;
  return true;
}
bool
InnerRecord::to_proto (ProtoRecord &dst) const
{
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  field->set_vint64 (x);
  field = rpr.add_fields();
  field->set_vint64 (y);
  field = rpr.add_fields();
  if (!rec.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  return true;
}
bool
InnerRecord::from_proto (const ProtoRecord &src)
{
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 3) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (!field->has_vint64()) return false;
  x = field->vint64();
  field = &rpr.fields (1);
  if (!field->has_vint64()) return false;
  y = field->vint64();
  field = &rpr.fields (2);
  if (!field->has_vrec() || !rec.from_proto (ProtoRecordCast (field->vrec()))) return false;
  return true;
}

} // Inner
bool
Refer2Inner::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (1);
  if (!this->r.proto_add (fb)) return false;
  return true;
}
bool
Refer2Inner::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 1) return false;
  if (!this->r.proto_pop (fbr)) return false;
  return true;
}
bool
Refer2Inner::to_proto (ProtoRecord &dst) const
{
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  if (!r.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  return true;
}
bool
Refer2Inner::from_proto (const ProtoRecord &src)
{
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 1) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (!field->has_vrec() || !r.from_proto (ProtoRecordCast (field->vrec()))) return false;
  return true;
}

} // MandatoryNamespace

namespace OtherNamespace {
bool
SomeRecord::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (4);
  if (!this->r1.proto_add (fb)) return false;
  if (!this->r2.proto_add (fb)) return false;
  if (!this->r3.proto_add (fb)) return false;
  if (!this->r4.proto_add (fb)) return false;
  return true;
}
bool
SomeRecord::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 4) return false;
  if (!this->r1.proto_pop (fbr)) return false;
  if (!this->r2.proto_pop (fbr)) return false;
  if (!this->r3.proto_pop (fbr)) return false;
  if (!this->r4.proto_pop (fbr)) return false;
  return true;
}
bool
SomeRecord::to_proto (ProtoRecord &dst) const
{
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  if (!r1.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  field = rpr.add_fields();
  if (!r2.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  field = rpr.add_fields();
  if (!r3.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  field = rpr.add_fields();
  if (!r4.to_proto (ProtoRecordCast (*field->mutable_vrec()))) return false;
  return true;
}
bool
SomeRecord::from_proto (const ProtoRecord &src)
{
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 4) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (!field->has_vrec() || !r1.from_proto (ProtoRecordCast (field->vrec()))) return false;
  field = &rpr.fields (1);
  if (!field->has_vrec() || !r2.from_proto (ProtoRecordCast (field->vrec()))) return false;
  field = &rpr.fields (2);
  if (!field->has_vrec() || !r3.from_proto (ProtoRecordCast (field->vrec()))) return false;
  field = &rpr.fields (3);
  if (!field->has_vrec() || !r4.from_proto (ProtoRecordCast (field->vrec()))) return false;
  return true;
}

} // OtherNamespace

namespace InterfaceTests {
double
UIWidgetArea::simple_method ()
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000001);
  return 0; // FIXME
}
double
UIWidgetArea::single_arg (int n)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000002);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vint64 (n);
  return 0; // FIXME
}
double
UIWidgetArea::single_arg2 (int n)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000003);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vint64 (n);
  return 0; // FIXME
}
double
UIWidgetArea::two_args (int n,
                        double r)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000004);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vint64 (n);
  arg = rp.add_args();
  arg->set_vdouble (r);
  return 0; // FIXME
}
double
UIWidgetArea::two_args2 (int n,
                         double r)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000005);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vint64 (n);
  arg = rp.add_args();
  arg->set_vdouble (r);
  return 0; // FIXME
}
double
UIWidgetArea::multi_args (int n,
                          double r,
                          int i,
                          const std::string &s,
                          double y)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000006);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vint64 (n);
  arg = rp.add_args();
  arg->set_vdouble (r);
  arg = rp.add_args();
  arg->set_vint64 (i);
  arg = rp.add_args();
  arg->set_vstring (s);
  arg = rp.add_args();
  arg->set_vdouble (y);
  return 0; // FIXME
}
double
UIWidgetArea::self_method (UIWidgetArea &ba1,
                           UIWidgetArea &ba2)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000007);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vstring (Instance2StringCast (ba1));
  arg = rp.add_args();
  arg->set_vstring (Instance2StringCast (ba2));
  return 0; // FIXME
}
void
UIWidgetArea::void_method ()
{
  RemoteProcedure rp;
  rp.set_proc_id (0x01000008);
}
std::string
UIWidgetArea::on_click2out ()
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000009);
  return 0; // FIXME
}
void
UIWidgetArea::on_click2in (const std::string &command)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x0100000a);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vstring (command);
}





bool
QuickRecord::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (2);
  fb.add_int64 (this->int1);
  fb.add_int64 (this->int2);
  return true;
}
bool
QuickRecord::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 2) return false;
  this->int1 = fbr.pop_int64();
  this->int2 = fbr.pop_int64();
  return true;
}
bool
QuickRecord::to_proto (ProtoRecord &dst) const
{
  RemoteProcedure_Record &rpr = RPRecordCast (dst);
  RemoteProcedure_Argument *field;
  field = rpr.add_fields();
  field->set_vint64 (int1);
  field = rpr.add_fields();
  field->set_vint64 (int2);
  return true;
}
bool
QuickRecord::from_proto (const ProtoRecord &src)
{
  const RemoteProcedure_Record &rpr = RPRecordCast (src);
  if (rpr.fields_size() < 2) return false;
  const RemoteProcedure_Argument *field;
  field = &rpr.fields (0);
  if (!field->has_vint64()) return false;
  int1 = field->vint64();
  field = &rpr.fields (1);
  if (!field->has_vint64()) return false;
  int2 = field->vint64();
  return true;
}

bool
QuickSequence::proto_add (Rapicorn::Plic::FieldBuffer &dst) const
{
  const size_t len = somefloat.size();
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_double (this->somefloat[k]);
  }
  return true;
}
bool
QuickSequence::proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->somefloat.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->somefloat.push_back (fbr.pop_double());
  }
  return true;
}
bool
QuickSequence::to_proto (ProtoSequence &dst) const
{
  RemoteProcedure_Sequence &rps = RPSequenceCast (dst);
  const size_t len = somefloat.size();
  for (size_t k = 0; k < len; k++) {
    rps.add_vdouble (somefloat[k]);
  }
  return true;
}
bool
QuickSequence::from_proto (const ProtoSequence &src)
{
  const RemoteProcedure_Sequence &rps = RPSequenceCast (src);
  const size_t len = rps.vdouble_size();
  for (size_t k = 0; k < len; k++) {
    somefloat.push_back (rps.vdouble (k));
  }
  return true;
}

void
MethodTestInterface::method_with_void ()
{
  RemoteProcedure rp;
  rp.set_proc_id (0x0100000b);
}
bool
MethodTestInterface::method_with_bools (bool input,
                                        bool optval)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x0200000c);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vint64 (input);
  arg = rp.add_args();
  arg->set_vint64 (optval);
  return 0; // FIXME
}
int
MethodTestInterface::method_with_ints (int input,
                                       int optval)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x0200000d);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vint64 (input);
  arg = rp.add_args();
  arg->set_vint64 (optval);
  return 0; // FIXME
}
double
MethodTestInterface::method_with_floats (double input,
                                         double optval)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x0200000e);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vdouble (input);
  arg = rp.add_args();
  arg->set_vdouble (optval);
  return 0; // FIXME
}
std::string
MethodTestInterface::method_with_string (const std::string &input,
                                         const std::string &optval)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x0200000f);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vstring (input);
  arg = rp.add_args();
  arg->set_vstring (optval);
  return 0; // FIXME
}
QuickEnum
MethodTestInterface::method_with_enum (QuickEnum input,
                                       QuickEnum optval)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000010);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vint64 (input);
  arg = rp.add_args();
  arg->set_vint64 (optval);
  return QuickEnum (0); // FIXME
}
QuickRecord
MethodTestInterface::method_with_record (const QuickRecord &input,
                                         const QuickRecord &optval)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000011);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  if (!input.to_proto (ProtoRecordCast (*arg->mutable_vrec()))) die();
  arg = rp.add_args();
  if (!optval.to_proto (ProtoRecordCast (*arg->mutable_vrec()))) die();
  return QuickRecord(); // FIXME
}
QuickSequence
MethodTestInterface::method_with_sequence (const QuickSequence &input,
                                           const QuickSequence &optval)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000012);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  if (!input.to_proto (ProtoSequenceCast (*arg->mutable_vseq()))) die();
  arg = rp.add_args();
  if (!optval.to_proto (ProtoSequenceCast (*arg->mutable_vseq()))) die();
  return QuickSequence(); // FIXME
}
GrandChild*
MethodTestInterface::method_with_interface (GrandChild &input,
                                            GrandChild &optval)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000013);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vstring (Instance2StringCast (input));
  arg = rp.add_args();
  arg->set_vstring (Instance2StringCast (optval));
  return (GrandChild*) NULL; // FIXME
}

} // InterfaceTests

namespace RapicornPlicTest {

int
PureMethods::pure_method (double f)
{
  RemoteProcedure rp;
  rp.set_proc_id (0x02000014);
  RemoteProcedure_Argument *arg;
  arg = rp.add_args();
  arg->set_vdouble (f);
  return 0; // FIXME
}


// --- Server Stubs ---
} // RapicornPlicTest

namespace MandatoryNamespace {

namespace Inner {
} // Inner
} // MandatoryNamespace

namespace OtherNamespace {
} // OtherNamespace

namespace InterfaceTests {
static bool
call_UIWidgetArea_simple_method (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 0) return false;
  UIWidgetArea *self;
  self = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  double rval = self->simple_method ();
  rb.add_double (rval);
  return true;
}
static bool
call_UIWidgetArea_single_arg (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 1) return false;
  UIWidgetArea *self;
  self = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double rval = self->single_arg (arg_n);
  rb.add_double (rval);
  return true;
}
static bool
call_UIWidgetArea_single_arg2 (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 1) return false;
  UIWidgetArea *self;
  self = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double rval = self->single_arg2 (arg_n);
  rb.add_double (rval);
  return true;
}
static bool
call_UIWidgetArea_two_args (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 2) return false;
  UIWidgetArea *self;
  self = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double arg_r = fbr.pop_double();
  double rval = self->two_args (arg_n, arg_r);
  rb.add_double (rval);
  return true;
}
static bool
call_UIWidgetArea_two_args2 (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 2) return false;
  UIWidgetArea *self;
  self = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double arg_r = fbr.pop_double();
  double rval = self->two_args2 (arg_n, arg_r);
  rb.add_double (rval);
  return true;
}
static bool
call_UIWidgetArea_multi_args (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 5) return false;
  UIWidgetArea *self;
  self = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double arg_r = fbr.pop_double();
  int arg_i = fbr.pop_int64();
  std::string arg_s = fbr.pop_string();
  double arg_y = fbr.pop_double();
  double rval = self->multi_args (arg_n, arg_r, arg_i, arg_s, arg_y);
  rb.add_double (rval);
  return true;
}
static bool
call_UIWidgetArea_self_method (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 2) return false;
  UIWidgetArea *self;
  self = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  UIWidgetArea *arg_ba1 = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  UIWidgetArea *arg_ba2 = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  double rval = self->self_method (*arg_ba1, *arg_ba2);
  rb.add_double (rval);
  return true;
}
static bool
call_UIWidgetArea_void_method (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 0) return false;
  UIWidgetArea *self;
  self = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  self->void_method ();
  return true;
}
static bool
call_UIWidgetArea_on_click2out (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 0) return false;
  UIWidgetArea *self;
  self = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  std::string rval = self->on_click2out ();
  rb.add_string (rval);
  return true;
}
static bool
call_UIWidgetArea_on_click2in (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 1) return false;
  UIWidgetArea *self;
  self = Instance4StringCast<UIWidgetArea> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  std::string arg_command = fbr.pop_string();
  self->on_click2in (arg_command);
  return true;
}

static bool
handle_UIWidgetArea_simple_method (const RemoteProcedure    &_rope_rp,
                                   RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  UIWidgetArea *self;
  rope_check (_rope_rp.args_size() == 1, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  double _rope_retval = self->simple_method ();
  (&_rope_aret)->set_vdouble (_rope_retval);
  return true;
}
static bool
handle_UIWidgetArea_single_arg (const RemoteProcedure    &_rope_rp,
                                RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  UIWidgetArea *self;
  int n;
  rope_check (_rope_rp.args_size() == 2, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vint64()) return false;
  n = _rope_arg->vint64();
  double _rope_retval = self->single_arg (n);
  (&_rope_aret)->set_vdouble (_rope_retval);
  return true;
}
static bool
handle_UIWidgetArea_single_arg2 (const RemoteProcedure    &_rope_rp,
                                 RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  UIWidgetArea *self;
  int n;
  rope_check (_rope_rp.args_size() == 2, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vint64()) return false;
  n = _rope_arg->vint64();
  double _rope_retval = self->single_arg2 (n);
  (&_rope_aret)->set_vdouble (_rope_retval);
  return true;
}
static bool
handle_UIWidgetArea_two_args (const RemoteProcedure    &_rope_rp,
                              RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  UIWidgetArea *self;
  int n;
  double r;
  rope_check (_rope_rp.args_size() == 3, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vint64()) return false;
  n = _rope_arg->vint64();
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vdouble()) return false;
  r = _rope_arg->vdouble();
  double _rope_retval = self->two_args (n, r);
  (&_rope_aret)->set_vdouble (_rope_retval);
  return true;
}
static bool
handle_UIWidgetArea_two_args2 (const RemoteProcedure    &_rope_rp,
                               RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  UIWidgetArea *self;
  int n;
  double r;
  rope_check (_rope_rp.args_size() == 3, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vint64()) return false;
  n = _rope_arg->vint64();
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vdouble()) return false;
  r = _rope_arg->vdouble();
  double _rope_retval = self->two_args2 (n, r);
  (&_rope_aret)->set_vdouble (_rope_retval);
  return true;
}
static bool
handle_UIWidgetArea_multi_args (const RemoteProcedure    &_rope_rp,
                                RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  UIWidgetArea *self;
  int n;
  double r;
  int i;
  std::string s;
  double y;
  rope_check (_rope_rp.args_size() == 6, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vint64()) return false;
  n = _rope_arg->vint64();
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vdouble()) return false;
  r = _rope_arg->vdouble();
  _rope_arg = &_rope_rp.args (3);
  if (!_rope_arg->has_vint64()) return false;
  i = _rope_arg->vint64();
  _rope_arg = &_rope_rp.args (4);
  if (!_rope_arg->has_vstring()) return false;
  s = _rope_arg->vstring();
  _rope_arg = &_rope_rp.args (5);
  if (!_rope_arg->has_vdouble()) return false;
  y = _rope_arg->vdouble();
  double _rope_retval = self->multi_args (n, r, i, s, y);
  (&_rope_aret)->set_vdouble (_rope_retval);
  return true;
}
static bool
handle_UIWidgetArea_self_method (const RemoteProcedure    &_rope_rp,
                                 RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  UIWidgetArea *self;
  UIWidgetArea *ba1;
  UIWidgetArea *ba2;
  rope_check (_rope_rp.args_size() == 3, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vstring()) return false;
  ba1 = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vstring()) return false;
  ba2 = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  double _rope_retval = self->self_method (*ba1, *ba2);
  (&_rope_aret)->set_vdouble (_rope_retval);
  return true;
}
static bool
handle_UIWidgetArea_void_method (const RemoteProcedure    &_rope_rp,
                                 RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  UIWidgetArea *self;
  rope_check (_rope_rp.args_size() == 1, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  self->void_method ();
  return true;
}
static bool
handle_UIWidgetArea_on_click2out (const RemoteProcedure    &_rope_rp,
                                  RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  UIWidgetArea *self;
  rope_check (_rope_rp.args_size() == 1, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  std::string _rope_retval = self->on_click2out ();
  (&_rope_aret)->set_vstring (_rope_retval);
  return true;
}
static bool
handle_UIWidgetArea_on_click2in (const RemoteProcedure    &_rope_rp,
                                 RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  UIWidgetArea *self;
  std::string command;
  rope_check (_rope_rp.args_size() == 2, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<UIWidgetArea> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vstring()) return false;
  command = _rope_arg->vstring();
  self->on_click2in (command);
  return true;
}









static bool
call_MethodTestInterface_method_with_void (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 0) return false;
  MethodTestInterface *self;
  self = Instance4StringCast<MethodTestInterface> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  self->method_with_void ();
  return true;
}
static bool
call_MethodTestInterface_method_with_bools (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface *self;
  self = Instance4StringCast<MethodTestInterface> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  bool arg_input = fbr.pop_int64();
  bool arg_optval = fbr.pop_int64();
  bool rval = self->method_with_bools (arg_input, arg_optval);
  rb.add_int64 (rval);
  return true;
}
static bool
call_MethodTestInterface_method_with_ints (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface *self;
  self = Instance4StringCast<MethodTestInterface> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  int arg_input = fbr.pop_int64();
  int arg_optval = fbr.pop_int64();
  int rval = self->method_with_ints (arg_input, arg_optval);
  rb.add_int64 (rval);
  return true;
}
static bool
call_MethodTestInterface_method_with_floats (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface *self;
  self = Instance4StringCast<MethodTestInterface> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  double arg_input = fbr.pop_double();
  double arg_optval = fbr.pop_double();
  double rval = self->method_with_floats (arg_input, arg_optval);
  rb.add_double (rval);
  return true;
}
static bool
call_MethodTestInterface_method_with_string (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface *self;
  self = Instance4StringCast<MethodTestInterface> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  std::string arg_input = fbr.pop_string();
  std::string arg_optval = fbr.pop_string();
  std::string rval = self->method_with_string (arg_input, arg_optval);
  rb.add_string (rval);
  return true;
}
static bool
call_MethodTestInterface_method_with_enum (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface *self;
  self = Instance4StringCast<MethodTestInterface> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  QuickEnum arg_input = QuickEnum (fbr.pop_evalue());
  QuickEnum arg_optval = QuickEnum (fbr.pop_evalue());
  QuickEnum rval = self->method_with_enum (arg_input, arg_optval);
  rb.add_evalue (rval);
  return true;
}
static bool
call_MethodTestInterface_method_with_record (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface *self;
  self = Instance4StringCast<MethodTestInterface> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  QuickRecord arg_input;
  if (!arg_input.proto_pop (fbr)) return false;
  QuickRecord arg_optval;
  if (!arg_optval.proto_pop (fbr)) return false;
  QuickRecord rval = self->method_with_record (arg_input, arg_optval);
  if (!rval.proto_add (rb)) return false;
  return true;
}
static bool
call_MethodTestInterface_method_with_sequence (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface *self;
  self = Instance4StringCast<MethodTestInterface> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  QuickSequence arg_input;
  if (!arg_input.proto_pop (fbr)) return false;
  QuickSequence arg_optval;
  if (!arg_optval.proto_pop (fbr)) return false;
  QuickSequence rval = self->method_with_sequence (arg_input, arg_optval);
  if (!rval.proto_add (rb)) return false;
  return true;
}
static bool
call_MethodTestInterface_method_with_interface (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface *self;
  self = Instance4StringCast<MethodTestInterface> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  GrandChild *arg_input = Instance4StringCast<GrandChild> (fbr.pop_object());
  GrandChild *arg_optval = Instance4StringCast<GrandChild> (fbr.pop_object());
  GrandChild *rval = self->method_with_interface (*arg_input, *arg_optval);
  rb.add_object (Instance2StringCast (rval));
  return true;
}

static bool
handle_MethodTestInterface_method_with_void (const RemoteProcedure    &_rope_rp,
                                             RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  MethodTestInterface *self;
  rope_check (_rope_rp.args_size() == 1, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<MethodTestInterface> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  self->method_with_void ();
  return true;
}
static bool
handle_MethodTestInterface_method_with_bools (const RemoteProcedure    &_rope_rp,
                                              RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  MethodTestInterface *self;
  bool input;
  bool optval;
  rope_check (_rope_rp.args_size() == 3, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<MethodTestInterface> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vint64()) return false;
  input = _rope_arg->vint64();
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vint64()) return false;
  optval = _rope_arg->vint64();
  bool _rope_retval = self->method_with_bools (input, optval);
  (&_rope_aret)->set_vint64 (_rope_retval);
  return true;
}
static bool
handle_MethodTestInterface_method_with_ints (const RemoteProcedure    &_rope_rp,
                                             RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  MethodTestInterface *self;
  int input;
  int optval;
  rope_check (_rope_rp.args_size() == 3, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<MethodTestInterface> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vint64()) return false;
  input = _rope_arg->vint64();
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vint64()) return false;
  optval = _rope_arg->vint64();
  int _rope_retval = self->method_with_ints (input, optval);
  (&_rope_aret)->set_vint64 (_rope_retval);
  return true;
}
static bool
handle_MethodTestInterface_method_with_floats (const RemoteProcedure    &_rope_rp,
                                               RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  MethodTestInterface *self;
  double input;
  double optval;
  rope_check (_rope_rp.args_size() == 3, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<MethodTestInterface> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vdouble()) return false;
  input = _rope_arg->vdouble();
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vdouble()) return false;
  optval = _rope_arg->vdouble();
  double _rope_retval = self->method_with_floats (input, optval);
  (&_rope_aret)->set_vdouble (_rope_retval);
  return true;
}
static bool
handle_MethodTestInterface_method_with_string (const RemoteProcedure    &_rope_rp,
                                               RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  MethodTestInterface *self;
  std::string input;
  std::string optval;
  rope_check (_rope_rp.args_size() == 3, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<MethodTestInterface> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vstring()) return false;
  input = _rope_arg->vstring();
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vstring()) return false;
  optval = _rope_arg->vstring();
  std::string _rope_retval = self->method_with_string (input, optval);
  (&_rope_aret)->set_vstring (_rope_retval);
  return true;
}
static bool
handle_MethodTestInterface_method_with_enum (const RemoteProcedure    &_rope_rp,
                                             RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  MethodTestInterface *self;
  QuickEnum input;
  QuickEnum optval;
  rope_check (_rope_rp.args_size() == 3, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<MethodTestInterface> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vint64()) return false;
  input = QuickEnum (_rope_arg->vint64());
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vint64()) return false;
  optval = QuickEnum (_rope_arg->vint64());
  QuickEnum _rope_retval = self->method_with_enum (input, optval);
  (&_rope_aret)->set_vint64 (_rope_retval);
  return true;
}
static bool
handle_MethodTestInterface_method_with_record (const RemoteProcedure    &_rope_rp,
                                               RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  MethodTestInterface *self;
  QuickRecord input;
  QuickRecord optval;
  rope_check (_rope_rp.args_size() == 3, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<MethodTestInterface> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vrec() || !input.from_proto (ProtoRecordCast (_rope_arg->vrec()))) return false;
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vrec() || !optval.from_proto (ProtoRecordCast (_rope_arg->vrec()))) return false;
  QuickRecord _rope_retval = self->method_with_record (input, optval);
  if (!_rope_retval.to_proto (ProtoRecordCast (*(&_rope_aret)->mutable_vrec()))) return false;
  return true;
}
static bool
handle_MethodTestInterface_method_with_sequence (const RemoteProcedure    &_rope_rp,
                                                 RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  MethodTestInterface *self;
  QuickSequence input;
  QuickSequence optval;
  rope_check (_rope_rp.args_size() == 3, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<MethodTestInterface> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vseq() || !input.from_proto (ProtoSequenceCast (_rope_arg->vseq()))) return false;
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vseq() || !optval.from_proto (ProtoSequenceCast (_rope_arg->vseq()))) return false;
  QuickSequence _rope_retval = self->method_with_sequence (input, optval);
  if (!_rope_retval.to_proto (ProtoSequenceCast (*(&_rope_aret)->mutable_vseq()))) return false;
  return true;
}
static bool
handle_MethodTestInterface_method_with_interface (const RemoteProcedure    &_rope_rp,
                                                  RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  MethodTestInterface *self;
  GrandChild *input;
  GrandChild *optval;
  rope_check (_rope_rp.args_size() == 3, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<MethodTestInterface> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vstring()) return false;
  input = Instance4StringCast<GrandChild> (_rope_arg->vstring());
  _rope_arg = &_rope_rp.args (2);
  if (!_rope_arg->has_vstring()) return false;
  optval = Instance4StringCast<GrandChild> (_rope_arg->vstring());
  GrandChild* _rope_retval = self->method_with_interface (*input, *optval);
  (&_rope_aret)->set_vstring (Instance2StringCast (_rope_retval));
  return true;
}

} // InterfaceTests

namespace RapicornPlicTest {


static bool
call_PureMethods_pure_method (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  Rapicorn::Plic::FieldBufferReader fbr (fb);
  fbr.skip(); // proc_id
  if (fbr.remaining() != 1 + 1) return false;
  PureMethods *self;
  self = Instance4StringCast<PureMethods> (fbr.pop_object());
  rope_check (self, "self must be non-NULL");
  double arg_f = fbr.pop_double();
  int rval = self->pure_method (arg_f);
  rb.add_int64 (rval);
  return true;
}

static bool
handle_PureMethods_pure_method (const RemoteProcedure    &_rope_rp,
                                RemoteProcedure_Argument &_rope_aret)
{
  const RemoteProcedure_Argument *_rope_arg;
  PureMethods *self;
  double f;
  rope_check (_rope_rp.args_size() == 2, "invalid nuber of args");
  _rope_arg = &_rope_rp.args (0);
  if (!_rope_arg->has_vstring()) return false;
  self = Instance4StringCast<PureMethods> (_rope_arg->vstring());
  rope_check (self, "self must be non-NULL");
  _rope_arg = &_rope_rp.args (1);
  if (!_rope_arg->has_vdouble()) return false;
  f = _rope_arg->vdouble();
  int _rope_retval = self->pure_method (f);
  (&_rope_aret)->set_vint64 (_rope_retval);
  return true;
}

} // RapicornPlicTest

static bool __UNUSED__
plic_call_wrapper_switch (Rapicorn::Plic::FieldBuffer &fb, Rapicorn::Plic::FieldBuffer &rb)
{
  switch (fb.first_id()) {
  case 0x02000001: // UIWidgetArea::simple_method
    return InterfaceTests::call_UIWidgetArea_simple_method (fb, rb);
  case 0x02000002: // UIWidgetArea::single_arg
    return InterfaceTests::call_UIWidgetArea_single_arg (fb, rb);
  case 0x02000003: // UIWidgetArea::single_arg2
    return InterfaceTests::call_UIWidgetArea_single_arg2 (fb, rb);
  case 0x02000004: // UIWidgetArea::two_args
    return InterfaceTests::call_UIWidgetArea_two_args (fb, rb);
  case 0x02000005: // UIWidgetArea::two_args2
    return InterfaceTests::call_UIWidgetArea_two_args2 (fb, rb);
  case 0x02000006: // UIWidgetArea::multi_args
    return InterfaceTests::call_UIWidgetArea_multi_args (fb, rb);
  case 0x02000007: // UIWidgetArea::self_method
    return InterfaceTests::call_UIWidgetArea_self_method (fb, rb);
  case 0x01000008: // UIWidgetArea::void_method
    return InterfaceTests::call_UIWidgetArea_void_method (fb, rb);
  case 0x02000009: // UIWidgetArea::on_click2out
    return InterfaceTests::call_UIWidgetArea_on_click2out (fb, rb);
  case 0x0100000a: // UIWidgetArea::on_click2in
    return InterfaceTests::call_UIWidgetArea_on_click2in (fb, rb);
  case 0x0100000b: // MethodTestInterface::method_with_void
    return InterfaceTests::call_MethodTestInterface_method_with_void (fb, rb);
  case 0x0200000c: // MethodTestInterface::method_with_bools
    return InterfaceTests::call_MethodTestInterface_method_with_bools (fb, rb);
  case 0x0200000d: // MethodTestInterface::method_with_ints
    return InterfaceTests::call_MethodTestInterface_method_with_ints (fb, rb);
  case 0x0200000e: // MethodTestInterface::method_with_floats
    return InterfaceTests::call_MethodTestInterface_method_with_floats (fb, rb);
  case 0x0200000f: // MethodTestInterface::method_with_string
    return InterfaceTests::call_MethodTestInterface_method_with_string (fb, rb);
  case 0x02000010: // MethodTestInterface::method_with_enum
    return InterfaceTests::call_MethodTestInterface_method_with_enum (fb, rb);
  case 0x02000011: // MethodTestInterface::method_with_record
    return InterfaceTests::call_MethodTestInterface_method_with_record (fb, rb);
  case 0x02000012: // MethodTestInterface::method_with_sequence
    return InterfaceTests::call_MethodTestInterface_method_with_sequence (fb, rb);
  case 0x02000013: // MethodTestInterface::method_with_interface
    return InterfaceTests::call_MethodTestInterface_method_with_interface (fb, rb);
  case 0x02000014: // PureMethods::pure_method
    return RapicornPlicTest::call_PureMethods_pure_method (fb, rb);
  default:
    die();
  }
  return false;
}


static bool __UNUSED__
rope_callee_handler (const RemoteProcedure _rope_rp,
                     RemoteProcedure_Argument &_rope_aret)
{
  switch (_rope_rp.proc_id()) {
  case 0x02000001: // UIWidgetArea::simple_method
    return InterfaceTests::handle_UIWidgetArea_simple_method (_rope_rp, _rope_aret);
  case 0x02000002: // UIWidgetArea::single_arg
    return InterfaceTests::handle_UIWidgetArea_single_arg (_rope_rp, _rope_aret);
  case 0x02000003: // UIWidgetArea::single_arg2
    return InterfaceTests::handle_UIWidgetArea_single_arg2 (_rope_rp, _rope_aret);
  case 0x02000004: // UIWidgetArea::two_args
    return InterfaceTests::handle_UIWidgetArea_two_args (_rope_rp, _rope_aret);
  case 0x02000005: // UIWidgetArea::two_args2
    return InterfaceTests::handle_UIWidgetArea_two_args2 (_rope_rp, _rope_aret);
  case 0x02000006: // UIWidgetArea::multi_args
    return InterfaceTests::handle_UIWidgetArea_multi_args (_rope_rp, _rope_aret);
  case 0x02000007: // UIWidgetArea::self_method
    return InterfaceTests::handle_UIWidgetArea_self_method (_rope_rp, _rope_aret);
  case 0x01000008: // UIWidgetArea::void_method
    return InterfaceTests::handle_UIWidgetArea_void_method (_rope_rp, _rope_aret);
  case 0x02000009: // UIWidgetArea::on_click2out
    return InterfaceTests::handle_UIWidgetArea_on_click2out (_rope_rp, _rope_aret);
  case 0x0100000a: // UIWidgetArea::on_click2in
    return InterfaceTests::handle_UIWidgetArea_on_click2in (_rope_rp, _rope_aret);
  case 0x0100000b: // MethodTestInterface::method_with_void
    return InterfaceTests::handle_MethodTestInterface_method_with_void (_rope_rp, _rope_aret);
  case 0x0200000c: // MethodTestInterface::method_with_bools
    return InterfaceTests::handle_MethodTestInterface_method_with_bools (_rope_rp, _rope_aret);
  case 0x0200000d: // MethodTestInterface::method_with_ints
    return InterfaceTests::handle_MethodTestInterface_method_with_ints (_rope_rp, _rope_aret);
  case 0x0200000e: // MethodTestInterface::method_with_floats
    return InterfaceTests::handle_MethodTestInterface_method_with_floats (_rope_rp, _rope_aret);
  case 0x0200000f: // MethodTestInterface::method_with_string
    return InterfaceTests::handle_MethodTestInterface_method_with_string (_rope_rp, _rope_aret);
  case 0x02000010: // MethodTestInterface::method_with_enum
    return InterfaceTests::handle_MethodTestInterface_method_with_enum (_rope_rp, _rope_aret);
  case 0x02000011: // MethodTestInterface::method_with_record
    return InterfaceTests::handle_MethodTestInterface_method_with_record (_rope_rp, _rope_aret);
  case 0x02000012: // MethodTestInterface::method_with_sequence
    return InterfaceTests::handle_MethodTestInterface_method_with_sequence (_rope_rp, _rope_aret);
  case 0x02000013: // MethodTestInterface::method_with_interface
    return InterfaceTests::handle_MethodTestInterface_method_with_interface (_rope_rp, _rope_aret);
  case 0x02000014: // PureMethods::pure_method
    return RapicornPlicTest::handle_PureMethods_pure_method (_rope_rp, _rope_aret);
  default:
    die();
  }
  return false;
}


// --- Interface Implementation Helpers ---

namespace InterfaceTests {
UIWidgetArea::~UIWidgetArea () {}

Parent::~Parent () {}

Child::~Child () {}

Descendant::~Descendant () {}

GrandChild::~GrandChild () {}

MethodTestInterface::~MethodTestInterface () {}

} // InterfaceTests

namespace RapicornPlicTest {
ButtonArea::~ButtonArea () {}

PureMethods::~PureMethods () {}

} // RapicornPlicTest

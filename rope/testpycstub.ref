/* --- Generated by Rapicorn-PyCStub --- */

#include <Python.h> // must be included first to configure std headers
#include <string>

static inline PY_LONG_LONG
PyIntLong_AsLongLong (PyObject *intlong)
{
  if (PyInt_Check (intlong))
    return PyInt_AS_LONG (intlong);
  else
    return PyLong_AsLongLong (intlong);
}

enum Empty {
};
enum Enum1 {
  E1_A = 1,};
enum Enum1c {
  E1C_A = 1,};
enum Enum2 {
  E2_A = 1,  E2_B = 2,};
enum Enum2c {
  E2C_A = 1,  E2C_B = 2,};
enum Enum3 {
  E3_A = 1,  E3_B = 2,  E3_C = 3,};
enum Enum3c {
  E3C_A = 1,  E3C_B = 2,  E3C_C = 3,};
enum Enum4a {
  E4A_A = 1,  E4A_B = 2,  E4A_C = 3,  E4A_D = 4,};
enum Enum4b {
  E4B_A = 1,  E4B_B = 2,  E4B_C = 3,  E4B_D = 4,};
enum Enum4c {
  E4C_A = 1,  E4C_B = 2,  E4C_C = 3,  E4C_D = 4,};
enum Enum4d {
  E4D_A = 1,  E4D_B = 2,  E4D_C = 3,  E4D_D = 4,};
enum ExtensiveEnum {
  V1a = 1,  V1b = 1,  V2 = 2,  V3 = 3,  V4 = 4,  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,  V10 = 10,  V11 = 11,  V12 = 12,  V13 = 13,  V14 = 14,  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,  V21 = 21,  V22 = 22,  V23 = 23,  V24 = 24,  V25 = -16,  V26 = 16,  V27 = -16,  V28 = -28,  V30 = 42,  V31 = 43,  V32 = 42,  V33 = 43,  V34 = 44, // "foo"
  V35 = 42,  V36 = 42, // "foo""4"
};
struct XFooRecord;
struct NestedTypesRec;
struct NewRecord;
struct InnerRecord;
struct Refer2Inner;
struct SomeRecord;
enum ClickType {
  CLICK_ON_PRESS = 1,  CLICK_ON_RELEASE = 2,  CLICK_SLOW_REPEAT = 3,  CLICK_FAST_REPEAT = 4,  CLICK_KEY_REPEAT = 5,};
struct XFooRecord {
  bool            single_bool;
  int             single_num;
  double          single_float;
  std::string     single_string;
  int             sibling1;
  int             sibling2;
  int             multi1;
  int             multi2;
  int             multi3;
  int             multi4;
  ExtensiveEnum   enum_field;
};
static bool rope_frompy_XFooRecord (PyObject*, XFooRecord*);

struct XFooSequence {
  bool            single_bool;
};
static bool rope_frompy_XFooSequence (PyObject*, XFooSequence*);

struct ExtensiveEnumSequence {
  ExtensiveEnum   enum_elements;
};
static bool rope_frompy_ExtensiveEnumSequence (PyObject*, ExtensiveEnumSequence*);

struct NestedTypesRec {
  XFooRecord      *rec;
  XFooSequence    *seq;
};
static bool rope_frompy_NestedTypesRec (PyObject*, NestedTypesRec*);

struct NestedTypesSeq {
  NestedTypesRec  *ntr;
};
static bool rope_frompy_NestedTypesSeq (PyObject*, NestedTypesSeq*);

struct NewRecord {
  int             i;
  Enum1           enum1;
  XFooSequence    *xfs;
  NestedTypesRec  *ntr;
};
static bool rope_frompy_NewRecord (PyObject*, NewRecord*);

struct InnerRecord {
  int             x;
  int             y;
  NewRecord       *rec;
};
static bool rope_frompy_InnerRecord (PyObject*, InnerRecord*);

struct Refer2Inner {
  InnerRecord     *r;
};
static bool rope_frompy_Refer2Inner (PyObject*, Refer2Inner*);

struct SomeRecord {
  NewRecord       *r1;
  NewRecord       *r2;
  InnerRecord     *r3;
  InnerRecord     *r4;
};
static bool rope_frompy_SomeRecord (PyObject*, SomeRecord*);

static bool
rope_frompy_XFooRecord (PyObject *instance, XFooRecord *rec)
{
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) goto error;
  item = PyDict_GetItemString (dictR, "single_bool"); if (!dictR) goto error;
  rec->single_bool = PyIntLong_AsLongLong (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "single_num"); if (!dictR) goto error;
  rec->single_num = PyIntLong_AsLongLong (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "single_float"); if (!dictR) goto error;
  rec->single_float = PyFloat_AsDouble (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "single_string"); if (!dictR) goto error;
  rec->single_string = PyString_AsString (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "sibling1"); if (!dictR) goto error;
  rec->sibling1 = PyIntLong_AsLongLong (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "sibling2"); if (!dictR) goto error;
  rec->sibling2 = PyIntLong_AsLongLong (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "multi1"); if (!dictR) goto error;
  rec->multi1 = PyIntLong_AsLongLong (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "multi2"); if (!dictR) goto error;
  rec->multi2 = PyIntLong_AsLongLong (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "multi3"); if (!dictR) goto error;
  rec->multi3 = PyIntLong_AsLongLong (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "multi4"); if (!dictR) goto error;
  rec->multi4 = PyIntLong_AsLongLong (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "enum_field"); if (!dictR) goto error;
  rec->enum_field = ExtensiveEnum (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}

static bool
rope_frompy_NestedTypesRec (PyObject *instance, NestedTypesRec *rec)
{
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) goto error;
  item = PyDict_GetItemString (dictR, "rec"); if (!dictR) goto error;
  if (!rope_frompy_XFooRecord (item, rec->rec)) goto error;
  item = PyDict_GetItemString (dictR, "seq"); if (!dictR) goto error;
  if (!rope_frompy_XFooSequence (item, rec->seq)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}

static bool
rope_frompy_NewRecord (PyObject *instance, NewRecord *rec)
{
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) goto error;
  item = PyDict_GetItemString (dictR, "i"); if (!dictR) goto error;
  rec->i = PyIntLong_AsLongLong (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "enum1"); if (!dictR) goto error;
  rec->enum1 = Enum1 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "xfs"); if (!dictR) goto error;
  if (!rope_frompy_XFooSequence (item, rec->xfs)) goto error;
  item = PyDict_GetItemString (dictR, "ntr"); if (!dictR) goto error;
  if (!rope_frompy_NestedTypesRec (item, rec->ntr)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}

static bool
rope_frompy_InnerRecord (PyObject *instance, InnerRecord *rec)
{
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) goto error;
  item = PyDict_GetItemString (dictR, "x"); if (!dictR) goto error;
  rec->x = PyIntLong_AsLongLong (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "y"); if (!dictR) goto error;
  rec->y = PyIntLong_AsLongLong (item); if (PyErr_Occurred()) goto error;
  item = PyDict_GetItemString (dictR, "rec"); if (!dictR) goto error;
  if (!rope_frompy_NewRecord (item, rec->rec)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}

static bool
rope_frompy_Refer2Inner (PyObject *instance, Refer2Inner *rec)
{
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) goto error;
  item = PyDict_GetItemString (dictR, "r"); if (!dictR) goto error;
  if (!rope_frompy_InnerRecord (item, rec->r)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}

static bool
rope_frompy_SomeRecord (PyObject *instance, SomeRecord *rec)
{
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) goto error;
  item = PyDict_GetItemString (dictR, "r1"); if (!dictR) goto error;
  if (!rope_frompy_NewRecord (item, rec->r1)) goto error;
  item = PyDict_GetItemString (dictR, "r2"); if (!dictR) goto error;
  if (!rope_frompy_NewRecord (item, rec->r2)) goto error;
  item = PyDict_GetItemString (dictR, "r3"); if (!dictR) goto error;
  if (!rope_frompy_InnerRecord (item, rec->r3)) goto error;
  item = PyDict_GetItemString (dictR, "r4"); if (!dictR) goto error;
  if (!rope_frompy_InnerRecord (item, rec->r4)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}


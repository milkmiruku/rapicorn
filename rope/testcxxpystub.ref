/* --- Generated by Rapicorn-CxxPyStub --- */

#include <Python.h> // must be included first to configure std headers
#include <string>

#include <ui/protocol-pb2.hh>
typedef Rapicorn::Rope::RemoteProcedure RemoteProcedure;
typedef Rapicorn::Rope::RemoteProcedure_Sequence RemoteProcedure_Sequence;
typedef Rapicorn::Rope::RemoteProcedure_Record RemoteProcedure_Record;
typedef Rapicorn::Rope::RemoteProcedure_Argument RemoteProcedure_Argument;

#include <rapicorn-core.hh>

#define None_INCREF()   ({ Py_INCREF (Py_None); Py_None; })
#define GOTO_ERROR()    goto error
#define ERRORif(cond)   if (cond) goto error
#define ERRORifpy()     if (PyErr_Occurred()) goto error
#define ERRORpy(msg)    do { PyErr_Format (PyExc_RuntimeError, msg); goto error; } while (0)

static inline PY_LONG_LONG
PyIntLong_AsLongLong (PyObject *intlong)
{
  if (PyInt_Check (intlong))
    return PyInt_AS_LONG (intlong);
  else
    return PyLong_AsLongLong (intlong);
}

static inline std::string
PyString_As_std_string (PyObject *pystr)
{
  char *s = NULL;
  Py_ssize_t len = 0;
  PyString_AsStringAndSize (pystr, &s, &len);
  return std::string (s, len);
}

static inline std::string
PyAttr_As_std_string (PyObject *pyobj, const char *attr_name)
{
  PyObject *o = PyObject_GetAttrString (pyobj, attr_name);
  if (o)
     return PyString_As_std_string (o);
  return "";
}

static inline PyObject*
PyString_From_std_string (const std::string &s)
{
  return PyString_FromStringAndSize (s.data(), s.size());
}

static inline int
PyDict_Take_Item (PyObject *pydict, const char *key, PyObject **pyitemp)
{
  int r = PyDict_SetItemString (pydict, key, *pyitemp);
  if (r >= 0)
    {
      Py_DECREF (*pyitemp);
      *pyitemp = NULL;
    }
  return r;
}

static inline int
PyList_Take_Item (PyObject *pylist, PyObject **pyitemp)
{
  int r = PyList_Append (pylist, *pyitemp);
  if (r >= 0)
    {
      Py_DECREF (*pyitemp);
      *pyitemp = NULL;
    }
  return r;
}

static Rapicorn::Plic::FieldBuffer* plic_call_remote (Rapicorn::Plic::FieldBuffer&);
#ifndef HAVE_PLIC_CALL_REMOTE
static Rapicorn::Plic::FieldBuffer* plic_call_remote (Rapicorn::Plic::FieldBuffer&)
{ return NULL; } // testing stub
#endif

static Rapicorn::Rope::RemoteProcedure* rope_call_remote (RemoteProcedure&);
#ifndef HAVE_ROPE_CALL_REMOTE
static Rapicorn::Rope::RemoteProcedure* rope_call_remote (RemoteProcedure&)
{ return NULL; } // testing stub
#endif

enum Empty {
};
enum Enum1 {
  E1_A = 1,
};
enum Enum1c {
  E1C_A = 1,
};
enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
struct XFooRecord;
struct NestedTypesRec;
struct NewRecord;
struct InnerRecord;
struct Refer2Inner;
struct SomeRecord;
enum QuickEnum {
  ZERO = 0,
};
struct QuickRecord;
enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
static RAPICORN_UNUSED bool
plic_pyXFooRecord_proto_add (PyObject *pyrec, Rapicorn::Plic::FieldBuffer &dst)
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (11);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "single_bool"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "single_num"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "single_float"); ERRORif (!item);
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "single_string"); ERRORif (!item);
  fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "sibling1"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "sibling2"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "multi1"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "multi2"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "multi3"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "multi4"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "enum_field"); ERRORif (!item);
  fb.add_evalue (PyIntLong_AsLongLong (item)); ERRORifpy();
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyXFooRecord_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 11) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "single_bool", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "single_num", &pyfoR) < 0) goto error;
  pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
  if (PyDict_Take_Item (dictR, "single_float", &pyfoR) < 0) goto error;
  pyfoR = PyString_From_std_string (fbr.pop_string()); ERRORifpy();
  if (PyDict_Take_Item (dictR, "single_string", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "sibling1", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "sibling2", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "multi1", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "multi2", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "multi3", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "multi4", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_evalue()); ERRORifpy();
  if (PyDict_Take_Item (dictR, "enum_field", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

struct XFooSequence {
  bool            single_bool;
};
static bool rope_frompy_XFooSequence (PyObject*, RemoteProcedure_Sequence&);
static RAPICORN_UNUSED bool
plic_pyXFooSequence_proto_add (PyObject *pylist, Rapicorn::Plic::FieldBuffer &dst)
{
  const ssize_t len = PyList_Size (pylist); if (len < 0) return false;
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (pylist, k);
    fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyXFooSequence_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

struct IntSequence {
  int             numx;
};
static bool rope_frompy_IntSequence (PyObject*, RemoteProcedure_Sequence&);
static RAPICORN_UNUSED bool
plic_pyIntSequence_proto_add (PyObject *pylist, Rapicorn::Plic::FieldBuffer &dst)
{
  const ssize_t len = PyList_Size (pylist); if (len < 0) return false;
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (pylist, k);
    fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyIntSequence_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

struct FloatSequence {
  double          fractalvalue;
};
static bool rope_frompy_FloatSequence (PyObject*, RemoteProcedure_Sequence&);
static RAPICORN_UNUSED bool
plic_pyFloatSequence_proto_add (PyObject *pylist, Rapicorn::Plic::FieldBuffer &dst)
{
  const ssize_t len = PyList_Size (pylist); if (len < 0) return false;
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (pylist, k);
    fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyFloatSequence_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

struct StringSequence {
  std::string     blurb;
};
static bool rope_frompy_StringSequence (PyObject*, RemoteProcedure_Sequence&);
static RAPICORN_UNUSED bool
plic_pyStringSequence_proto_add (PyObject *pylist, Rapicorn::Plic::FieldBuffer &dst)
{
  const ssize_t len = PyList_Size (pylist); if (len < 0) return false;
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (pylist, k);
    fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyStringSequence_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyString_From_std_string (fbr.pop_string()); ERRORifpy();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

struct ExtensiveEnumSequence {
  ExtensiveEnum   enum_elements;
};
static bool rope_frompy_ExtensiveEnumSequence (PyObject*, RemoteProcedure_Sequence&);
static RAPICORN_UNUSED bool
plic_pyExtensiveEnumSequence_proto_add (PyObject *pylist, Rapicorn::Plic::FieldBuffer &dst)
{
  const ssize_t len = PyList_Size (pylist); if (len < 0) return false;
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (pylist, k);
    fb.add_evalue (PyIntLong_AsLongLong (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyExtensiveEnumSequence_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyLong_FromLongLong (fbr.pop_evalue()); ERRORifpy();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

struct RecordSequence {
  XFooRecord      *repeatedfield;
};
static bool rope_frompy_RecordSequence (PyObject*, RemoteProcedure_Sequence&);
static RAPICORN_UNUSED bool
plic_pyRecordSequence_proto_add (PyObject *pylist, Rapicorn::Plic::FieldBuffer &dst)
{
  const ssize_t len = PyList_Size (pylist); if (len < 0) return false;
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (pylist, k);
    if (!plic_pyXFooRecord_proto_add (item, fb)) goto error;
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyRecordSequence_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = plic_pyXFooRecord_proto_pop (fbr); ERRORif (!pyfoR);
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

struct SequenceSequence {
  IntSequence     *moreints;
};
static bool rope_frompy_SequenceSequence (PyObject*, RemoteProcedure_Sequence&);
static RAPICORN_UNUSED bool
plic_pySequenceSequence_proto_add (PyObject *pylist, Rapicorn::Plic::FieldBuffer &dst)
{
  const ssize_t len = PyList_Size (pylist); if (len < 0) return false;
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (pylist, k);
    if (!plic_pyIntSequence_proto_add (item, fb)) goto error;
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pySequenceSequence_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = plic_pyIntSequence_proto_pop (fbr); ERRORif (!pyfoR);
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyNestedTypesRec_proto_add (PyObject *pyrec, Rapicorn::Plic::FieldBuffer &dst)
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (2);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "rec"); ERRORif (!item);
  if (!plic_pyXFooRecord_proto_add (item, fb)) goto error;
  item = PyDict_GetItemString (dictR, "seq"); ERRORif (!item);
  if (!plic_pyXFooSequence_proto_add (item, fb)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyNestedTypesRec_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 2) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = plic_pyXFooRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "rec", &pyfoR) < 0) goto error;
  pyfoR = plic_pyXFooSequence_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "seq", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

struct NestedTypesSeq {
  NestedTypesRec  *ntr;
};
static bool rope_frompy_NestedTypesSeq (PyObject*, RemoteProcedure_Sequence&);
static RAPICORN_UNUSED bool
plic_pyNestedTypesSeq_proto_add (PyObject *pylist, Rapicorn::Plic::FieldBuffer &dst)
{
  const ssize_t len = PyList_Size (pylist); if (len < 0) return false;
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (pylist, k);
    if (!plic_pyNestedTypesRec_proto_add (item, fb)) goto error;
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyNestedTypesSeq_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = plic_pyNestedTypesRec_proto_pop (fbr); ERRORif (!pyfoR);
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyNewRecord_proto_add (PyObject *pyrec, Rapicorn::Plic::FieldBuffer &dst)
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (4);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "i"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "enum1"); ERRORif (!item);
  fb.add_evalue (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "xfs"); ERRORif (!item);
  if (!plic_pyXFooSequence_proto_add (item, fb)) goto error;
  item = PyDict_GetItemString (dictR, "ntr"); ERRORif (!item);
  if (!plic_pyNestedTypesRec_proto_add (item, fb)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyNewRecord_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 4) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "i", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_evalue()); ERRORifpy();
  if (PyDict_Take_Item (dictR, "enum1", &pyfoR) < 0) goto error;
  pyfoR = plic_pyXFooSequence_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "xfs", &pyfoR) < 0) goto error;
  pyfoR = plic_pyNestedTypesRec_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "ntr", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyInnerRecord_proto_add (PyObject *pyrec, Rapicorn::Plic::FieldBuffer &dst)
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (3);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "x"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "y"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "rec"); ERRORif (!item);
  if (!plic_pyNewRecord_proto_add (item, fb)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyInnerRecord_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 3) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "x", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "y", &pyfoR) < 0) goto error;
  pyfoR = plic_pyNewRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "rec", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyRefer2Inner_proto_add (PyObject *pyrec, Rapicorn::Plic::FieldBuffer &dst)
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (1);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "r"); ERRORif (!item);
  if (!plic_pyInnerRecord_proto_add (item, fb)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyRefer2Inner_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 1) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = plic_pyInnerRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "r", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pySomeRecord_proto_add (PyObject *pyrec, Rapicorn::Plic::FieldBuffer &dst)
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (4);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "r1"); ERRORif (!item);
  if (!plic_pyNewRecord_proto_add (item, fb)) goto error;
  item = PyDict_GetItemString (dictR, "r2"); ERRORif (!item);
  if (!plic_pyNewRecord_proto_add (item, fb)) goto error;
  item = PyDict_GetItemString (dictR, "r3"); ERRORif (!item);
  if (!plic_pyInnerRecord_proto_add (item, fb)) goto error;
  item = PyDict_GetItemString (dictR, "r4"); ERRORif (!item);
  if (!plic_pyInnerRecord_proto_add (item, fb)) goto error;
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pySomeRecord_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 4) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = plic_pyNewRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "r1", &pyfoR) < 0) goto error;
  pyfoR = plic_pyNewRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "r2", &pyfoR) < 0) goto error;
  pyfoR = plic_pyInnerRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "r3", &pyfoR) < 0) goto error;
  pyfoR = plic_pyInnerRecord_proto_pop (fbr); ERRORif (!pyfoR);
  if (PyDict_Take_Item (dictR, "r4", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

static RAPICORN_UNUSED bool
plic_pyQuickRecord_proto_add (PyObject *pyrec, Rapicorn::Plic::FieldBuffer &dst)
{
  Rapicorn::Plic::FieldBuffer &fb = dst.add_rec (2);
  bool success = false;
  PyObject *dictR = NULL, *item = NULL;
  dictR = PyObject_GetAttrString (pyrec, "__dict__"); ERRORif (!dictR);
  item = PyDict_GetItemString (dictR, "int1"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyDict_GetItemString (dictR, "int2"); ERRORif (!item);
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyQuickRecord_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 2) ERRORpy ("PLIC: marshalling error: invalid record length");
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); ERRORif (!pyinstR);
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); ERRORif (!dictR);
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "int1", &pyfoR) < 0) goto error;
  pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
  if (PyDict_Take_Item (dictR, "int2", &pyfoR) < 0) goto error;
  pyret = pyinstR;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (dictR);
  if (pyret != pyinstR)
    Py_XDECREF (pyinstR);
  return pyret;
}

struct QuickSequence {
  double          somefloat;
};
static bool rope_frompy_QuickSequence (PyObject*, RemoteProcedure_Sequence&);
static RAPICORN_UNUSED bool
plic_pyQuickSequence_proto_add (PyObject *pylist, Rapicorn::Plic::FieldBuffer &dst)
{
  const ssize_t len = PyList_Size (pylist); if (len < 0) return false;
  Rapicorn::Plic::FieldBuffer &fb = dst.add_seq (len);
  bool success = false;
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (pylist, k);
    fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  }
  success = true;
 error:
  return success;
}
static RAPICORN_UNUSED PyObject*
plic_pyQuickSequence_proto_pop (Rapicorn::Plic::FieldBufferReader &src)
{
  PyObject *listR = NULL, *pyfoR = NULL, *pyret = NULL;
  Rapicorn::Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
    if (PyList_Take_Item (listR, &pyfoR) < 0) goto error;
  }
  pyret = listR;
 error:
  Py_XDECREF (pyfoR);
  if (pyret != listR)
    Py_XDECREF (listR);
  return pyret;
}

static RAPICORN_UNUSED bool
rope_frompy_XFooRecord (PyObject *instance, RemoteProcedure_Record &rpr)
{
  RemoteProcedure_Argument *field;
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "single_bool"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "single_num"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "single_float"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vdouble (PyFloat_AsDouble (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "single_string"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  { char *s = NULL; Py_ssize_t len = 0;
    if (PyString_AsStringAndSize (item, &s, &len) < 0) GOTO_ERROR();
    field->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyDict_GetItemString (dictR, "sibling1"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "sibling2"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "multi1"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "multi2"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "multi3"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "multi4"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "enum_field"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED bool
rope_topy_XFooRecord (const RemoteProcedure_Record &rpr, PyObject **pyop)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL;
  const RemoteProcedure_Argument *field;
  bool success = false;
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); if (!pyinstR) GOTO_ERROR();
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); if (!dictR) GOTO_ERROR();
  if (rpr.fields_size() < 11) GOTO_ERROR();
  field = &rpr.fields (0);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "single_bool", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (1);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "single_num", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (2);
  if (!field->has_vdouble()) GOTO_ERROR();
  pyfoR = PyFloat_FromDouble (field->vdouble()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "single_float", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (3);
  if (!field->has_vstring()) GOTO_ERROR();
  { const std::string &sp = field->vstring();
    pyfoR = PyString_FromStringAndSize (sp.data(), sp.size()); }
  if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "single_string", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (4);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "sibling1", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (5);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "sibling2", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (6);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "multi1", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (7);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "multi2", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (8);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "multi3", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (9);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "multi4", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (10);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "enum_field", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  *pyop = (Py_INCREF (pyinstR), pyinstR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (pyinstR);
  Py_XDECREF (dictR);
  return success;
}

static bool RAPICORN_UNUSED
rope_frompy_XFooSequence (PyObject *list, RemoteProcedure_Sequence &rps)
{
  bool success = false;
  const ssize_t len = PyList_Size (list); if (len < 0) GOTO_ERROR();
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (list, k);
    rps.add_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  }
  success = true;
 error:
  return success;
}
static bool RAPICORN_UNUSED
rope_topy_XFooSequence (const RemoteProcedure_Sequence &rps, PyObject **pyop)
{
  PyObject *listR = NULL, *pyfoR = NULL;
  bool success = false;
  const size_t len = rps.vint64_size();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyLong_FromLongLong (rps.vint64 (k)); if (!pyfoR) GOTO_ERROR();
    if (PyList_SetItem (listR, k, pyfoR) < 0) GOTO_ERROR();
    pyfoR = NULL;
  }
  *pyop = (Py_INCREF (listR), listR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (listR);
  return success;
}

static bool RAPICORN_UNUSED
rope_frompy_IntSequence (PyObject *list, RemoteProcedure_Sequence &rps)
{
  bool success = false;
  const ssize_t len = PyList_Size (list); if (len < 0) GOTO_ERROR();
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (list, k);
    rps.add_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  }
  success = true;
 error:
  return success;
}
static bool RAPICORN_UNUSED
rope_topy_IntSequence (const RemoteProcedure_Sequence &rps, PyObject **pyop)
{
  PyObject *listR = NULL, *pyfoR = NULL;
  bool success = false;
  const size_t len = rps.vint64_size();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyLong_FromLongLong (rps.vint64 (k)); if (!pyfoR) GOTO_ERROR();
    if (PyList_SetItem (listR, k, pyfoR) < 0) GOTO_ERROR();
    pyfoR = NULL;
  }
  *pyop = (Py_INCREF (listR), listR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (listR);
  return success;
}

static bool RAPICORN_UNUSED
rope_frompy_FloatSequence (PyObject *list, RemoteProcedure_Sequence &rps)
{
  bool success = false;
  const ssize_t len = PyList_Size (list); if (len < 0) GOTO_ERROR();
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (list, k);
    rps.add_vdouble (PyFloat_AsDouble (item)); if (PyErr_Occurred()) GOTO_ERROR();
  }
  success = true;
 error:
  return success;
}
static bool RAPICORN_UNUSED
rope_topy_FloatSequence (const RemoteProcedure_Sequence &rps, PyObject **pyop)
{
  PyObject *listR = NULL, *pyfoR = NULL;
  bool success = false;
  const size_t len = rps.vdouble_size();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyFloat_FromDouble (rps.vdouble (k)); if (!pyfoR) GOTO_ERROR();
    if (PyList_SetItem (listR, k, pyfoR) < 0) GOTO_ERROR();
    pyfoR = NULL;
  }
  *pyop = (Py_INCREF (listR), listR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (listR);
  return success;
}

static bool RAPICORN_UNUSED
rope_frompy_StringSequence (PyObject *list, RemoteProcedure_Sequence &rps)
{
  bool success = false;
  const ssize_t len = PyList_Size (list); if (len < 0) GOTO_ERROR();
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (list, k);
    { char *s = NULL; Py_ssize_t len = 0;
      if (PyString_AsStringAndSize (item, &s, &len) < 0) GOTO_ERROR();
      rps.add_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  }
  success = true;
 error:
  return success;
}
static bool RAPICORN_UNUSED
rope_topy_StringSequence (const RemoteProcedure_Sequence &rps, PyObject **pyop)
{
  PyObject *listR = NULL, *pyfoR = NULL;
  bool success = false;
  const size_t len = rps.vstring_size();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    { const std::string &sp = rps.vstring (k);
      pyfoR = PyString_FromStringAndSize (sp.data(), sp.size()); }
    if (!pyfoR) GOTO_ERROR();
    if (PyList_SetItem (listR, k, pyfoR) < 0) GOTO_ERROR();
    pyfoR = NULL;
  }
  *pyop = (Py_INCREF (listR), listR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (listR);
  return success;
}

static bool RAPICORN_UNUSED
rope_frompy_ExtensiveEnumSequence (PyObject *list, RemoteProcedure_Sequence &rps)
{
  bool success = false;
  const ssize_t len = PyList_Size (list); if (len < 0) GOTO_ERROR();
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (list, k);
    rps.add_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  }
  success = true;
 error:
  return success;
}
static bool RAPICORN_UNUSED
rope_topy_ExtensiveEnumSequence (const RemoteProcedure_Sequence &rps, PyObject **pyop)
{
  PyObject *listR = NULL, *pyfoR = NULL;
  bool success = false;
  const size_t len = rps.vint64_size();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyLong_FromLongLong (rps.vint64 (k)); if (!pyfoR) GOTO_ERROR();
    if (PyList_SetItem (listR, k, pyfoR) < 0) GOTO_ERROR();
    pyfoR = NULL;
  }
  *pyop = (Py_INCREF (listR), listR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (listR);
  return success;
}

static bool RAPICORN_UNUSED
rope_frompy_RecordSequence (PyObject *list, RemoteProcedure_Sequence &rps)
{
  bool success = false;
  const ssize_t len = PyList_Size (list); if (len < 0) GOTO_ERROR();
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (list, k);
    if (!rope_frompy_XFooRecord (item, *rps.add_vrec())) GOTO_ERROR();
  }
  success = true;
 error:
  return success;
}
static bool RAPICORN_UNUSED
rope_topy_RecordSequence (const RemoteProcedure_Sequence &rps, PyObject **pyop)
{
  PyObject *listR = NULL, *pyfoR = NULL;
  bool success = false;
  const size_t len = rps.vrec_size();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    if (!rope_topy_XFooRecord (rps.vrec (k), &pyfoR) || !pyfoR) GOTO_ERROR();
    if (PyList_SetItem (listR, k, pyfoR) < 0) GOTO_ERROR();
    pyfoR = NULL;
  }
  *pyop = (Py_INCREF (listR), listR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (listR);
  return success;
}

static bool RAPICORN_UNUSED
rope_frompy_SequenceSequence (PyObject *list, RemoteProcedure_Sequence &rps)
{
  bool success = false;
  const ssize_t len = PyList_Size (list); if (len < 0) GOTO_ERROR();
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (list, k);
    if (!rope_frompy_IntSequence (item, *rps.add_vseq())) GOTO_ERROR();
  }
  success = true;
 error:
  return success;
}
static bool RAPICORN_UNUSED
rope_topy_SequenceSequence (const RemoteProcedure_Sequence &rps, PyObject **pyop)
{
  PyObject *listR = NULL, *pyfoR = NULL;
  bool success = false;
  const size_t len = rps.vseq_size();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    if (!rope_topy_IntSequence (rps.vseq (k), &pyfoR) || !pyfoR) GOTO_ERROR();
    if (PyList_SetItem (listR, k, pyfoR) < 0) GOTO_ERROR();
    pyfoR = NULL;
  }
  *pyop = (Py_INCREF (listR), listR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (listR);
  return success;
}

static RAPICORN_UNUSED bool
rope_frompy_NestedTypesRec (PyObject *instance, RemoteProcedure_Record &rpr)
{
  RemoteProcedure_Argument *field;
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "rec"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  if (!rope_frompy_XFooRecord (item, *field->mutable_vrec())) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "seq"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  if (!rope_frompy_XFooSequence (item, *field->mutable_vseq())) GOTO_ERROR();
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED bool
rope_topy_NestedTypesRec (const RemoteProcedure_Record &rpr, PyObject **pyop)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL;
  const RemoteProcedure_Argument *field;
  bool success = false;
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); if (!pyinstR) GOTO_ERROR();
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); if (!dictR) GOTO_ERROR();
  if (rpr.fields_size() < 2) GOTO_ERROR();
  field = &rpr.fields (0);
  if (!field->has_vrec()) GOTO_ERROR();
  if (!rope_topy_XFooRecord (field->vrec(), &pyfoR) || !pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "rec", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (1);
  if (!field->has_vseq()) GOTO_ERROR();
  if (!rope_topy_XFooSequence (field->vseq(), &pyfoR) || !pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "seq", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  *pyop = (Py_INCREF (pyinstR), pyinstR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (pyinstR);
  Py_XDECREF (dictR);
  return success;
}

static bool RAPICORN_UNUSED
rope_frompy_NestedTypesSeq (PyObject *list, RemoteProcedure_Sequence &rps)
{
  bool success = false;
  const ssize_t len = PyList_Size (list); if (len < 0) GOTO_ERROR();
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (list, k);
    if (!rope_frompy_NestedTypesRec (item, *rps.add_vrec())) GOTO_ERROR();
  }
  success = true;
 error:
  return success;
}
static bool RAPICORN_UNUSED
rope_topy_NestedTypesSeq (const RemoteProcedure_Sequence &rps, PyObject **pyop)
{
  PyObject *listR = NULL, *pyfoR = NULL;
  bool success = false;
  const size_t len = rps.vrec_size();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    if (!rope_topy_NestedTypesRec (rps.vrec (k), &pyfoR) || !pyfoR) GOTO_ERROR();
    if (PyList_SetItem (listR, k, pyfoR) < 0) GOTO_ERROR();
    pyfoR = NULL;
  }
  *pyop = (Py_INCREF (listR), listR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (listR);
  return success;
}

static RAPICORN_UNUSED bool
rope_frompy_NewRecord (PyObject *instance, RemoteProcedure_Record &rpr)
{
  RemoteProcedure_Argument *field;
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "i"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "enum1"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "xfs"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  if (!rope_frompy_XFooSequence (item, *field->mutable_vseq())) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "ntr"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  if (!rope_frompy_NestedTypesRec (item, *field->mutable_vrec())) GOTO_ERROR();
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED bool
rope_topy_NewRecord (const RemoteProcedure_Record &rpr, PyObject **pyop)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL;
  const RemoteProcedure_Argument *field;
  bool success = false;
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); if (!pyinstR) GOTO_ERROR();
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); if (!dictR) GOTO_ERROR();
  if (rpr.fields_size() < 4) GOTO_ERROR();
  field = &rpr.fields (0);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "i", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (1);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "enum1", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (2);
  if (!field->has_vseq()) GOTO_ERROR();
  if (!rope_topy_XFooSequence (field->vseq(), &pyfoR) || !pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "xfs", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (3);
  if (!field->has_vrec()) GOTO_ERROR();
  if (!rope_topy_NestedTypesRec (field->vrec(), &pyfoR) || !pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "ntr", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  *pyop = (Py_INCREF (pyinstR), pyinstR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (pyinstR);
  Py_XDECREF (dictR);
  return success;
}

static RAPICORN_UNUSED bool
rope_frompy_InnerRecord (PyObject *instance, RemoteProcedure_Record &rpr)
{
  RemoteProcedure_Argument *field;
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "x"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "y"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "rec"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  if (!rope_frompy_NewRecord (item, *field->mutable_vrec())) GOTO_ERROR();
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED bool
rope_topy_InnerRecord (const RemoteProcedure_Record &rpr, PyObject **pyop)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL;
  const RemoteProcedure_Argument *field;
  bool success = false;
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); if (!pyinstR) GOTO_ERROR();
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); if (!dictR) GOTO_ERROR();
  if (rpr.fields_size() < 3) GOTO_ERROR();
  field = &rpr.fields (0);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "x", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (1);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "y", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (2);
  if (!field->has_vrec()) GOTO_ERROR();
  if (!rope_topy_NewRecord (field->vrec(), &pyfoR) || !pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "rec", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  *pyop = (Py_INCREF (pyinstR), pyinstR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (pyinstR);
  Py_XDECREF (dictR);
  return success;
}

static RAPICORN_UNUSED bool
rope_frompy_Refer2Inner (PyObject *instance, RemoteProcedure_Record &rpr)
{
  RemoteProcedure_Argument *field;
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "r"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  if (!rope_frompy_InnerRecord (item, *field->mutable_vrec())) GOTO_ERROR();
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED bool
rope_topy_Refer2Inner (const RemoteProcedure_Record &rpr, PyObject **pyop)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL;
  const RemoteProcedure_Argument *field;
  bool success = false;
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); if (!pyinstR) GOTO_ERROR();
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); if (!dictR) GOTO_ERROR();
  if (rpr.fields_size() < 1) GOTO_ERROR();
  field = &rpr.fields (0);
  if (!field->has_vrec()) GOTO_ERROR();
  if (!rope_topy_InnerRecord (field->vrec(), &pyfoR) || !pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "r", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  *pyop = (Py_INCREF (pyinstR), pyinstR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (pyinstR);
  Py_XDECREF (dictR);
  return success;
}

static RAPICORN_UNUSED bool
rope_frompy_SomeRecord (PyObject *instance, RemoteProcedure_Record &rpr)
{
  RemoteProcedure_Argument *field;
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "r1"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  if (!rope_frompy_NewRecord (item, *field->mutable_vrec())) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "r2"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  if (!rope_frompy_NewRecord (item, *field->mutable_vrec())) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "r3"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  if (!rope_frompy_InnerRecord (item, *field->mutable_vrec())) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "r4"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  if (!rope_frompy_InnerRecord (item, *field->mutable_vrec())) GOTO_ERROR();
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED bool
rope_topy_SomeRecord (const RemoteProcedure_Record &rpr, PyObject **pyop)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL;
  const RemoteProcedure_Argument *field;
  bool success = false;
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); if (!pyinstR) GOTO_ERROR();
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); if (!dictR) GOTO_ERROR();
  if (rpr.fields_size() < 4) GOTO_ERROR();
  field = &rpr.fields (0);
  if (!field->has_vrec()) GOTO_ERROR();
  if (!rope_topy_NewRecord (field->vrec(), &pyfoR) || !pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "r1", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (1);
  if (!field->has_vrec()) GOTO_ERROR();
  if (!rope_topy_NewRecord (field->vrec(), &pyfoR) || !pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "r2", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (2);
  if (!field->has_vrec()) GOTO_ERROR();
  if (!rope_topy_InnerRecord (field->vrec(), &pyfoR) || !pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "r3", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (3);
  if (!field->has_vrec()) GOTO_ERROR();
  if (!rope_topy_InnerRecord (field->vrec(), &pyfoR) || !pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "r4", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  *pyop = (Py_INCREF (pyinstR), pyinstR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (pyinstR);
  Py_XDECREF (dictR);
  return success;
}

static PyObject*
rope__UIWidgetArea_simple_method (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000001);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 2) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vdouble()) GOTO_ERROR();
    pyfoR = PyFloat_FromDouble (cret.vdouble()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__UIWidgetArea_single_arg (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000002);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 3) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // n
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vdouble()) GOTO_ERROR();
    pyfoR = PyFloat_FromDouble (cret.vdouble()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__UIWidgetArea_single_arg2 (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000003);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 3) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // n
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vdouble()) GOTO_ERROR();
    pyfoR = PyFloat_FromDouble (cret.vdouble()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__UIWidgetArea_two_args (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000004);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 4) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // n
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 3); // r
  arg = rp.add_args();
  arg->set_vdouble (PyFloat_AsDouble (item)); if (PyErr_Occurred()) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vdouble()) GOTO_ERROR();
    pyfoR = PyFloat_FromDouble (cret.vdouble()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__UIWidgetArea_two_args2 (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000005);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 4) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // n
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 3); // r
  arg = rp.add_args();
  arg->set_vdouble (PyFloat_AsDouble (item)); if (PyErr_Occurred()) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vdouble()) GOTO_ERROR();
    pyfoR = PyFloat_FromDouble (cret.vdouble()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__UIWidgetArea_multi_args (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000006);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 7) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // n
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 3); // r
  arg = rp.add_args();
  arg->set_vdouble (PyFloat_AsDouble (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 4); // i
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 5); // s
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    if (PyString_AsStringAndSize (item, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 6); // y
  arg = rp.add_args();
  arg->set_vdouble (PyFloat_AsDouble (item)); if (PyErr_Occurred()) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vdouble()) GOTO_ERROR();
    pyfoR = PyFloat_FromDouble (cret.vdouble()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__UIWidgetArea_self_method (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000007);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 4) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // ba1
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 3); // ba2
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vdouble()) GOTO_ERROR();
    pyfoR = PyFloat_FromDouble (cret.vdouble()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__UIWidgetArea_void_method (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x01000008);
  PyObject *item;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 2) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  _rpret = rope_call_remote (rp);
  if (_rpret) { delete _rpret; _rpret = NULL; }
  return None_INCREF();
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__UIWidgetArea_on_click2out (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000009);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 2) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vstring()) GOTO_ERROR();
    { const std::string &sp = cret.vstring();
      pyfoR = PyString_FromStringAndSize (sp.data(), sp.size()); }
    if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__UIWidgetArea_on_click2in (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x0100000a);
  PyObject *item;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 3) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // command
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    if (PyString_AsStringAndSize (item, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  _rpret = rope_call_remote (rp);
  if (_rpret) { delete _rpret; _rpret = NULL; }
  return None_INCREF();
 error:
  if (_rpret) delete _rpret;
  return NULL;
}

static PyObject*
plic_pycall_UIWidgetArea_simple_method (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 0), *fr = NULL;
  fb.add_int64 (0x02000001); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 0) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_UIWidgetArea_single_arg (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 1), *fr = NULL;
  fb.add_int64 (0x02000002); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 1) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // n
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_UIWidgetArea_single_arg2 (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 1), *fr = NULL;
  fb.add_int64 (0x02000003); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 1) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // n
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_UIWidgetArea_two_args (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 2), *fr = NULL;
  fb.add_int64 (0x02000004); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // n
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 3); // r
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_UIWidgetArea_two_args2 (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 2), *fr = NULL;
  fb.add_int64 (0x02000005); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // n
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 3); // r
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_UIWidgetArea_multi_args (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 5), *fr = NULL;
  fb.add_int64 (0x02000006); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 5) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // n
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 3); // r
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 4); // i
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 5); // s
  fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 6); // y
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_UIWidgetArea_self_method (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 2), *fr = NULL;
  fb.add_int64 (0x02000007); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // ba1
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 3); // ba2
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_UIWidgetArea_void_method (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 0), *fr = NULL;
  fb.add_int64 (0x01000008); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 0) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) { delete fr; fr = NULL; }
  return None_INCREF();
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_UIWidgetArea_on_click2out (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 0), *fr = NULL;
  fb.add_int64 (0x02000009); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 0) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyString_From_std_string (fbr.pop_string()); ERRORifpy();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_UIWidgetArea_on_click2in (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 1), *fr = NULL;
  fb.add_int64 (0x0100000a); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 1) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // command
  fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) { delete fr; fr = NULL; }
  return None_INCREF();
 error:
  if (fr) delete fr;
  return NULL;
}




static RAPICORN_UNUSED bool
rope_frompy_QuickRecord (PyObject *instance, RemoteProcedure_Record &rpr)
{
  RemoteProcedure_Argument *field;
  PyObject *dictR = NULL, *item = NULL;
  bool success = false;
  dictR = PyObject_GetAttrString (instance, "__dict__"); if (!dictR) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "int1"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyDict_GetItemString (dictR, "int2"); if (!dictR) GOTO_ERROR();
  field = rpr.add_fields();
  field->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  success = true;
 error:
  Py_XDECREF (dictR);
  return success;
}
static RAPICORN_UNUSED bool
rope_topy_QuickRecord (const RemoteProcedure_Record &rpr, PyObject **pyop)
{
  PyObject *pyinstR = NULL, *dictR = NULL, *pyfoR = NULL;
  const RemoteProcedure_Argument *field;
  bool success = false;
  pyinstR = PyInstance_NewRaw ((PyObject*) &PyBaseObject_Type, NULL); if (!pyinstR) GOTO_ERROR();
  dictR = PyObject_GetAttrString (pyinstR, "__dict__"); if (!dictR) GOTO_ERROR();
  if (rpr.fields_size() < 2) GOTO_ERROR();
  field = &rpr.fields (0);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "int1", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  field = &rpr.fields (1);
  if (!field->has_vint64()) GOTO_ERROR();
  pyfoR = PyLong_FromLongLong (field->vint64()); if (!pyfoR) GOTO_ERROR();
  if (PyDict_SetItemString (dictR, "int2", pyfoR) < 0) GOTO_ERROR();
  else Py_DECREF (pyfoR);
  pyfoR = NULL;
  *pyop = (Py_INCREF (pyinstR), pyinstR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (pyinstR);
  Py_XDECREF (dictR);
  return success;
}

static bool RAPICORN_UNUSED
rope_frompy_QuickSequence (PyObject *list, RemoteProcedure_Sequence &rps)
{
  bool success = false;
  const ssize_t len = PyList_Size (list); if (len < 0) GOTO_ERROR();
  for (ssize_t k = 0; k < len; k++) {
    PyObject *item = PyList_GET_ITEM (list, k);
    rps.add_vdouble (PyFloat_AsDouble (item)); if (PyErr_Occurred()) GOTO_ERROR();
  }
  success = true;
 error:
  return success;
}
static bool RAPICORN_UNUSED
rope_topy_QuickSequence (const RemoteProcedure_Sequence &rps, PyObject **pyop)
{
  PyObject *listR = NULL, *pyfoR = NULL;
  bool success = false;
  const size_t len = rps.vdouble_size();
  listR = PyList_New (len); if (!listR) GOTO_ERROR();
  for (size_t k = 0; k < len; k++) {
    pyfoR = PyFloat_FromDouble (rps.vdouble (k)); if (!pyfoR) GOTO_ERROR();
    if (PyList_SetItem (listR, k, pyfoR) < 0) GOTO_ERROR();
    pyfoR = NULL;
  }
  *pyop = (Py_INCREF (listR), listR);
  success = true;
 error:
  Py_XDECREF (pyfoR);
  Py_XDECREF (listR);
  return success;
}

static PyObject*
rope__MethodTestInterface_method_with_void (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x0100000b);
  PyObject *item;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 2) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  _rpret = rope_call_remote (rp);
  if (_rpret) { delete _rpret; _rpret = NULL; }
  return None_INCREF();
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__MethodTestInterface_method_with_bools (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x0200000c);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 4) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // input
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 3); // optval
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vint64()) GOTO_ERROR();
    pyfoR = PyLong_FromLongLong (cret.vint64()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__MethodTestInterface_method_with_ints (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x0200000d);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 4) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // input
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 3); // optval
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vint64()) GOTO_ERROR();
    pyfoR = PyLong_FromLongLong (cret.vint64()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__MethodTestInterface_method_with_floats (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x0200000e);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 4) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // input
  arg = rp.add_args();
  arg->set_vdouble (PyFloat_AsDouble (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 3); // optval
  arg = rp.add_args();
  arg->set_vdouble (PyFloat_AsDouble (item)); if (PyErr_Occurred()) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vdouble()) GOTO_ERROR();
    pyfoR = PyFloat_FromDouble (cret.vdouble()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__MethodTestInterface_method_with_string (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x0200000f);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 4) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // input
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    if (PyString_AsStringAndSize (item, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 3); // optval
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    if (PyString_AsStringAndSize (item, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vstring()) GOTO_ERROR();
    { const std::string &sp = cret.vstring();
      pyfoR = PyString_FromStringAndSize (sp.data(), sp.size()); }
    if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__MethodTestInterface_method_with_enum (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000010);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 4) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // input
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 3); // optval
  arg = rp.add_args();
  arg->set_vint64 (PyIntLong_AsLongLong (item)); if (PyErr_Occurred()) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vint64()) GOTO_ERROR();
    pyfoR = PyLong_FromLongLong (cret.vint64()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__MethodTestInterface_method_with_record (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000011);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 4) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // input
  arg = rp.add_args();
  if (!rope_frompy_QuickRecord (item, *arg->mutable_vrec())) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 3); // optval
  arg = rp.add_args();
  if (!rope_frompy_QuickRecord (item, *arg->mutable_vrec())) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vrec()) GOTO_ERROR();
    if (!rope_topy_QuickRecord (cret.vrec(), &pyfoR) || !pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__MethodTestInterface_method_with_sequence (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000012);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 4) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // input
  arg = rp.add_args();
  if (!rope_frompy_QuickSequence (item, *arg->mutable_vseq())) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 3); // optval
  arg = rp.add_args();
  if (!rope_frompy_QuickSequence (item, *arg->mutable_vseq())) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vseq()) GOTO_ERROR();
    if (!rope_topy_QuickSequence (cret.vseq(), &pyfoR) || !pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}
static PyObject*
rope__MethodTestInterface_method_with_interface (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000013);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 4) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // input
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 3); // optval
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vstring()) GOTO_ERROR();
    { const std::string &sp = cret.vstring();
      pyfoR = PyString_FromStringAndSize (sp.data(), sp.size()); }
    if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}

static PyObject*
plic_pycall_MethodTestInterface_method_with_void (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 0), *fr = NULL;
  fb.add_int64 (0x0100000b); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 0) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) { delete fr; fr = NULL; }
  return None_INCREF();
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_MethodTestInterface_method_with_bools (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 2), *fr = NULL;
  fb.add_int64 (0x0200000c); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // input
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 3); // optval
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_MethodTestInterface_method_with_ints (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 2), *fr = NULL;
  fb.add_int64 (0x0200000d); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // input
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 3); // optval
  fb.add_int64 (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_MethodTestInterface_method_with_floats (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 2), *fr = NULL;
  fb.add_int64 (0x0200000e); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // input
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 3); // optval
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyFloat_FromDouble (fbr.pop_double()); ERRORifpy();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_MethodTestInterface_method_with_string (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 2), *fr = NULL;
  fb.add_int64 (0x0200000f); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // input
  fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 3); // optval
  fb.add_string (PyString_As_std_string (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyString_From_std_string (fbr.pop_string()); ERRORifpy();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_MethodTestInterface_method_with_enum (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 2), *fr = NULL;
  fb.add_int64 (0x02000010); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // input
  fb.add_evalue (PyIntLong_AsLongLong (item)); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 3); // optval
  fb.add_evalue (PyIntLong_AsLongLong (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyLong_FromLongLong (fbr.pop_evalue()); ERRORifpy();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_MethodTestInterface_method_with_record (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 2), *fr = NULL;
  fb.add_int64 (0x02000011); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // input
  if (!plic_pyQuickRecord_proto_add (item, fb)) goto error;
  item = PyTuple_GET_ITEM (pyargs, 3); // optval
  if (!plic_pyQuickRecord_proto_add (item, fb)) goto error;
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = plic_pyQuickRecord_proto_pop (fbr); ERRORif (!pyfoR);
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_MethodTestInterface_method_with_sequence (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 2), *fr = NULL;
  fb.add_int64 (0x02000012); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // input
  if (!plic_pyQuickSequence_proto_add (item, fb)) goto error;
  item = PyTuple_GET_ITEM (pyargs, 3); // optval
  if (!plic_pyQuickSequence_proto_add (item, fb)) goto error;
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = plic_pyQuickSequence_proto_pop (fbr); ERRORif (!pyfoR);
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static PyObject*
plic_pycall_MethodTestInterface_method_with_interface (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 2), *fr = NULL;
  fb.add_int64 (0x02000013); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 2) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // input
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 3); // optval
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyString_From_std_string (fbr.pop_string()); ERRORifpy();
          // FIXME: convert to "__rope__object__"
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}

static PyObject*
rope__PureMethods_pure_method (PyObject *_py_self, PyObject *args)
{
  RemoteProcedure rp, *_rpret = NULL;
  rp.set_proc_id (0x02000014);
  PyObject *item;
  PyObject *pyfoR;
  RemoteProcedure_Argument *arg;
  if (PyTuple_Size (args) < 3) GOTO_ERROR();
  item = PyTuple_GET_ITEM (args, 1);  // self
  arg = rp.add_args();
  { char *s = NULL; Py_ssize_t len = 0;
    PyObject *iobj = PyObject_GetAttrString (item, "__rope__object__"); if (!iobj) GOTO_ERROR();
    if (PyString_AsStringAndSize (iobj, &s, &len) < 0) GOTO_ERROR();
    arg->set_vstring (std::string (s, len)); if (PyErr_Occurred()) GOTO_ERROR(); }
  item = PyTuple_GET_ITEM (args, 2); // f
  arg = rp.add_args();
  arg->set_vdouble (PyFloat_AsDouble (item)); if (PyErr_Occurred()) GOTO_ERROR();
  _rpret = rope_call_remote (rp);
  if (!_rpret || _rpret->proc_id() != 0x02000000 || _rpret->args_size() != 1)
    { PyErr_Format (PyExc_RuntimeError, "ROPE: missing method return"); goto error; }
  { const RemoteProcedure_Argument &cret = _rpret->args (0);
    if (!cret.has_vint64()) GOTO_ERROR();
    pyfoR = PyLong_FromLongLong (cret.vint64()); if (!pyfoR) GOTO_ERROR();    return pyfoR; }
 error:
  if (_rpret) delete _rpret;
  return NULL;
}

static PyObject*
plic_pycall_PureMethods_pure_method (PyObject *pyself, PyObject *pyargs)
{
  PyObject *item, *pyfoR = NULL;
  Rapicorn::Plic::FieldBuffer fb (1 + 1 + 1), *fr = NULL;
  fb.add_int64 (0x02000014); // proc_id
  if (PyTuple_Size (pyargs) != 1 + 1 + 1) ERRORpy ("PLIC: wrong number of arguments");
  item = PyTuple_GET_ITEM (pyargs, 1);  // self
  fb.add_string (PyAttr_As_std_string (item, "__plic__object__")); ERRORifpy();
  item = PyTuple_GET_ITEM (pyargs, 2); // f
  fb.add_double (PyFloat_AsDouble (item)); ERRORifpy();
  fr = plic_call_remote (fb);
  if (fr) {
    Rapicorn::Plic::FieldBufferReader fbr (*fr);
    if (fbr.pop_int64() == 0x02000000) { // proc_id
      if (fbr.remaining() == 1) {
          pyfoR = PyLong_FromLongLong (fbr.pop_int64()); ERRORifpy ();
      }
    }
    delete fr; fr = NULL;
  }
  if (!pyfoR) ERRORpy ("PLIC: marshalling error: invalid method return");
  return pyfoR;
 error:
  if (fr) delete fr;
  return NULL;
}
static RAPICORN_UNUSED PyObject*
rope_cpy_trampoline (PyObject *_py_self, PyObject *_py_args){
  PyObject *arg0 = NULL;
  unsigned int procid = 0;
  if (PyTuple_Size (_py_args) < 1)
    return PyErr_Format (PyExc_RuntimeError, "trampoline call without arguments");
  arg0 = PyTuple_GET_ITEM (_py_args, 0);
  procid = PyInt_AsLong (arg0);
  if (PyErr_Occurred()) return NULL;
  switch (procid) {
  case 0x02000001: // UIWidgetArea::simple_method
    return rope__UIWidgetArea_simple_method (_py_self, _py_args);
  case 0x02000002: // UIWidgetArea::single_arg
    return rope__UIWidgetArea_single_arg (_py_self, _py_args);
  case 0x02000003: // UIWidgetArea::single_arg2
    return rope__UIWidgetArea_single_arg2 (_py_self, _py_args);
  case 0x02000004: // UIWidgetArea::two_args
    return rope__UIWidgetArea_two_args (_py_self, _py_args);
  case 0x02000005: // UIWidgetArea::two_args2
    return rope__UIWidgetArea_two_args2 (_py_self, _py_args);
  case 0x02000006: // UIWidgetArea::multi_args
    return rope__UIWidgetArea_multi_args (_py_self, _py_args);
  case 0x02000007: // UIWidgetArea::self_method
    return rope__UIWidgetArea_self_method (_py_self, _py_args);
  case 0x01000008: // UIWidgetArea::void_method
    return rope__UIWidgetArea_void_method (_py_self, _py_args);
  case 0x02000009: // UIWidgetArea::on_click2out
    return rope__UIWidgetArea_on_click2out (_py_self, _py_args);
  case 0x0100000a: // UIWidgetArea::on_click2in
    return rope__UIWidgetArea_on_click2in (_py_self, _py_args);
  case 0x0100000b: // MethodTestInterface::method_with_void
    return rope__MethodTestInterface_method_with_void (_py_self, _py_args);
  case 0x0200000c: // MethodTestInterface::method_with_bools
    return rope__MethodTestInterface_method_with_bools (_py_self, _py_args);
  case 0x0200000d: // MethodTestInterface::method_with_ints
    return rope__MethodTestInterface_method_with_ints (_py_self, _py_args);
  case 0x0200000e: // MethodTestInterface::method_with_floats
    return rope__MethodTestInterface_method_with_floats (_py_self, _py_args);
  case 0x0200000f: // MethodTestInterface::method_with_string
    return rope__MethodTestInterface_method_with_string (_py_self, _py_args);
  case 0x02000010: // MethodTestInterface::method_with_enum
    return rope__MethodTestInterface_method_with_enum (_py_self, _py_args);
  case 0x02000011: // MethodTestInterface::method_with_record
    return rope__MethodTestInterface_method_with_record (_py_self, _py_args);
  case 0x02000012: // MethodTestInterface::method_with_sequence
    return rope__MethodTestInterface_method_with_sequence (_py_self, _py_args);
  case 0x02000013: // MethodTestInterface::method_with_interface
    return rope__MethodTestInterface_method_with_interface (_py_self, _py_args);
  case 0x02000014: // PureMethods::pure_method
    return rope__PureMethods_pure_method (_py_self, _py_args);
  default:
    return PyErr_Format (PyExc_RuntimeError, "ROPE: unknown method id: 0x%08x", procid);
  }
}
static RAPICORN_UNUSED PyObject*
plic_cpy_trampoline (PyObject *pyself, PyObject *pyargs){
  PyObject *arg0 = NULL;
  unsigned int procid = 0;
  if (PyTuple_Size (pyargs) < 1)
    return PyErr_Format (PyExc_RuntimeError, "PLIC: pyc trampoline without arguments");
  arg0 = PyTuple_GET_ITEM (pyargs, 0);
  procid = PyInt_AsLong (arg0);
  if (PyErr_Occurred()) return NULL;
  switch (procid) {
  case 0x02000001: // UIWidgetArea::simple_method
    return plic_pycall_UIWidgetArea_simple_method (pyself, pyargs);
  case 0x02000002: // UIWidgetArea::single_arg
    return plic_pycall_UIWidgetArea_single_arg (pyself, pyargs);
  case 0x02000003: // UIWidgetArea::single_arg2
    return plic_pycall_UIWidgetArea_single_arg2 (pyself, pyargs);
  case 0x02000004: // UIWidgetArea::two_args
    return plic_pycall_UIWidgetArea_two_args (pyself, pyargs);
  case 0x02000005: // UIWidgetArea::two_args2
    return plic_pycall_UIWidgetArea_two_args2 (pyself, pyargs);
  case 0x02000006: // UIWidgetArea::multi_args
    return plic_pycall_UIWidgetArea_multi_args (pyself, pyargs);
  case 0x02000007: // UIWidgetArea::self_method
    return plic_pycall_UIWidgetArea_self_method (pyself, pyargs);
  case 0x01000008: // UIWidgetArea::void_method
    return plic_pycall_UIWidgetArea_void_method (pyself, pyargs);
  case 0x02000009: // UIWidgetArea::on_click2out
    return plic_pycall_UIWidgetArea_on_click2out (pyself, pyargs);
  case 0x0100000a: // UIWidgetArea::on_click2in
    return plic_pycall_UIWidgetArea_on_click2in (pyself, pyargs);
  case 0x0100000b: // MethodTestInterface::method_with_void
    return plic_pycall_MethodTestInterface_method_with_void (pyself, pyargs);
  case 0x0200000c: // MethodTestInterface::method_with_bools
    return plic_pycall_MethodTestInterface_method_with_bools (pyself, pyargs);
  case 0x0200000d: // MethodTestInterface::method_with_ints
    return plic_pycall_MethodTestInterface_method_with_ints (pyself, pyargs);
  case 0x0200000e: // MethodTestInterface::method_with_floats
    return plic_pycall_MethodTestInterface_method_with_floats (pyself, pyargs);
  case 0x0200000f: // MethodTestInterface::method_with_string
    return plic_pycall_MethodTestInterface_method_with_string (pyself, pyargs);
  case 0x02000010: // MethodTestInterface::method_with_enum
    return plic_pycall_MethodTestInterface_method_with_enum (pyself, pyargs);
  case 0x02000011: // MethodTestInterface::method_with_record
    return plic_pycall_MethodTestInterface_method_with_record (pyself, pyargs);
  case 0x02000012: // MethodTestInterface::method_with_sequence
    return plic_pycall_MethodTestInterface_method_with_sequence (pyself, pyargs);
  case 0x02000013: // MethodTestInterface::method_with_interface
    return plic_pycall_MethodTestInterface_method_with_interface (pyself, pyargs);
  case 0x02000014: // PureMethods::pure_method
    return plic_pycall_PureMethods_pure_method (pyself, pyargs);
  default:
    return PyErr_Format (PyExc_RuntimeError, "PLIC: unknown method id: 0x%08x", procid);
  }
}

#include <rapicorn.hh>

/* --- Generated by PLIC-CxxCaller --- */

// --- ServerHH Boilerplate ---
#include <rcore/plicutils.hh>
#include <rcore/rapicornsignal.hh>
using Rapicorn::Signals::slot;

// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {
enum Empty {
};
enum Enum1 {
  E1_A = 1,
};
enum Enum1c {
  E1C_A = 1,
};
enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};

class I_FirstInterface_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_FirstInterface_Interface ();
  virtual /*Des*/         ~I_FirstInterface_Interface () = 0;
public:
  virtual void            void_func ();
};

class FirstInterface_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline FirstInterface_SmartHandle () {}
  inline FirstInterface_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline FirstInterface_SmartHandle (I_FirstInterface_Interface *iface) { _iface (iface); }
  inline FirstInterface_SmartHandle (I_FirstInterface_Interface &iface) { _iface (&iface); }
  // void            void_func ();
  inline I_FirstInterface_Interface& operator*  () const { return *dynamic_cast<I_FirstInterface_Interface*> (_iface()); }
  inline I_FirstInterface_Interface* operator-> () const { return dynamic_cast<I_FirstInterface_Interface*> (_iface()); }
  inline operator  I_FirstInterface_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

struct XFooRecord {
  bool            single_bool;
  int             single_num;
  double          single_float;
  std::string     single_string;
  int             sibling1;
  int             sibling2;
  int             multi1;
  int             multi2;
  int             multi3;
  int             multi4;
  ExtensiveEnum   enum_field;
  FirstInterface_SmartHandle iface1;
  FirstInterface_SmartHandle iface2;
  FirstInterface_SmartHandle iface3;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline XFooRecord () { single_bool = 0; single_num = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
struct XFooSequence {
  typedef std::vector<bool> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        single_bool;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct IntSequence {
  typedef std::vector<int> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        numx;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct FloatSequence {
  typedef std::vector<double> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        fractalvalue;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct StringSequence {
  typedef std::vector<std::string> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        blurb;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct ExtensiveEnumSequence {
  typedef std::vector<ExtensiveEnum> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        enum_elements;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct RecordSequence {
  typedef std::vector<XFooRecord> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        repeatedfield;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct SequenceSequence {
  typedef std::vector<IntSequence> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        moreints;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct InterfaceSequence {
  typedef std::vector<FirstInterface_SmartHandle> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        iface1;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct NestedTypesRec {
  XFooRecord      rec;
  XFooSequence    seq;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline NestedTypesRec () { }
};
struct NestedTypesSeq {
  typedef std::vector<NestedTypesRec> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        ntr;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
typedef int AliasInt;
typedef double AliasFloat;
typedef bool AliasBool;
typedef std::string AliasString;
typedef XFooRecord AliasRecord;
typedef XFooSequence AliasSequence;
typedef ExtensiveEnum AliasEnum;
struct NewRecord {
  int             i;
  Enum1           enum1;
  XFooSequence    xfs;
  NestedTypesRec  ntr;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline NewRecord () { i = 0; enum1 = Enum1 (0); }
};

namespace Inner {
struct InnerRecord {
  int             x;
  int             y;
  NewRecord       rec;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline InnerRecord () { x = 0; y = 0; }
};
} // Inner
struct Refer2Inner {
  Inner::InnerRecord r;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline Refer2Inner () { }
};
} // MandatoryNamespace

namespace OtherNamespace {
struct SomeRecord {
  MandatoryNamespace::NewRecord r1;
  MandatoryNamespace::NewRecord r2;
  MandatoryNamespace::Inner::InnerRecord r3;
  MandatoryNamespace::Inner::InnerRecord r4;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline SomeRecord () { }
};
} // OtherNamespace

namespace Auxdata {
typedef int bar;
typedef double x;
typedef std::string s;
} // Auxdata

namespace InterfaceTests {

class I_UIWidgetArea_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_UIWidgetArea_Interface ();
  virtual /*Des*/         ~I_UIWidgetArea_Interface () = 0;
public:
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, double (I_UIWidgetArea_Interface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double          simple_method ();
  virtual double          single_arg    (int n);
  virtual double          single_arg2   (int n = 5);
  virtual double          two_args      (int n,
                                         double r);
  virtual double          two_args2     (int n = 6,
                                         double r = 7.7);
  virtual double          multi_args    (int n,
                                         double r,
                                         int i,
                                         const std::string &s = "String ding",
                                         double y = 5);
  virtual double          self_method   (I_UIWidgetArea_Interface &ba1,
                                         I_UIWidgetArea_Interface &ba2);
  virtual void            void_method   ();
  virtual std::string     on_click2out  ();
  virtual void            on_click2in   (const std::string &command);
};

class UIWidgetArea_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline UIWidgetArea_SmartHandle () {}
  inline UIWidgetArea_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline UIWidgetArea_SmartHandle (I_UIWidgetArea_Interface *iface) { _iface (iface); }
  inline UIWidgetArea_SmartHandle (I_UIWidgetArea_Interface &iface) { _iface (&iface); }
  // double          simple_method ();
  // double          single_arg    (int);
  // double          single_arg2   (int);
  // double          two_args      (int, double);
  // double          two_args2     (int, double);
  // double          multi_args    (int, double, int, const std::string&, double);
  // double          self_method   (UIWidgetArea_SmartHandle&, UIWidgetArea_SmartHandle&);
  // void            void_method   ();
  // std::string     on_click2out  ();
  // void            on_click2in   (const std::string&);
  inline I_UIWidgetArea_Interface& operator*  () const { return *dynamic_cast<I_UIWidgetArea_Interface*> (_iface()); }
  inline I_UIWidgetArea_Interface* operator-> () const { return dynamic_cast<I_UIWidgetArea_Interface*> (_iface()); }
  inline operator  I_UIWidgetArea_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_Parent_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_Parent_Interface ();
  virtual /*Des*/         ~I_Parent_Interface () = 0;
public:
};

class Parent_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline Parent_SmartHandle () {}
  inline Parent_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline Parent_SmartHandle (I_Parent_Interface *iface) { _iface (iface); }
  inline Parent_SmartHandle (I_Parent_Interface &iface) { _iface (&iface); }
  inline I_Parent_Interface& operator*  () const { return *dynamic_cast<I_Parent_Interface*> (_iface()); }
  inline I_Parent_Interface* operator-> () const { return dynamic_cast<I_Parent_Interface*> (_iface()); }
  inline operator  I_Parent_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_Child_Interface : public virtual I_Parent_Interface {
protected:
  explicit                 I_Child_Interface ();
  virtual /*Des*/         ~I_Child_Interface () = 0;
public:
};

class Child_SmartHandle : public Parent_SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline Child_SmartHandle () {}
  inline Child_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline Child_SmartHandle (I_Child_Interface *iface) { _iface (iface); }
  inline Child_SmartHandle (I_Child_Interface &iface) { _iface (&iface); }
  inline I_Child_Interface& operator*  () const { return *dynamic_cast<I_Child_Interface*> (_iface()); }
  inline I_Child_Interface* operator-> () const { return dynamic_cast<I_Child_Interface*> (_iface()); }
  inline operator  I_Child_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_Descendant_Interface : public virtual I_Child_Interface {
protected:
  explicit                 I_Descendant_Interface ();
  virtual /*Des*/         ~I_Descendant_Interface () = 0;
public:
};

class Descendant_SmartHandle : public Child_SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline Descendant_SmartHandle () {}
  inline Descendant_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline Descendant_SmartHandle (I_Descendant_Interface *iface) { _iface (iface); }
  inline Descendant_SmartHandle (I_Descendant_Interface &iface) { _iface (&iface); }
  inline I_Descendant_Interface& operator*  () const { return *dynamic_cast<I_Descendant_Interface*> (_iface()); }
  inline I_Descendant_Interface* operator-> () const { return dynamic_cast<I_Descendant_Interface*> (_iface()); }
  inline operator  I_Descendant_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_GrandChild_Interface : public virtual I_Descendant_Interface {
protected:
  explicit                 I_GrandChild_Interface ();
  virtual /*Des*/         ~I_GrandChild_Interface () = 0;
public:
};

class GrandChild_SmartHandle : public Descendant_SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline GrandChild_SmartHandle () {}
  inline GrandChild_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline GrandChild_SmartHandle (I_GrandChild_Interface *iface) { _iface (iface); }
  inline GrandChild_SmartHandle (I_GrandChild_Interface &iface) { _iface (&iface); }
  inline I_GrandChild_Interface& operator*  () const { return *dynamic_cast<I_GrandChild_Interface*> (_iface()); }
  inline I_GrandChild_Interface* operator-> () const { return dynamic_cast<I_GrandChild_Interface*> (_iface()); }
  inline operator  I_GrandChild_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

enum QuickEnum {
  ZERO = 0,
};
struct QuickRecord {
  int             int1;
  int             int2;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline QuickRecord () { int1 = 0; int2 = 0; }
};
struct QuickSequence {
  typedef std::vector<double> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        somefloat;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};

class I_QuickIface_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_QuickIface_Interface ();
  virtual /*Des*/         ~I_QuickIface_Interface () = 0;
public:
  virtual void            simple_function (int i = 9);
};

class QuickIface_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline QuickIface_SmartHandle () {}
  inline QuickIface_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline QuickIface_SmartHandle (I_QuickIface_Interface *iface) { _iface (iface); }
  inline QuickIface_SmartHandle (I_QuickIface_Interface &iface) { _iface (&iface); }
  // void            simple_function (int);
  inline I_QuickIface_Interface& operator*  () const { return *dynamic_cast<I_QuickIface_Interface*> (_iface()); }
  inline I_QuickIface_Interface* operator-> () const { return dynamic_cast<I_QuickIface_Interface*> (_iface()); }
  inline operator  I_QuickIface_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_MethodTestInterface_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_MethodTestInterface_Interface ();
  virtual /*Des*/         ~I_MethodTestInterface_Interface () = 0;
public:
  virtual void            method_with_void       ();
  virtual bool            method_with_bools      (bool input,
                                                  bool optval = 0);
  virtual int             method_with_ints       (int input,
                                                  int optval = -2);
  virtual double          method_with_floats     (double input,
                                                  double optval = 309.9);
  virtual std::string     method_with_string     (const std::string &input,
                                                  const std::string &optval = "default");
  virtual QuickEnum       method_with_enum       (QuickEnum input,
                                                  QuickEnum optval = QuickEnum (0));
  virtual QuickRecord     method_with_record     (const QuickRecord &input,
                                                  const QuickRecord &optval = QuickRecord());
  virtual QuickSequence   method_with_sequence   (const QuickSequence &input,
                                                  const QuickSequence &optval = QuickSequence());
  virtual I_GrandChild_Interface* method_with_interface  (I_GrandChild_Interface &input,
                                                          I_GrandChild_Interface &optval = *(I_GrandChild_Interface*) NULL);
  virtual I_QuickIface_Interface* method_with_quickiface (I_QuickIface_Interface &input,
                                                          I_QuickIface_Interface &iface0 = *(I_QuickIface_Interface*) NULL);
};

class MethodTestInterface_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline MethodTestInterface_SmartHandle () {}
  inline MethodTestInterface_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline MethodTestInterface_SmartHandle (I_MethodTestInterface_Interface *iface) { _iface (iface); }
  inline MethodTestInterface_SmartHandle (I_MethodTestInterface_Interface &iface) { _iface (&iface); }
  // void            method_with_void       ();
  // bool            method_with_bools      (bool, bool);
  // int             method_with_ints       (int, int);
  // double          method_with_floats     (double, double);
  // std::string     method_with_string     (const std::string&, const std::string&);
  // QuickEnum       method_with_enum       (QuickEnum, QuickEnum);
  // QuickRecord     method_with_record     (const QuickRecord&, const QuickRecord&);
  // QuickSequence   method_with_sequence   (const QuickSequence&, const QuickSequence&);
  // GrandChild_SmartHandle method_with_interface  (GrandChild_SmartHandle&, GrandChild_SmartHandle&);
  // QuickIface_SmartHandle method_with_quickiface (QuickIface_SmartHandle&, QuickIface_SmartHandle&);
  inline I_MethodTestInterface_Interface& operator*  () const { return *dynamic_cast<I_MethodTestInterface_Interface*> (_iface()); }
  inline I_MethodTestInterface_Interface* operator-> () const { return dynamic_cast<I_MethodTestInterface_Interface*> (_iface()); }
  inline operator  I_MethodTestInterface_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_SignalTestInterface_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_SignalTestInterface_Interface ();
  virtual /*Des*/         ~I_SignalTestInterface_Interface () = 0;
public:
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, bool ()> Signal_bool_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, int ()> Signal_int_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, double ()> Signal_float_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, std::string ()> Signal_string_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickRecord ()> Signal_record_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickSequence ()> Signal_sequence_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_GrandChild_Interface* ()> Signal_interface_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_SignalTestInterface_Interface* ()> Signal_self_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (int i)> Signal_int_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (double f)> Signal_float_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickRecord &r)> Signal_record_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickSequence &s)> Signal_sequence_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_GrandChild_Interface &i)> Signal_interface_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_SignalTestInterface_Interface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int_result sig_int_result;
  Signal_float_result sig_float_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int_arg sig_int_arg;
  Signal_float_arg sig_float_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_self_args sig_self_args;
};

class SignalTestInterface_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline SignalTestInterface_SmartHandle () {}
  inline SignalTestInterface_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline SignalTestInterface_SmartHandle (I_SignalTestInterface_Interface *iface) { _iface (iface); }
  inline SignalTestInterface_SmartHandle (I_SignalTestInterface_Interface &iface) { _iface (&iface); }
  inline I_SignalTestInterface_Interface& operator*  () const { return *dynamic_cast<I_SignalTestInterface_Interface*> (_iface()); }
  inline I_SignalTestInterface_Interface* operator-> () const { return dynamic_cast<I_SignalTestInterface_Interface*> (_iface()); }
  inline operator  I_SignalTestInterface_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

} // InterfaceTests

namespace RapicornPlicTest {
enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};

class I_ButtonArea_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_ButtonArea_Interface ();
  virtual /*Des*/         ~I_ButtonArea_Interface () = 0;
public:
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, bool (), Rapicorn::Signals::CollectorUntil0<bool> > Signal_check_activate;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};

class ButtonArea_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline ButtonArea_SmartHandle () {}
  inline ButtonArea_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline ButtonArea_SmartHandle (I_ButtonArea_Interface *iface) { _iface (iface); }
  inline ButtonArea_SmartHandle (I_ButtonArea_Interface &iface) { _iface (&iface); }
  inline I_ButtonArea_Interface& operator*  () const { return *dynamic_cast<I_ButtonArea_Interface*> (_iface()); }
  inline I_ButtonArea_Interface* operator-> () const { return dynamic_cast<I_ButtonArea_Interface*> (_iface()); }
  inline operator  I_ButtonArea_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_PureMethods_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_PureMethods_Interface ();
  virtual /*Des*/         ~I_PureMethods_Interface () = 0;
public:
  virtual int             pure_method (double f) = 0;
};

class PureMethods_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline PureMethods_SmartHandle () {}
  inline PureMethods_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline PureMethods_SmartHandle (I_PureMethods_Interface *iface) { _iface (iface); }
  inline PureMethods_SmartHandle (I_PureMethods_Interface &iface) { _iface (&iface); }
  // int             pure_method (double);
  inline I_PureMethods_Interface& operator*  () const { return *dynamic_cast<I_PureMethods_Interface*> (_iface()); }
  inline I_PureMethods_Interface* operator-> () const { return dynamic_cast<I_PureMethods_Interface*> (_iface()); }
  inline operator  I_PureMethods_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

} // RapicornPlicTest

// --- Interface Skeletons ---

namespace MandatoryNamespace {

void
MandatoryNamespace::I_FirstInterface_Interface::void_func ()
{
}
} // MandatoryNamespace

namespace InterfaceTests {

double
InterfaceTests::I_UIWidgetArea_Interface::simple_method ()
{
  return 0;
}

double
I_UIWidgetArea_Interface::single_arg (int n)
{
  return 0;
}

double
I_UIWidgetArea_Interface::single_arg2 (int n)
{
  return 0;
}

double
I_UIWidgetArea_Interface::two_args (int n,
                                    double r)
{
  return 0;
}

double
I_UIWidgetArea_Interface::two_args2 (int n,
                                     double r)
{
  return 0;
}

double
I_UIWidgetArea_Interface::multi_args (int n,
                                      double r,
                                      int i,
                                      const std::string &s,
                                      double y)
{
  return 0;
}

double
I_UIWidgetArea_Interface::self_method (I_UIWidgetArea_Interface &ba1,
                                       I_UIWidgetArea_Interface &ba2)
{
  return 0;
}

void
I_UIWidgetArea_Interface::void_method ()
{
}

std::string
I_UIWidgetArea_Interface::on_click2out ()
{
  return 0;
}

void
I_UIWidgetArea_Interface::on_click2in (const std::string &command)
{
}

void
I_QuickIface_Interface::simple_function (int i)
{
}

void
I_MethodTestInterface_Interface::method_with_void ()
{
}

bool
I_MethodTestInterface_Interface::method_with_bools (bool input,
                                                    bool optval)
{
  return 0;
}

int
I_MethodTestInterface_Interface::method_with_ints (int input,
                                                   int optval)
{
  return 0;
}

double
I_MethodTestInterface_Interface::method_with_floats (double input,
                                                     double optval)
{
  return 0;
}

std::string
I_MethodTestInterface_Interface::method_with_string (const std::string &input,
                                                     const std::string &optval)
{
  return 0;
}

QuickEnum
I_MethodTestInterface_Interface::method_with_enum (QuickEnum input,
                                                   QuickEnum optval)
{
  return QuickEnum (0);
}

QuickRecord
I_MethodTestInterface_Interface::method_with_record (const QuickRecord &input,
                                                     const QuickRecord &optval)
{
  return QuickRecord();
}

QuickSequence
I_MethodTestInterface_Interface::method_with_sequence (const QuickSequence &input,
                                                       const QuickSequence &optval)
{
  return QuickSequence();
}

I_GrandChild_Interface*
I_MethodTestInterface_Interface::method_with_interface (I_GrandChild_Interface &input,
                                                        I_GrandChild_Interface &optval)
{
  return (I_GrandChild_Interface*) NULL;
}

I_QuickIface_Interface*
I_MethodTestInterface_Interface::method_with_quickiface (I_QuickIface_Interface &input,
                                                         I_QuickIface_Interface &iface0)
{
  return (I_QuickIface_Interface*) NULL;
}
} // InterfaceTests


#include <rapicorn.hh>

/* --- Generated by PLIC-CxxStub --- */

// --- ServerHH Boilerplate ---
#include <rcore/plicutils.hh>
#include <rcore/rapicornsignal.hh>
using Rapicorn::Signals::slot;

// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

enum Empty {
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Empty &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Empty &e) { e = Empty (frr.pop_evalue()); return frr; }

enum Enum1 {
  E1_A = 1,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum1 &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum1 &e) { e = Enum1 (frr.pop_evalue()); return frr; }

enum Enum1c {
  E1C_A = 1,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum1c &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum1c &e) { e = Enum1c (frr.pop_evalue()); return frr; }

enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum2 &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum2 &e) { e = Enum2 (frr.pop_evalue()); return frr; }

enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum2c &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum2c &e) { e = Enum2c (frr.pop_evalue()); return frr; }

enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum3 &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum3 &e) { e = Enum3 (frr.pop_evalue()); return frr; }

enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum3c &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum3c &e) { e = Enum3c (frr.pop_evalue()); return frr; }

enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum4a &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum4a &e) { e = Enum4a (frr.pop_evalue()); return frr; }

enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum4b &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum4b &e) { e = Enum4b (frr.pop_evalue()); return frr; }

enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum4c &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum4c &e) { e = Enum4c (frr.pop_evalue()); return frr; }

enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  Enum4d &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, Enum4d &e) { e = Enum4d (frr.pop_evalue()); return frr; }

enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  ExtensiveEnum &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, ExtensiveEnum &e) { e = ExtensiveEnum (frr.pop_evalue()); return frr; }

class I_FirstInterface_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class FirstInterface.
{
protected:
  explicit                               I_FirstInterface_Interface ();
  virtual /*Des*/                       ~I_FirstInterface_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
  virtual void                          void_func                  ();
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_FirstInterface_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_FirstInterface_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_FirstInterface_Interface*&);

struct XFooRecordImpl {
  bool                          single_bool;
  int                           single_num;
  double                        single_float;
  std::string                   single_string;
  int                           sibling1;
  int                           sibling2;
  int                           multi1;
  int                           multi2;
  int                           multi3;
  int                           multi4;
  ExtensiveEnum                 enum_field;
  I_FirstInterface_Interface*   iface1;
  I_FirstInterface_Interface*   iface2;
  I_FirstInterface_Interface*   iface3;
  inline                        XFooRecordImpl () { single_bool = 0; single_num = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const XFooRecordImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, XFooRecordImpl&);

struct XFooSequenceImpl : public std::vector<bool> {
  typedef std::vector<bool> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const XFooSequenceImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, XFooSequenceImpl&);

struct IntSequenceImpl : public std::vector<int> {
  typedef std::vector<int> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const IntSequenceImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, IntSequenceImpl&);

struct FloatSequenceImpl : public std::vector<double> {
  typedef std::vector<double> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const FloatSequenceImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, FloatSequenceImpl&);

struct StringSequenceImpl : public std::vector<std::string> {
  typedef std::vector<std::string> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const StringSequenceImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, StringSequenceImpl&);

struct ExtensiveEnumSequenceImpl : public std::vector<ExtensiveEnum> {
  typedef std::vector<ExtensiveEnum> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const ExtensiveEnumSequenceImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, ExtensiveEnumSequenceImpl&);

struct RecordSequenceImpl : public std::vector<XFooRecordImpl> {
  typedef std::vector<XFooRecordImpl> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const RecordSequenceImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, RecordSequenceImpl&);

struct SequenceSequenceImpl : public std::vector<IntSequenceImpl> {
  typedef std::vector<IntSequenceImpl> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const SequenceSequenceImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, SequenceSequenceImpl&);

struct InterfaceSequenceImpl : public std::vector<I_FirstInterface_Interface*> {
  typedef std::vector<I_FirstInterface_Interface*> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const InterfaceSequenceImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, InterfaceSequenceImpl&);

struct NestedTypesRecImpl {
  XFooRecordImpl                rec;
  XFooSequenceImpl              seq;
  inline                        NestedTypesRecImpl () { }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const NestedTypesRecImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, NestedTypesRecImpl&);

struct NestedTypesSeqImpl : public std::vector<NestedTypesRecImpl> {
  typedef std::vector<NestedTypesRecImpl> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const NestedTypesSeqImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, NestedTypesSeqImpl&);

typedef int AliasInt;

typedef double AliasFloat;

typedef bool AliasBool;

typedef std::string AliasString;

typedef XFooRecordImpl AliasRecord;

typedef XFooSequenceImpl AliasSequence;

typedef ExtensiveEnum AliasEnum;

struct NewRecordImpl {
  int                           i;
  Enum1                         enum1;
  XFooSequenceImpl              xfs;
  NestedTypesRecImpl            ntr;
  inline                        NewRecordImpl () { i = 0; enum1 = Enum1 (0); }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const NewRecordImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, NewRecordImpl&);

namespace Inner {

struct InnerRecordImpl {
  int                           x;
  int                           y;
  NewRecordImpl                 rec;
  inline                        InnerRecordImpl () { x = 0; y = 0; }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const InnerRecordImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, InnerRecordImpl&);
} // Inner

struct Refer2InnerImpl {
  Inner::InnerRecordImpl        r;
  inline                        Refer2InnerImpl () { }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const Refer2InnerImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, Refer2InnerImpl&);
} // MandatoryNamespace

namespace OtherNamespace {

struct SomeRecordImpl {
  MandatoryNamespace::NewRecordImpl r1;
  MandatoryNamespace::NewRecordImpl r2;
  MandatoryNamespace::Inner::InnerRecordImpl r3;
  MandatoryNamespace::Inner::InnerRecordImpl r4;
  inline                        SomeRecordImpl () { }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const SomeRecordImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, SomeRecordImpl&);
} // OtherNamespace

namespace Auxdata {

typedef int bar;

typedef double x;

typedef std::string s;
} // Auxdata

namespace InterfaceTests {

class I_UIWidgetArea_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class UIWidgetArea.
{
protected:
  explicit                               I_UIWidgetArea_Interface ();
  virtual /*Des*/                       ~I_UIWidgetArea_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
  virtual double                        dummy    () const = 0;
  virtual void                          dummy    (double) = 0;
  virtual std::string                   on_click () const = 0;
  virtual void                          on_click (const std::string&) = 0;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, double (I_UIWidgetArea_Interface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double                        simple_method            ();
  virtual double                        single_arg               (int n);
  virtual double                        single_arg2              (int n = 5);
  virtual double                        two_args                 (int n,
                                                                  double r);
  virtual double                        two_args2                (int n = 6,
                                                                  double r = 7.7);
  virtual double                        multi_args               (int n,
                                                                  double r,
                                                                  int i,
                                                                  const std::string &s = "String ding",
                                                                  double y = 5);
  virtual double                        self_method              (I_UIWidgetArea_Interface &ba1,
                                                                  I_UIWidgetArea_Interface &ba2);
  virtual void                          void_method              ();
  virtual std::string                   on_click2out             ();
  virtual void                          on_click2in              (const std::string &command);
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_UIWidgetArea_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_UIWidgetArea_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_UIWidgetArea_Interface*&);

class I_Parent_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class Parent.
{
protected:
  explicit                               I_Parent_Interface ();
  virtual /*Des*/                       ~I_Parent_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_Parent_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_Parent_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_Parent_Interface*&);

class I_Child_Interface : public virtual I_Parent_Interface
  /// See also the corresponding IDL class Child.
{
protected:
  explicit                               I_Child_Interface ();
  virtual /*Des*/                       ~I_Child_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_Child_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_Child_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_Child_Interface*&);

class I_Descendant_Interface : public virtual I_Child_Interface
  /// See also the corresponding IDL class Descendant.
{
protected:
  explicit                               I_Descendant_Interface ();
  virtual /*Des*/                       ~I_Descendant_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_Descendant_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_Descendant_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_Descendant_Interface*&);

class I_GrandChild_Interface : public virtual I_Descendant_Interface
  /// See also the corresponding IDL class GrandChild.
{
protected:
  explicit                               I_GrandChild_Interface ();
  virtual /*Des*/                       ~I_GrandChild_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_GrandChild_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_GrandChild_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_GrandChild_Interface*&);

enum QuickEnum {
  ZERO = 0,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  QuickEnum &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, QuickEnum &e) { e = QuickEnum (frr.pop_evalue()); return frr; }

struct QuickRecordImpl {
  int                           int1;
  int                           int2;
  inline                        QuickRecordImpl () { int1 = 0; int2 = 0; }
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const QuickRecordImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, QuickRecordImpl&);

struct QuickSequenceImpl : public std::vector<double> {
  typedef std::vector<double> Sequence;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, const QuickSequenceImpl&);
Plic::FieldReader& operator>> (Plic::FieldReader&, QuickSequenceImpl&);

class I_QuickIface_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class QuickIface.
{
protected:
  explicit                               I_QuickIface_Interface ();
  virtual /*Des*/                       ~I_QuickIface_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
  virtual void                          simple_function        (int i = 9);
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_QuickIface_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_QuickIface_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_QuickIface_Interface*&);

class I_MethodTestInterface_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class MethodTestInterface.
{
protected:
  explicit                               I_MethodTestInterface_Interface ();
  virtual /*Des*/                       ~I_MethodTestInterface_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
  virtual void                          method_with_void                ();
  virtual bool                          method_with_bools               (bool input,
                                                                         bool optval = 0);
  virtual int                           method_with_ints                (int input,
                                                                         int optval = -2);
  virtual double                        method_with_floats              (double input,
                                                                         double optval = 309.9);
  virtual std::string                   method_with_string              (const std::string &input,
                                                                         const std::string &optval = "default");
  virtual QuickEnum                     method_with_enum                (QuickEnum input,
                                                                         QuickEnum optval = QuickEnum (0));
  virtual QuickRecordImpl               method_with_record              (const QuickRecordImpl &input,
                                                                         const QuickRecordImpl &optval = QuickRecordImpl());
  virtual QuickSequenceImpl             method_with_sequence            (const QuickSequenceImpl &input,
                                                                         const QuickSequenceImpl &optval = QuickSequenceImpl());
  virtual I_GrandChild_Interface*       method_with_interface           (I_GrandChild_Interface &input,
                                                                         I_GrandChild_Interface &optval = *(I_GrandChild_Interface*) NULL);
  virtual I_QuickIface_Interface*       method_with_quickiface          (I_QuickIface_Interface &input,
                                                                         I_QuickIface_Interface &iface0 = *(I_QuickIface_Interface*) NULL);
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_MethodTestInterface_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_MethodTestInterface_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_MethodTestInterface_Interface*&);

class I_SignalTestInterface_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class SignalTestInterface.
{
protected:
  explicit                               I_SignalTestInterface_Interface ();
  virtual /*Des*/                       ~I_SignalTestInterface_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, bool ()> Signal_bool_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, int ()> Signal_int_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, double ()> Signal_float_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, std::string ()> Signal_string_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickRecordImpl ()> Signal_record_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickSequenceImpl ()> Signal_sequence_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_GrandChild_Interface* ()> Signal_interface_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_SignalTestInterface_Interface* ()> Signal_self_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (int i)> Signal_int_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (double f)> Signal_float_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickRecordImpl &r)> Signal_record_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickSequenceImpl &s)> Signal_sequence_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_GrandChild_Interface &i)> Signal_interface_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_SignalTestInterface_Interface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int_result sig_int_result;
  Signal_float_result sig_float_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int_arg sig_int_arg;
  Signal_float_arg sig_float_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_self_args sig_self_args;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_SignalTestInterface_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_SignalTestInterface_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_SignalTestInterface_Interface*&);

class I_PropertyTester_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class PropertyTester.
{
protected:
  explicit                               I_PropertyTester_Interface ();
  virtual /*Des*/                       ~I_PropertyTester_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
  virtual bool                          bool_prop      () const = 0;
  virtual void                          bool_prop      (bool) = 0;
  virtual int                           int_prop       () const = 0;
  virtual void                          int_prop       (int) = 0;
  virtual double                        float_prop     () const = 0;
  virtual void                          float_prop     (double) = 0;
  virtual std::string                   string_prop    () const = 0;
  virtual void                          string_prop    (const std::string&) = 0;
  virtual QuickEnum                     enum_prop      () const = 0;
  virtual void                          enum_prop      (QuickEnum) = 0;
  virtual QuickRecordImpl               record_prop    () const = 0;
  virtual void                          record_prop    (const QuickRecordImpl&) = 0;
  virtual QuickSequenceImpl             sequence_prop  () const = 0;
  virtual void                          sequence_prop  (const QuickSequenceImpl&) = 0;
  virtual I_GrandChild_Interface*       interface_prop () const = 0;
  virtual void                          interface_prop (I_GrandChild_Interface*) = 0;
  virtual I_PropertyTester_Interface*   self_prop      () const = 0;
  virtual void                          self_prop      (I_PropertyTester_Interface*) = 0;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_PropertyTester_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_PropertyTester_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_PropertyTester_Interface*&);
} // InterfaceTests

namespace RapicornPlicTest {

enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};
inline Plic::FieldBuffer& operator<< (Plic::FieldBuffer &fb,  ClickType &e) { fb << Plic::EnumValue (e); return fb; }
inline Plic::FieldReader& operator>> (Plic::FieldReader &frr, ClickType &e) { e = ClickType (frr.pop_evalue()); return frr; }

class I_ButtonArea_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class ButtonArea.
{
protected:
  explicit                               I_ButtonArea_Interface ();
  virtual /*Des*/                       ~I_ButtonArea_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
  virtual std::string                   on_click   () const = 0;
  virtual void                          on_click   (const std::string&) = 0;
  virtual std::string                   on_click2  () const = 0;
  virtual void                          on_click2  (const std::string&) = 0;
  virtual std::string                   on_click3  () const = 0;
  virtual void                          on_click3  (const std::string&) = 0;
  virtual ClickType                     click_type () const = 0;
  virtual void                          click_type (ClickType) = 0;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, bool (), Rapicorn::Signals::CollectorUntil0<bool> > Signal_check_activate;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_ButtonArea_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_ButtonArea_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_ButtonArea_Interface*&);

class I_PureMethods_Interface;

class I_PureMethods_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class PureMethods.
{
protected:
  explicit                               I_PureMethods_Interface ();
  virtual /*Des*/                       ~I_PureMethods_Interface () = 0;
public:
  virtual void                          _list_types (Plic::TypeHashList&) const;
  virtual int                           pure_method             (double f) = 0;
};
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_PureMethods_Interface&);
Plic::FieldBuffer& operator<< (Plic::FieldBuffer&, I_PureMethods_Interface*);
Plic::FieldReader& operator>> (Plic::FieldReader&, I_PureMethods_Interface*&);
} // RapicornPlicTest

// --- Interface Skeletons ---

void
MandatoryNamespace::I_FirstInterface_Interface::void_func ()
{
}

double
InterfaceTests::I_UIWidgetArea_Interface::simple_method ()
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::single_arg (int n)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::single_arg2 (int n)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::two_args (int n,
                                                    double r)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::two_args2 (int n,
                                                     double r)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::multi_args (int n,
                                                      double r,
                                                      int i,
                                                      const std::string &s,
                                                      double y)
{
  return 0;
}

double
InterfaceTests::I_UIWidgetArea_Interface::self_method (InterfaceTests::I_UIWidgetArea_Interface &ba1,
                                                       InterfaceTests::I_UIWidgetArea_Interface &ba2)
{
  return 0;
}

void
InterfaceTests::I_UIWidgetArea_Interface::void_method ()
{
}

std::string
InterfaceTests::I_UIWidgetArea_Interface::on_click2out ()
{
  return 0;
}

void
InterfaceTests::I_UIWidgetArea_Interface::on_click2in (const std::string &command)
{
}

void
InterfaceTests::I_QuickIface_Interface::simple_function (int i)
{
}

void
InterfaceTests::I_MethodTestInterface_Interface::method_with_void ()
{
}

bool
InterfaceTests::I_MethodTestInterface_Interface::method_with_bools (bool input,
                                                                    bool optval)
{
  return 0;
}

int
InterfaceTests::I_MethodTestInterface_Interface::method_with_ints (int input,
                                                                   int optval)
{
  return 0;
}

double
InterfaceTests::I_MethodTestInterface_Interface::method_with_floats (double input,
                                                                     double optval)
{
  return 0;
}

std::string
InterfaceTests::I_MethodTestInterface_Interface::method_with_string (const std::string &input,
                                                                     const std::string &optval)
{
  return 0;
}

InterfaceTests::QuickEnum
InterfaceTests::I_MethodTestInterface_Interface::method_with_enum (InterfaceTests::QuickEnum input,
                                                                   InterfaceTests::QuickEnum optval)
{
  return InterfaceTests::QuickEnum (0);
}

InterfaceTests::QuickRecordImpl
InterfaceTests::I_MethodTestInterface_Interface::method_with_record (const InterfaceTests::QuickRecordImpl &input,
                                                                     const InterfaceTests::QuickRecordImpl &optval)
{
  return InterfaceTests::QuickRecordImpl();
}

InterfaceTests::QuickSequenceImpl
InterfaceTests::I_MethodTestInterface_Interface::method_with_sequence (const InterfaceTests::QuickSequenceImpl &input,
                                                                       const InterfaceTests::QuickSequenceImpl &optval)
{
  return InterfaceTests::QuickSequenceImpl();
}

InterfaceTests::I_GrandChild_Interface*
InterfaceTests::I_MethodTestInterface_Interface::method_with_interface (InterfaceTests::I_GrandChild_Interface &input,
                                                                        InterfaceTests::I_GrandChild_Interface &optval)
{
  return (InterfaceTests::I_GrandChild_Interface*) NULL;
}

InterfaceTests::I_QuickIface_Interface*
InterfaceTests::I_MethodTestInterface_Interface::method_with_quickiface (InterfaceTests::I_QuickIface_Interface &input,
                                                                         InterfaceTests::I_QuickIface_Interface &iface0)
{
  return (InterfaceTests::I_QuickIface_Interface*) NULL;
}


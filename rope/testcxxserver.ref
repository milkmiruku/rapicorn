/* --- Generated by PLIC-CxxCaller --- */

// --- ServerHH Boilerplate ---
#include <rcore/plicutils.hh>
#include <rcore/rapicornsignal.hh>
using Rapicorn::Signals::slot;

// --- ClientCC/ServerCC Boilerplate ---
#include <string>
#include <vector>
#include <stdexcept>
#ifndef __PLIC_GENERIC_CC_BOILERPLATE__
#define __PLIC_GENERIC_CC_BOILERPLATE__

#define THROW_ERROR()   throw std::runtime_error ("PLIC: Marshalling failed")
#define PLIC_CHECK(cond,errmsg) do { if (cond) break; throw std::runtime_error (std::string ("PLIC-ERROR: ") + errmsg); } while (0)

namespace { // Anonymous
using Plic::uint64;
typedef Plic::Coupler Coupler;
typedef Plic::FieldBuffer FieldBuffer;
typedef Plic::FieldBuffer8 FieldBuffer8;
typedef Plic::FieldBufferReader FieldBufferReader;

#ifndef PLIC_COUPLER
#define PLIC_COUPLER()  _plic_coupler_static
static struct _DummyCoupler : public Coupler {
  virtual FieldBuffer* call_remote (FieldBuffer *fbcall)
  {
    bool hasresult = Plic::msgid_has_result (fbcall->first_id());
    if (push_call (fbcall)) // deletes fbcall
      ; // threaded dispatcher needs CPU
    // wakeup dispatcher
    while (check_dispatch())
      dispatch();
    return !hasresult ? NULL : pop_result();
  }
} _plic_coupler_static;
#endif

} // Anonymous
#endif // __PLIC_GENERIC_CC_BOILERPLATE__


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {
enum Empty {
};
enum Enum1 {
  E1_A = 1,
};
enum Enum1c {
  E1C_A = 1,
};
enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};

class I_FirstInterface_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_FirstInterface_Interface ();
  virtual /*Des*/         ~I_FirstInterface_Interface () = 0;
public:
  virtual void            void_func ();
};

class FirstInterface_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline FirstInterface_SmartHandle () {}
  inline FirstInterface_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline FirstInterface_SmartHandle (I_FirstInterface_Interface *iface) { _iface (iface); }
  inline FirstInterface_SmartHandle (I_FirstInterface_Interface &iface) { _iface (&iface); }
  // void            void_func ();
  inline I_FirstInterface_Interface& operator*  () const { return *dynamic_cast<I_FirstInterface_Interface*> (_iface()); }
  inline I_FirstInterface_Interface* operator-> () const { return dynamic_cast<I_FirstInterface_Interface*> (_iface()); }
  inline operator  I_FirstInterface_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

struct XFooRecord {
  bool            single_bool;
  int             single_num;
  double          single_float;
  std::string     single_string;
  int             sibling1;
  int             sibling2;
  int             multi1;
  int             multi2;
  int             multi3;
  int             multi4;
  ExtensiveEnum   enum_field;
  FirstInterface_SmartHandle iface1;
  FirstInterface_SmartHandle iface2;
  FirstInterface_SmartHandle iface3;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline XFooRecord () { single_bool = 0; single_num = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
struct XFooSequence {
  typedef std::vector<bool> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        single_bool;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct IntSequence {
  typedef std::vector<int> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        numx;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct FloatSequence {
  typedef std::vector<double> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        fractalvalue;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct StringSequence {
  typedef std::vector<std::string> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        blurb;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct ExtensiveEnumSequence {
  typedef std::vector<ExtensiveEnum> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        enum_elements;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct RecordSequence {
  typedef std::vector<XFooRecord> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        repeatedfield;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct SequenceSequence {
  typedef std::vector<IntSequence> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        moreints;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct InterfaceSequence {
  typedef std::vector<FirstInterface_SmartHandle> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        iface1;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct NestedTypesRec {
  XFooRecord      rec;
  XFooSequence    seq;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline NestedTypesRec () { }
};
struct NestedTypesSeq {
  typedef std::vector<NestedTypesRec> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        ntr;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
typedef int AliasInt;
typedef double AliasFloat;
typedef bool AliasBool;
typedef std::string AliasString;
typedef XFooRecord AliasRecord;
typedef XFooSequence AliasSequence;
typedef ExtensiveEnum AliasEnum;
struct NewRecord {
  int             i;
  Enum1           enum1;
  XFooSequence    xfs;
  NestedTypesRec  ntr;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline NewRecord () { i = 0; enum1 = Enum1 (0); }
};

namespace Inner {
struct InnerRecord {
  int             x;
  int             y;
  NewRecord       rec;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline InnerRecord () { x = 0; y = 0; }
};
} // Inner
struct Refer2Inner {
  Inner::InnerRecord r;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline Refer2Inner () { }
};
} // MandatoryNamespace

namespace OtherNamespace {
struct SomeRecord {
  MandatoryNamespace::NewRecord r1;
  MandatoryNamespace::NewRecord r2;
  MandatoryNamespace::Inner::InnerRecord r3;
  MandatoryNamespace::Inner::InnerRecord r4;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline SomeRecord () { }
};
} // OtherNamespace

namespace Auxdata {
typedef int bar;
typedef double x;
typedef std::string s;

} // Auxdata

namespace InterfaceTests {
class I_UIWidgetArea_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_UIWidgetArea_Interface ();
  virtual /*Des*/         ~I_UIWidgetArea_Interface () = 0;
public:
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, double (I_UIWidgetArea_Interface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double          simple_method ();
  virtual double          single_arg    (int n);
  virtual double          single_arg2   (int n = 5);
  virtual double          two_args      (int n,
                                         double r);
  virtual double          two_args2     (int n = 6,
                                         double r = 7.7);
  virtual double          multi_args    (int n,
                                         double r,
                                         int i,
                                         const std::string &s = "String ding",
                                         double y = 5);
  virtual double          self_method   (I_UIWidgetArea_Interface &ba1,
                                         I_UIWidgetArea_Interface &ba2);
  virtual void            void_method   ();
  virtual std::string     on_click2out  ();
  virtual void            on_click2in   (const std::string &command);
};

class UIWidgetArea_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline UIWidgetArea_SmartHandle () {}
  inline UIWidgetArea_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline UIWidgetArea_SmartHandle (I_UIWidgetArea_Interface *iface) { _iface (iface); }
  inline UIWidgetArea_SmartHandle (I_UIWidgetArea_Interface &iface) { _iface (&iface); }
  // double          simple_method ();
  // double          single_arg    (int);
  // double          single_arg2   (int);
  // double          two_args      (int, double);
  // double          two_args2     (int, double);
  // double          multi_args    (int, double, int, const std::string&, double);
  // double          self_method   (UIWidgetArea_SmartHandle&, UIWidgetArea_SmartHandle&);
  // void            void_method   ();
  // std::string     on_click2out  ();
  // void            on_click2in   (const std::string&);
  inline I_UIWidgetArea_Interface& operator*  () const { return *dynamic_cast<I_UIWidgetArea_Interface*> (_iface()); }
  inline I_UIWidgetArea_Interface* operator-> () const { return dynamic_cast<I_UIWidgetArea_Interface*> (_iface()); }
  inline operator  I_UIWidgetArea_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_Parent_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_Parent_Interface ();
  virtual /*Des*/         ~I_Parent_Interface () = 0;
public:
};

class Parent_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline Parent_SmartHandle () {}
  inline Parent_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline Parent_SmartHandle (I_Parent_Interface *iface) { _iface (iface); }
  inline Parent_SmartHandle (I_Parent_Interface &iface) { _iface (&iface); }
  inline I_Parent_Interface& operator*  () const { return *dynamic_cast<I_Parent_Interface*> (_iface()); }
  inline I_Parent_Interface* operator-> () const { return dynamic_cast<I_Parent_Interface*> (_iface()); }
  inline operator  I_Parent_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_Child_Interface : public virtual I_Parent_Interface {
protected:
  explicit                 I_Child_Interface ();
  virtual /*Des*/         ~I_Child_Interface () = 0;
public:
};

class Child_SmartHandle : public Parent_SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline Child_SmartHandle () {}
  inline Child_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline Child_SmartHandle (I_Child_Interface *iface) { _iface (iface); }
  inline Child_SmartHandle (I_Child_Interface &iface) { _iface (&iface); }
  inline I_Child_Interface& operator*  () const { return *dynamic_cast<I_Child_Interface*> (_iface()); }
  inline I_Child_Interface* operator-> () const { return dynamic_cast<I_Child_Interface*> (_iface()); }
  inline operator  I_Child_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_Descendant_Interface : public virtual I_Child_Interface {
protected:
  explicit                 I_Descendant_Interface ();
  virtual /*Des*/         ~I_Descendant_Interface () = 0;
public:
};

class Descendant_SmartHandle : public Child_SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline Descendant_SmartHandle () {}
  inline Descendant_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline Descendant_SmartHandle (I_Descendant_Interface *iface) { _iface (iface); }
  inline Descendant_SmartHandle (I_Descendant_Interface &iface) { _iface (&iface); }
  inline I_Descendant_Interface& operator*  () const { return *dynamic_cast<I_Descendant_Interface*> (_iface()); }
  inline I_Descendant_Interface* operator-> () const { return dynamic_cast<I_Descendant_Interface*> (_iface()); }
  inline operator  I_Descendant_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_GrandChild_Interface : public virtual I_Descendant_Interface {
protected:
  explicit                 I_GrandChild_Interface ();
  virtual /*Des*/         ~I_GrandChild_Interface () = 0;
public:
};

class GrandChild_SmartHandle : public Descendant_SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline GrandChild_SmartHandle () {}
  inline GrandChild_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline GrandChild_SmartHandle (I_GrandChild_Interface *iface) { _iface (iface); }
  inline GrandChild_SmartHandle (I_GrandChild_Interface &iface) { _iface (&iface); }
  inline I_GrandChild_Interface& operator*  () const { return *dynamic_cast<I_GrandChild_Interface*> (_iface()); }
  inline I_GrandChild_Interface* operator-> () const { return dynamic_cast<I_GrandChild_Interface*> (_iface()); }
  inline operator  I_GrandChild_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

enum QuickEnum {
  ZERO = 0,
};
struct QuickRecord {
  int             int1;
  int             int2;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline QuickRecord () { int1 = 0; int2 = 0; }
};
struct QuickSequence {
  typedef std::vector<double> Sequence;
  typedef Sequence::size_type              size_type;
  typedef Sequence::value_type             value_type;
  typedef Sequence::allocator_type         allocator_type;
  typedef Sequence::iterator               iterator;
  typedef Sequence::const_iterator         const_iterator;
  typedef Sequence::reverse_iterator       reverse_iterator;
  typedef Sequence::const_reverse_iterator const_reverse_iterator;
  Sequence        somefloat;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};

class I_QuickIface_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_QuickIface_Interface ();
  virtual /*Des*/         ~I_QuickIface_Interface () = 0;
public:
  virtual void            simple_function (int i = 9);
};

class QuickIface_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline QuickIface_SmartHandle () {}
  inline QuickIface_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline QuickIface_SmartHandle (I_QuickIface_Interface *iface) { _iface (iface); }
  inline QuickIface_SmartHandle (I_QuickIface_Interface &iface) { _iface (&iface); }
  // void            simple_function (int);
  inline I_QuickIface_Interface& operator*  () const { return *dynamic_cast<I_QuickIface_Interface*> (_iface()); }
  inline I_QuickIface_Interface* operator-> () const { return dynamic_cast<I_QuickIface_Interface*> (_iface()); }
  inline operator  I_QuickIface_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_MethodTestInterface_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_MethodTestInterface_Interface ();
  virtual /*Des*/         ~I_MethodTestInterface_Interface () = 0;
public:
  virtual void            method_with_void       ();
  virtual bool            method_with_bools      (bool input,
                                                  bool optval = 0);
  virtual int             method_with_ints       (int input,
                                                  int optval = -2);
  virtual double          method_with_floats     (double input,
                                                  double optval = 309.9);
  virtual std::string     method_with_string     (const std::string &input,
                                                  const std::string &optval = "default");
  virtual QuickEnum       method_with_enum       (QuickEnum input,
                                                  QuickEnum optval = QuickEnum (0));
  virtual QuickRecord     method_with_record     (const QuickRecord &input,
                                                  const QuickRecord &optval = QuickRecord());
  virtual QuickSequence   method_with_sequence   (const QuickSequence &input,
                                                  const QuickSequence &optval = QuickSequence());
  virtual I_GrandChild_Interface* method_with_interface  (I_GrandChild_Interface &input,
                                                          I_GrandChild_Interface &optval = *(I_GrandChild_Interface*) NULL);
  virtual I_QuickIface_Interface* method_with_quickiface (I_QuickIface_Interface &input,
                                                          I_QuickIface_Interface &iface0 = *(I_QuickIface_Interface*) NULL);
};

class MethodTestInterface_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline MethodTestInterface_SmartHandle () {}
  inline MethodTestInterface_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline MethodTestInterface_SmartHandle (I_MethodTestInterface_Interface *iface) { _iface (iface); }
  inline MethodTestInterface_SmartHandle (I_MethodTestInterface_Interface &iface) { _iface (&iface); }
  // void            method_with_void       ();
  // bool            method_with_bools      (bool, bool);
  // int             method_with_ints       (int, int);
  // double          method_with_floats     (double, double);
  // std::string     method_with_string     (const std::string&, const std::string&);
  // QuickEnum       method_with_enum       (QuickEnum, QuickEnum);
  // QuickRecord     method_with_record     (const QuickRecord&, const QuickRecord&);
  // QuickSequence   method_with_sequence   (const QuickSequence&, const QuickSequence&);
  // GrandChild_SmartHandle method_with_interface  (GrandChild_SmartHandle&, GrandChild_SmartHandle&);
  // QuickIface_SmartHandle method_with_quickiface (QuickIface_SmartHandle&, QuickIface_SmartHandle&);
  inline I_MethodTestInterface_Interface& operator*  () const { return *dynamic_cast<I_MethodTestInterface_Interface*> (_iface()); }
  inline I_MethodTestInterface_Interface* operator-> () const { return dynamic_cast<I_MethodTestInterface_Interface*> (_iface()); }
  inline operator  I_MethodTestInterface_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_SignalTestInterface_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_SignalTestInterface_Interface ();
  virtual /*Des*/         ~I_SignalTestInterface_Interface () = 0;
public:
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, bool ()> Signal_bool_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, int ()> Signal_int_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, double ()> Signal_float_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, std::string ()> Signal_string_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickRecord ()> Signal_record_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickSequence ()> Signal_sequence_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_GrandChild_Interface* ()> Signal_interface_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_SignalTestInterface_Interface* ()> Signal_self_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (int i)> Signal_int_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (double f)> Signal_float_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickRecord &r)> Signal_record_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickSequence &s)> Signal_sequence_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_GrandChild_Interface &i)> Signal_interface_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_SignalTestInterface_Interface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int_result sig_int_result;
  Signal_float_result sig_float_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int_arg sig_int_arg;
  Signal_float_arg sig_float_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_self_args sig_self_args;
};

class SignalTestInterface_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline SignalTestInterface_SmartHandle () {}
  inline SignalTestInterface_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline SignalTestInterface_SmartHandle (I_SignalTestInterface_Interface *iface) { _iface (iface); }
  inline SignalTestInterface_SmartHandle (I_SignalTestInterface_Interface &iface) { _iface (&iface); }
  inline I_SignalTestInterface_Interface& operator*  () const { return *dynamic_cast<I_SignalTestInterface_Interface*> (_iface()); }
  inline I_SignalTestInterface_Interface* operator-> () const { return dynamic_cast<I_SignalTestInterface_Interface*> (_iface()); }
  inline operator  I_SignalTestInterface_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

} // InterfaceTests

namespace RapicornPlicTest {
enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};

class I_ButtonArea_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_ButtonArea_Interface ();
  virtual /*Des*/         ~I_ButtonArea_Interface () = 0;
public:
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, bool (), Rapicorn::Signals::CollectorUntil0<bool> > Signal_check_activate;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};

class ButtonArea_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline ButtonArea_SmartHandle () {}
  inline ButtonArea_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline ButtonArea_SmartHandle (I_ButtonArea_Interface *iface) { _iface (iface); }
  inline ButtonArea_SmartHandle (I_ButtonArea_Interface &iface) { _iface (&iface); }
  inline I_ButtonArea_Interface& operator*  () const { return *dynamic_cast<I_ButtonArea_Interface*> (_iface()); }
  inline I_ButtonArea_Interface* operator-> () const { return dynamic_cast<I_ButtonArea_Interface*> (_iface()); }
  inline operator  I_ButtonArea_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};


class I_PureMethods_Interface : public virtual Plic::SimpleServer {
protected:
  explicit                 I_PureMethods_Interface ();
  virtual /*Des*/         ~I_PureMethods_Interface () = 0;
public:
  virtual int             pure_method (double f) = 0;
};

class PureMethods_SmartHandle : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline PureMethods_SmartHandle () {}
  inline PureMethods_SmartHandle (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline PureMethods_SmartHandle (I_PureMethods_Interface *iface) { _iface (iface); }
  inline PureMethods_SmartHandle (I_PureMethods_Interface &iface) { _iface (&iface); }
  // int             pure_method (double);
  inline I_PureMethods_Interface& operator*  () const { return *dynamic_cast<I_PureMethods_Interface*> (_iface()); }
  inline I_PureMethods_Interface* operator-> () const { return dynamic_cast<I_PureMethods_Interface*> (_iface()); }
  inline operator  I_PureMethods_Interface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

} // RapicornPlicTest

// --- Implementations ---

namespace MandatoryNamespace {
I_FirstInterface_Interface::I_FirstInterface_Interface ()
{}
I_FirstInterface_Interface::~I_FirstInterface_Interface () {}

bool
XFooRecord::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (14);
  fb.add_int64 (this->single_bool);
  fb.add_int64 (this->single_num);
  fb.add_double (this->single_float);
  fb.add_string (this->single_string);
  fb.add_int64 (this->sibling1);
  fb.add_int64 (this->sibling2);
  fb.add_int64 (this->multi1);
  fb.add_int64 (this->multi2);
  fb.add_int64 (this->multi3);
  fb.add_int64 (this->multi4);
  fb.add_evalue (this->enum_field);
  fb.add_object (this->iface1._rpc_id());
  fb.add_object (this->iface2._rpc_id());
  fb.add_object (this->iface3._rpc_id());
  return true;
}
bool
XFooRecord::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 14) return false;
  this->single_bool = fbr.pop_int64();
  this->single_num = fbr.pop_int64();
  this->single_float = fbr.pop_double();
  this->single_string = fbr.pop_string();
  this->sibling1 = fbr.pop_int64();
  this->sibling2 = fbr.pop_int64();
  this->multi1 = fbr.pop_int64();
  this->multi2 = fbr.pop_int64();
  this->multi3 = fbr.pop_int64();
  this->multi4 = fbr.pop_int64();
  this->enum_field = ExtensiveEnum (fbr.pop_evalue());
  this->iface1 = FirstInterface_SmartHandle (cpl, fbr);
  this->iface2 = FirstInterface_SmartHandle (cpl, fbr);
  this->iface3 = FirstInterface_SmartHandle (cpl, fbr);
  return true;
}

bool
XFooSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = single_bool.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_int64 (this->single_bool[k]);
  }
  return true;
}
bool
XFooSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->single_bool.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->single_bool.push_back (fbr.pop_int64());
  }
  return true;
}

bool
IntSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = numx.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_int64 (this->numx[k]);
  }
  return true;
}
bool
IntSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->numx.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->numx.push_back (fbr.pop_int64());
  }
  return true;
}

bool
FloatSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = fractalvalue.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_double (this->fractalvalue[k]);
  }
  return true;
}
bool
FloatSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->fractalvalue.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->fractalvalue.push_back (fbr.pop_double());
  }
  return true;
}

bool
StringSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = blurb.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_string (this->blurb[k]);
  }
  return true;
}
bool
StringSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->blurb.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->blurb.push_back (fbr.pop_string());
  }
  return true;
}

bool
ExtensiveEnumSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = enum_elements.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_evalue (this->enum_elements[k]);
  }
  return true;
}
bool
ExtensiveEnumSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->enum_elements.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->enum_elements.push_back (ExtensiveEnum (fbr.pop_evalue()));
  }
  return true;
}

bool
RecordSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = repeatedfield.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->repeatedfield[k].proto_add (cpl, fb)) return false;
  }
  return true;
}
bool
RecordSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->repeatedfield.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->repeatedfield[k].proto_pop (cpl, fbr)) return false;
  }
  return true;
}

bool
SequenceSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = moreints.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->moreints[k].proto_add (cpl, fb)) return false;
  }
  return true;
}
bool
SequenceSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->moreints.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->moreints[k].proto_pop (cpl, fbr)) return false;
  }
  return true;
}

bool
InterfaceSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = iface1.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_object (this->iface1[k]._rpc_id());
  }
  return true;
}
bool
InterfaceSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->iface1.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->iface1.push_back (FirstInterface_SmartHandle (cpl, fbr));
  }
  return true;
}

bool
NestedTypesRec::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  if (!this->rec.proto_add (cpl, fb)) return false;
  if (!this->seq.proto_add (cpl, fb)) return false;
  return true;
}
bool
NestedTypesRec::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 2) return false;
  if (!this->rec.proto_pop (cpl, fbr)) return false;
  if (!this->seq.proto_pop (cpl, fbr)) return false;
  return true;
}

bool
NestedTypesSeq::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = ntr.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->ntr[k].proto_add (cpl, fb)) return false;
  }
  return true;
}
bool
NestedTypesSeq::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->ntr.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->ntr[k].proto_pop (cpl, fbr)) return false;
  }
  return true;
}

bool
NewRecord::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  fb.add_int64 (this->i);
  fb.add_evalue (this->enum1);
  if (!this->xfs.proto_add (cpl, fb)) return false;
  if (!this->ntr.proto_add (cpl, fb)) return false;
  return true;
}
bool
NewRecord::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 4) return false;
  this->i = fbr.pop_int64();
  this->enum1 = Enum1 (fbr.pop_evalue());
  if (!this->xfs.proto_pop (cpl, fbr)) return false;
  if (!this->ntr.proto_pop (cpl, fbr)) return false;
  return true;
}


namespace Inner {
bool
InnerRecord::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (3);
  fb.add_int64 (this->x);
  fb.add_int64 (this->y);
  if (!this->rec.proto_add (cpl, fb)) return false;
  return true;
}
bool
InnerRecord::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 3) return false;
  this->x = fbr.pop_int64();
  this->y = fbr.pop_int64();
  if (!this->rec.proto_pop (cpl, fbr)) return false;
  return true;
}

} // Inner
bool
Refer2Inner::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (1);
  if (!this->r.proto_add (cpl, fb)) return false;
  return true;
}
bool
Refer2Inner::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 1) return false;
  if (!this->r.proto_pop (cpl, fbr)) return false;
  return true;
}

} // MandatoryNamespace

namespace OtherNamespace {
bool
SomeRecord::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  if (!this->r1.proto_add (cpl, fb)) return false;
  if (!this->r2.proto_add (cpl, fb)) return false;
  if (!this->r3.proto_add (cpl, fb)) return false;
  if (!this->r4.proto_add (cpl, fb)) return false;
  return true;
}
bool
SomeRecord::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 4) return false;
  if (!this->r1.proto_pop (cpl, fbr)) return false;
  if (!this->r2.proto_pop (cpl, fbr)) return false;
  if (!this->r3.proto_pop (cpl, fbr)) return false;
  if (!this->r4.proto_pop (cpl, fbr)) return false;
  return true;
}

} // OtherNamespace

namespace InterfaceTests {
I_UIWidgetArea_Interface::I_UIWidgetArea_Interface () :
  sig_void_signal (*this), sig_sample_signal (*this)
{}
I_UIWidgetArea_Interface::~I_UIWidgetArea_Interface () {}

I_Parent_Interface::I_Parent_Interface ()
{}
I_Parent_Interface::~I_Parent_Interface () {}

I_Child_Interface::I_Child_Interface ()
{}
I_Child_Interface::~I_Child_Interface () {}

I_Descendant_Interface::I_Descendant_Interface ()
{}
I_Descendant_Interface::~I_Descendant_Interface () {}

I_GrandChild_Interface::I_GrandChild_Interface ()
{}
I_GrandChild_Interface::~I_GrandChild_Interface () {}

bool
QuickRecord::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  fb.add_int64 (this->int1);
  fb.add_int64 (this->int2);
  return true;
}
bool
QuickRecord::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 2) return false;
  this->int1 = fbr.pop_int64();
  this->int2 = fbr.pop_int64();
  return true;
}

bool
QuickSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = somefloat.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_double (this->somefloat[k]);
  }
  return true;
}
bool
QuickSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->somefloat.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->somefloat.push_back (fbr.pop_double());
  }
  return true;
}

I_QuickIface_Interface::I_QuickIface_Interface ()
{}
I_QuickIface_Interface::~I_QuickIface_Interface () {}

I_MethodTestInterface_Interface::I_MethodTestInterface_Interface ()
{}
I_MethodTestInterface_Interface::~I_MethodTestInterface_Interface () {}

I_SignalTestInterface_Interface::I_SignalTestInterface_Interface () :
  sig_void_result (*this), sig_bool_result (*this), sig_int_result (*this), sig_float_result (*this), sig_string_result (*this), sig_enum_result (*this), sig_record_result (*this), sig_sequence_result (*this), sig_interface_result (*this), sig_self_result (*this), sig_void_arg (*this), sig_bool_arg (*this), sig_int_arg (*this), sig_float_arg (*this), sig_string_arg (*this), sig_enum_arg (*this), sig_record_arg (*this), sig_sequence_arg (*this), sig_interface_arg (*this), sig_self_args (*this)
{}
I_SignalTestInterface_Interface::~I_SignalTestInterface_Interface () {}

} // InterfaceTests

namespace RapicornPlicTest {
I_ButtonArea_Interface::I_ButtonArea_Interface () :
  sig_check_activate (*this), sig_activate (*this)
{}
I_ButtonArea_Interface::~I_ButtonArea_Interface () {}

I_PureMethods_Interface::I_PureMethods_Interface ()
{}
I_PureMethods_Interface::~I_PureMethods_Interface () {}


// --- Method Dispatchers & Registry ---
} // RapicornPlicTest

namespace MandatoryNamespace {
static FieldBuffer*
_dispatch__FirstInterface_void_func (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 0) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_FirstInterface_Interface *self;
  self = FirstInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  self->void_func ();
  return NULL;
}


namespace Inner {
} // Inner
} // MandatoryNamespace

namespace OtherNamespace {
} // OtherNamespace

namespace InterfaceTests {
static FieldBuffer*
_dispatch__UIWidgetArea_simple_method (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 0) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  double rval = self->simple_method ();
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_single_arg (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 1) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double rval = self->single_arg (arg_n);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_single_arg2 (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 1) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double rval = self->single_arg2 (arg_n);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_two_args (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double arg_r = fbr.pop_double();
  double rval = self->two_args (arg_n, arg_r);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_two_args2 (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double arg_r = fbr.pop_double();
  double rval = self->two_args2 (arg_n, arg_r);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_multi_args (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 5) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double arg_r = fbr.pop_double();
  int arg_i = fbr.pop_int64();
  std::string arg_s = fbr.pop_string();
  double arg_y = fbr.pop_double();
  double rval = self->multi_args (arg_n, arg_r, arg_i, arg_s, arg_y);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_self_method (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  I_UIWidgetArea_Interface *arg_ba1 = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  I_UIWidgetArea_Interface *arg_ba2 = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  double rval = self->self_method (*arg_ba1, *arg_ba2);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_void_method (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 0) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  self->void_method ();
  return NULL;
}
static FieldBuffer*
_dispatch__UIWidgetArea_on_click2out (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 0) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  std::string rval = self->on_click2out ();
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_string (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_on_click2in (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 1) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  std::string arg_command = fbr.pop_string();
  self->on_click2in (arg_command);
  return NULL;
}
struct _CLOSURE_UIWidgetArea_void_signal {
  typedef Plic::shared_ptr<_CLOSURE_UIWidgetArea_void_signal> SharedPtr;
  _CLOSURE_UIWidgetArea_void_signal (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_UIWidgetArea_void_signal()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__UIWidgetArea_void_signal (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_void_signal.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_UIWidgetArea_void_signal::SharedPtr sp (new _CLOSURE_UIWidgetArea_void_signal (cpl, handler_id));
    cid = self->sig_void_signal.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_UIWidgetArea_sample_signal {
  typedef Plic::shared_ptr<_CLOSURE_UIWidgetArea_sample_signal> SharedPtr;
  _CLOSURE_UIWidgetArea_sample_signal (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_UIWidgetArea_sample_signal()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static double
  handler (I_UIWidgetArea_Interface &arg_ba1,
           int arg_someint,
           SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 2);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    fb.add_object (arg_ba1._rpc_id());
    fb.add_int64 (arg_someint);
    sp->m_coupler.push_event (&fb); // deletes fb
    return 0;
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__UIWidgetArea_sample_signal (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_UIWidgetArea_Interface *self;
  self = UIWidgetArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_sample_signal.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_UIWidgetArea_sample_signal::SharedPtr sp (new _CLOSURE_UIWidgetArea_sample_signal (cpl, handler_id));
    cid = self->sig_sample_signal.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}





static FieldBuffer*
_dispatch__QuickIface_simple_function (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 1) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_QuickIface_Interface *self;
  self = QuickIface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_i = fbr.pop_int64();
  self->simple_function (arg_i);
  return NULL;
}

static FieldBuffer*
_dispatch__MethodTestInterface_method_with_void (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 0) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_MethodTestInterface_Interface *self;
  self = MethodTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  self->method_with_void ();
  return NULL;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_bools (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_MethodTestInterface_Interface *self;
  self = MethodTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  bool arg_input = fbr.pop_int64();
  bool arg_optval = fbr.pop_int64();
  bool rval = self->method_with_bools (arg_input, arg_optval);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_ints (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_MethodTestInterface_Interface *self;
  self = MethodTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_input = fbr.pop_int64();
  int arg_optval = fbr.pop_int64();
  int rval = self->method_with_ints (arg_input, arg_optval);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_floats (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_MethodTestInterface_Interface *self;
  self = MethodTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  double arg_input = fbr.pop_double();
  double arg_optval = fbr.pop_double();
  double rval = self->method_with_floats (arg_input, arg_optval);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_string (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_MethodTestInterface_Interface *self;
  self = MethodTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  std::string arg_input = fbr.pop_string();
  std::string arg_optval = fbr.pop_string();
  std::string rval = self->method_with_string (arg_input, arg_optval);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_string (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_enum (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_MethodTestInterface_Interface *self;
  self = MethodTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  QuickEnum arg_input = QuickEnum (fbr.pop_evalue());
  QuickEnum arg_optval = QuickEnum (fbr.pop_evalue());
  QuickEnum rval = self->method_with_enum (arg_input, arg_optval);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_evalue (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_record (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_MethodTestInterface_Interface *self;
  self = MethodTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  QuickRecord arg_input;
  if (!arg_input.proto_pop (cpl, fbr)) return false;
  QuickRecord arg_optval;
  if (!arg_optval.proto_pop (cpl, fbr)) return false;
  QuickRecord rval = self->method_with_record (arg_input, arg_optval);
  FieldBuffer &rb = *FieldBuffer::new_result();
  if (!rval.proto_add (cpl, rb)) return false;
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_sequence (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_MethodTestInterface_Interface *self;
  self = MethodTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  QuickSequence arg_input;
  if (!arg_input.proto_pop (cpl, fbr)) return false;
  QuickSequence arg_optval;
  if (!arg_optval.proto_pop (cpl, fbr)) return false;
  QuickSequence rval = self->method_with_sequence (arg_input, arg_optval);
  FieldBuffer &rb = *FieldBuffer::new_result();
  if (!rval.proto_add (cpl, rb)) return false;
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_interface (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_MethodTestInterface_Interface *self;
  self = MethodTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  I_GrandChild_Interface *arg_input = GrandChild_SmartHandle (cpl, fbr).operator->();
  I_GrandChild_Interface *arg_optval = GrandChild_SmartHandle (cpl, fbr).operator->();
  I_GrandChild_Interface *rval = self->method_with_interface (*arg_input, *arg_optval);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_object (GrandChild_SmartHandle (rval)._rpc_id());
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_quickiface (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_MethodTestInterface_Interface *self;
  self = MethodTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  I_QuickIface_Interface *arg_input = QuickIface_SmartHandle (cpl, fbr).operator->();
  I_QuickIface_Interface *arg_iface0 = QuickIface_SmartHandle (cpl, fbr).operator->();
  I_QuickIface_Interface *rval = self->method_with_quickiface (*arg_input, *arg_iface0);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_object (QuickIface_SmartHandle (rval)._rpc_id());
  return &rb;
}

struct _CLOSURE_SignalTestInterface_void_result {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_void_result> SharedPtr;
  _CLOSURE_SignalTestInterface_void_result (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_void_result()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_void_result (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_void_result.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_void_result::SharedPtr sp (new _CLOSURE_SignalTestInterface_void_result (cpl, handler_id));
    cid = self->sig_void_result.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_bool_result {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_bool_result> SharedPtr;
  _CLOSURE_SignalTestInterface_bool_result (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_bool_result()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static bool
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
    return 0;
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_bool_result (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_bool_result.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_bool_result::SharedPtr sp (new _CLOSURE_SignalTestInterface_bool_result (cpl, handler_id));
    cid = self->sig_bool_result.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_int_result {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_int_result> SharedPtr;
  _CLOSURE_SignalTestInterface_int_result (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_int_result()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static int
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
    return 0;
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_int_result (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_int_result.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_int_result::SharedPtr sp (new _CLOSURE_SignalTestInterface_int_result (cpl, handler_id));
    cid = self->sig_int_result.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_float_result {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_float_result> SharedPtr;
  _CLOSURE_SignalTestInterface_float_result (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_float_result()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static double
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
    return 0;
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_float_result (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_float_result.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_float_result::SharedPtr sp (new _CLOSURE_SignalTestInterface_float_result (cpl, handler_id));
    cid = self->sig_float_result.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_string_result {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_string_result> SharedPtr;
  _CLOSURE_SignalTestInterface_string_result (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_string_result()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static std::string
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
    return "";
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_string_result (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_string_result.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_string_result::SharedPtr sp (new _CLOSURE_SignalTestInterface_string_result (cpl, handler_id));
    cid = self->sig_string_result.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_enum_result {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_enum_result> SharedPtr;
  _CLOSURE_SignalTestInterface_enum_result (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_enum_result()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static QuickEnum
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
    return QuickEnum (0);
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_enum_result (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_enum_result.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_enum_result::SharedPtr sp (new _CLOSURE_SignalTestInterface_enum_result (cpl, handler_id));
    cid = self->sig_enum_result.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_record_result {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_record_result> SharedPtr;
  _CLOSURE_SignalTestInterface_record_result (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_record_result()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static QuickRecord
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
    return QuickRecord();
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_record_result (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_record_result.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_record_result::SharedPtr sp (new _CLOSURE_SignalTestInterface_record_result (cpl, handler_id));
    cid = self->sig_record_result.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_sequence_result {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_sequence_result> SharedPtr;
  _CLOSURE_SignalTestInterface_sequence_result (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_sequence_result()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static QuickSequence
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
    return QuickSequence();
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_sequence_result (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_sequence_result.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_sequence_result::SharedPtr sp (new _CLOSURE_SignalTestInterface_sequence_result (cpl, handler_id));
    cid = self->sig_sequence_result.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_interface_result {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_interface_result> SharedPtr;
  _CLOSURE_SignalTestInterface_interface_result (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_interface_result()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static I_GrandChild_Interface*
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
    return 0;
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_interface_result (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_interface_result.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_interface_result::SharedPtr sp (new _CLOSURE_SignalTestInterface_interface_result (cpl, handler_id));
    cid = self->sig_interface_result.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_self_result {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_self_result> SharedPtr;
  _CLOSURE_SignalTestInterface_self_result (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_self_result()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static I_SignalTestInterface_Interface*
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
    return 0;
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_self_result (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_self_result.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_self_result::SharedPtr sp (new _CLOSURE_SignalTestInterface_self_result (cpl, handler_id));
    cid = self->sig_self_result.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_void_arg {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_void_arg> SharedPtr;
  _CLOSURE_SignalTestInterface_void_arg (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_void_arg()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_void_arg (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_void_arg.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_void_arg::SharedPtr sp (new _CLOSURE_SignalTestInterface_void_arg (cpl, handler_id));
    cid = self->sig_void_arg.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_bool_arg {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_bool_arg> SharedPtr;
  _CLOSURE_SignalTestInterface_bool_arg (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_bool_arg()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (bool arg_b,
           SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 1);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    fb.add_int64 (arg_b);
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_bool_arg (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_bool_arg.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_bool_arg::SharedPtr sp (new _CLOSURE_SignalTestInterface_bool_arg (cpl, handler_id));
    cid = self->sig_bool_arg.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_int_arg {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_int_arg> SharedPtr;
  _CLOSURE_SignalTestInterface_int_arg (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_int_arg()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (int arg_i,
           SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 1);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    fb.add_int64 (arg_i);
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_int_arg (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_int_arg.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_int_arg::SharedPtr sp (new _CLOSURE_SignalTestInterface_int_arg (cpl, handler_id));
    cid = self->sig_int_arg.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_float_arg {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_float_arg> SharedPtr;
  _CLOSURE_SignalTestInterface_float_arg (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_float_arg()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (double arg_f,
           SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 1);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    fb.add_double (arg_f);
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_float_arg (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_float_arg.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_float_arg::SharedPtr sp (new _CLOSURE_SignalTestInterface_float_arg (cpl, handler_id));
    cid = self->sig_float_arg.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_string_arg {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_string_arg> SharedPtr;
  _CLOSURE_SignalTestInterface_string_arg (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_string_arg()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (const std::string &arg_s,
           SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 1);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    fb.add_string (arg_s);
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_string_arg (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_string_arg.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_string_arg::SharedPtr sp (new _CLOSURE_SignalTestInterface_string_arg (cpl, handler_id));
    cid = self->sig_string_arg.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_enum_arg {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_enum_arg> SharedPtr;
  _CLOSURE_SignalTestInterface_enum_arg (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_enum_arg()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (QuickEnum arg_e,
           SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 1);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    fb.add_evalue (arg_e);
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_enum_arg (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_enum_arg.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_enum_arg::SharedPtr sp (new _CLOSURE_SignalTestInterface_enum_arg (cpl, handler_id));
    cid = self->sig_enum_arg.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_record_arg {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_record_arg> SharedPtr;
  _CLOSURE_SignalTestInterface_record_arg (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_record_arg()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (const QuickRecord &arg_r,
           SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 1);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    if (!arg_r.proto_add (sp->m_coupler, fb)) THROW_ERROR();
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_record_arg (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_record_arg.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_record_arg::SharedPtr sp (new _CLOSURE_SignalTestInterface_record_arg (cpl, handler_id));
    cid = self->sig_record_arg.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_sequence_arg {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_sequence_arg> SharedPtr;
  _CLOSURE_SignalTestInterface_sequence_arg (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_sequence_arg()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (const QuickSequence &arg_s,
           SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 1);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    if (!arg_s.proto_add (sp->m_coupler, fb)) THROW_ERROR();
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_sequence_arg (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_sequence_arg.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_sequence_arg::SharedPtr sp (new _CLOSURE_SignalTestInterface_sequence_arg (cpl, handler_id));
    cid = self->sig_sequence_arg.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_interface_arg {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_interface_arg> SharedPtr;
  _CLOSURE_SignalTestInterface_interface_arg (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_interface_arg()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (I_GrandChild_Interface &arg_i,
           SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 1);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    fb.add_object (arg_i._rpc_id());
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_interface_arg (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_interface_arg.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_interface_arg::SharedPtr sp (new _CLOSURE_SignalTestInterface_interface_arg (cpl, handler_id));
    cid = self->sig_interface_arg.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_SignalTestInterface_self_args {
  typedef Plic::shared_ptr<_CLOSURE_SignalTestInterface_self_args> SharedPtr;
  _CLOSURE_SignalTestInterface_self_args (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_SignalTestInterface_self_args()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (I_SignalTestInterface_Interface &arg_self_,
           SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 1);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    fb.add_object (arg_self_._rpc_id());
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__SignalTestInterface_self_args (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_SignalTestInterface_Interface *self;
  self = SignalTestInterface_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_self_args.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_SignalTestInterface_self_args::SharedPtr sp (new _CLOSURE_SignalTestInterface_self_args (cpl, handler_id));
    cid = self->sig_self_args.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}

} // InterfaceTests

namespace RapicornPlicTest {
struct _CLOSURE_ButtonArea_check_activate {
  typedef Plic::shared_ptr<_CLOSURE_ButtonArea_check_activate> SharedPtr;
  _CLOSURE_ButtonArea_check_activate (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_ButtonArea_check_activate()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static bool
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
    return 0;
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__ButtonArea_check_activate (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_ButtonArea_Interface *self;
  self = ButtonArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_check_activate.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_ButtonArea_check_activate::SharedPtr sp (new _CLOSURE_ButtonArea_check_activate (cpl, handler_id));
    cid = self->sig_check_activate.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
struct _CLOSURE_ButtonArea_activate {
  typedef Plic::shared_ptr<_CLOSURE_ButtonArea_activate> SharedPtr;
  _CLOSURE_ButtonArea_activate (Plic::Coupler &cpl, uint64 h) : m_coupler (cpl), m_handler (h) {}
  ~_CLOSURE_ButtonArea_activate()
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1);
    fb.add_int64 (Plic::msgid_discon);
    fb.add_int64 (m_handler);
    m_coupler.push_event (&fb); // deletes fb
  }
  static void
  handler (SharedPtr sp)
  {
    FieldBuffer &fb = *FieldBuffer::_new (1 + 1 + 0);
    fb.add_int64 (Plic::msgid_event);
    fb.add_int64 (sp->m_handler);
    sp->m_coupler.push_event (&fb); // deletes fb
  }
  private: Plic::Coupler &m_coupler; uint64 m_handler;
};
static FieldBuffer*
_dispatch__ButtonArea_activate (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 2) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_ButtonArea_Interface *self;
  self = ButtonArea_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_activate.disconnect (con_id);
  if (handler_id) {
    _CLOSURE_ButtonArea_activate::SharedPtr sp (new _CLOSURE_ButtonArea_activate (cpl, handler_id));
    cid = self->sig_activate.connect (slot (sp->handler, sp)); }
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}

static FieldBuffer*
_dispatch__PureMethods_pure_method (Coupler &cpl)
{
  FieldBufferReader &fbr = cpl.reader;
  fbr.skip_hash(); // TypeHash
  if (fbr.remaining() != 1 + 1) return FieldBuffer::new_error ("invalid number of arguments", __func__);
  I_PureMethods_Interface *self;
  self = PureMethods_SmartHandle (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  double arg_f = fbr.pop_double();
  int rval = self->pure_method (arg_f);
  FieldBuffer &rb = *FieldBuffer::new_result();
  rb.add_int64 (rval);
  return &rb;
}

static const Plic::DispatcherEntry _dispatcher_entries[] = {
  { { 0x200000001dfd7256ULL, 0xdec25cd632ee83caULL, 0x06b4549d6fedf832ULL, 0x9a1e54caedf1db9bULL }, MandatoryNamespace::_dispatch__FirstInterface_void_func, },
  { { 0x30000000fd8072dfULL, 0x591f7cce6e74034aULL, 0x419df82c635c78d1ULL, 0x1e2fc6cf88d761faULL }, InterfaceTests::_dispatch__UIWidgetArea_simple_method, },
  { { 0x3000000075ce4c8bULL, 0x1a40a9c8bd145a39ULL, 0x37b83f96f1d3168bULL, 0x3f57c461185c3752ULL }, InterfaceTests::_dispatch__UIWidgetArea_single_arg, },
  { { 0x30000000179c202fULL, 0xa554850da029f547ULL, 0xe2591a43b7c79a61ULL, 0xe19a6853f11b1b99ULL }, InterfaceTests::_dispatch__UIWidgetArea_single_arg2, },
  { { 0x300000006a210506ULL, 0xa76bb7cd90d84838ULL, 0x8000823cfb905b8cULL, 0x39826abcf9caba00ULL }, InterfaceTests::_dispatch__UIWidgetArea_two_args, },
  { { 0x30000000ac125ff1ULL, 0xac6be3d45e25ada6ULL, 0x040efc8ab508b1d3ULL, 0x15e48df9e26c0caaULL }, InterfaceTests::_dispatch__UIWidgetArea_two_args2, },
  { { 0x300000000361838dULL, 0xc298afde820561a5ULL, 0x8fe8c83788c4bb38ULL, 0xb3179ae3d510e7b2ULL }, InterfaceTests::_dispatch__UIWidgetArea_multi_args, },
  { { 0x30000000b9d64621ULL, 0x3a96692d3e1ef7dbULL, 0xdced671b586f7aa7ULL, 0x1d3870f7ed0285e5ULL }, InterfaceTests::_dispatch__UIWidgetArea_self_method, },
  { { 0x200000000ff38422ULL, 0x440e8e84942acf8eULL, 0x0c4945e5794d8356ULL, 0x2e2e61471f31bfbfULL }, InterfaceTests::_dispatch__UIWidgetArea_void_method, },
  { { 0x300000004b649644ULL, 0x8a9b2140ad7fc83dULL, 0x10b67ed382387b14ULL, 0xe7b6cc0714a17f30ULL }, InterfaceTests::_dispatch__UIWidgetArea_on_click2out, },
  { { 0x20000000f671167cULL, 0xdfc42ce42beb58f7ULL, 0x15afc969aae521d6ULL, 0xadbec8ab9522f6f8ULL }, InterfaceTests::_dispatch__UIWidgetArea_on_click2in, },
  { { 0x50000000257c7180ULL, 0xfac77ebb19c6ab72ULL, 0xb34dd194f62b665dULL, 0x0c329a03aebf472bULL }, InterfaceTests::_dispatch__UIWidgetArea_void_signal, },
  { { 0x50000000a31a6e24ULL, 0xfe2020b5b9671356ULL, 0x11e8a29ccb87db27ULL, 0xcbe662a2887ef78fULL }, InterfaceTests::_dispatch__UIWidgetArea_sample_signal, },
  { { 0x20000000be855008ULL, 0x6bf2269ff6939544ULL, 0x6a0846e9f5a62da8ULL, 0x59c8e2a4e4629e80ULL }, InterfaceTests::_dispatch__QuickIface_simple_function, },
  { { 0x20000000a426153aULL, 0x0a2f5758267a2651ULL, 0xd9bff16cf6755833ULL, 0x8959ddaf9e5b8a44ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_void, },
  { { 0x300000003917295eULL, 0x76cb59d18d695319ULL, 0x0fe6acdaa38d48dfULL, 0xa26ca0854c18e565ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_bools, },
  { { 0x3000000015f688dcULL, 0x4db9c06f4357aa4eULL, 0x902ee7647790de7cULL, 0x18aa217be2c83cbaULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_ints, },
  { { 0x30000000bfc2d47bULL, 0x70b13d1cdf2c9488ULL, 0x77c2ea3ad44c2625ULL, 0xd6093e05e70ea643ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_floats, },
  { { 0x300000002732b2feULL, 0x6dfd49db44b97641ULL, 0x010dcacac6eb8ed7ULL, 0xa79383e035fc64e1ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_string, },
  { { 0x300000003f676d86ULL, 0x903cbdda7f9bf8e6ULL, 0xb56b87771cbd4b69ULL, 0x5723ee9d219ddda5ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_enum, },
  { { 0x3000000004a0b014ULL, 0x7eef09335a6cd6afULL, 0xd80237b6e1df12f6ULL, 0x70618be70ed6e858ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_record, },
  { { 0x30000000e92eb1f1ULL, 0xbc6d5e758278964aULL, 0xe88f958f88ca346cULL, 0xf29e446630c57f23ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_sequence, },
  { { 0x3000000001640ae0ULL, 0xf5403244c684c076ULL, 0x208c721dda088467ULL, 0x425f3425b0dcfad4ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_interface, },
  { { 0x3000000082dc142eULL, 0x7d16cadebfca9b39ULL, 0x168d05eb3cf56adbULL, 0x31e28c41cf8bb4f9ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_quickiface, },
  { { 0x50000000d7b0d37dULL, 0x9a68ffaf1056fc04ULL, 0xb24f3d15ee791645ULL, 0x979c5c3dbb482dbdULL }, InterfaceTests::_dispatch__SignalTestInterface_void_result, },
  { { 0x5000000088395bfcULL, 0xb616815b8edaee44ULL, 0x37cc8b54b7500777ULL, 0xfe7258a75f8cb6b8ULL }, InterfaceTests::_dispatch__SignalTestInterface_bool_result, },
  { { 0x500000007d3c1951ULL, 0xf389540a04382db9ULL, 0xc26a2ee92fb29b95ULL, 0x1197b72e8fa6cfb2ULL }, InterfaceTests::_dispatch__SignalTestInterface_int_result, },
  { { 0x5000000021a8c164ULL, 0xecca5d4028d51f60ULL, 0x5e48820b0f116b7aULL, 0x1dcb611973ca7901ULL }, InterfaceTests::_dispatch__SignalTestInterface_float_result, },
  { { 0x5000000036e51367ULL, 0x21d4eda0c22f5ae7ULL, 0xb4663cb8cc9c5b6cULL, 0xaed8617878324d33ULL }, InterfaceTests::_dispatch__SignalTestInterface_string_result, },
  { { 0x500000006e50988aULL, 0x8edca7e533dbb84aULL, 0xc4d53e76a28e2cb2ULL, 0xe873a3116ee5f47bULL }, InterfaceTests::_dispatch__SignalTestInterface_enum_result, },
  { { 0x5000000055dcef7fULL, 0x8478d3457cd87d65ULL, 0x9749c1b1c287f9a7ULL, 0xb21d98dd311f88a0ULL }, InterfaceTests::_dispatch__SignalTestInterface_record_result, },
  { { 0x500000007ede93d1ULL, 0xc6d90e002209318dULL, 0xac81039a018518edULL, 0xb4d95ba887b99c60ULL }, InterfaceTests::_dispatch__SignalTestInterface_sequence_result, },
  { { 0x50000000c6e0f2dbULL, 0xf7660a7b33a76e14ULL, 0xcbdade8c0d53d333ULL, 0x235f30d69ba62708ULL }, InterfaceTests::_dispatch__SignalTestInterface_interface_result, },
  { { 0x500000000f7a484aULL, 0x8668cf9bda70ae96ULL, 0x6404938807ad413fULL, 0x48f1a8d3ba35d215ULL }, InterfaceTests::_dispatch__SignalTestInterface_self_result, },
  { { 0x50000000390ef9ebULL, 0x5fe021fa95e46c90ULL, 0xbb481496867f8fbbULL, 0xd0d4f522490eed0fULL }, InterfaceTests::_dispatch__SignalTestInterface_void_arg, },
  { { 0x500000008ae3eb10ULL, 0x0cd818645da43e38ULL, 0x28c3e51ddb121821ULL, 0x2c1f84e70ce9d966ULL }, InterfaceTests::_dispatch__SignalTestInterface_bool_arg, },
  { { 0x50000000c91ca108ULL, 0xcf9f85d25bb75bc8ULL, 0xa19af414c58a3ac6ULL, 0x688d4f1445624c0cULL }, InterfaceTests::_dispatch__SignalTestInterface_int_arg, },
  { { 0x5000000075078428ULL, 0x45d29e0377897dd2ULL, 0xb04599be75058416ULL, 0xa4be1bdf79af6b27ULL }, InterfaceTests::_dispatch__SignalTestInterface_float_arg, },
  { { 0x50000000cd2031d7ULL, 0xb127c8f2134a7e92ULL, 0x994f8b257e7550c1ULL, 0x86752a8f56f3202eULL }, InterfaceTests::_dispatch__SignalTestInterface_string_arg, },
  { { 0x500000007c8c24a8ULL, 0x6a34b5ca6ff1a9b1ULL, 0xa8421ac9442d7da7ULL, 0x397d7a2d9c23b69eULL }, InterfaceTests::_dispatch__SignalTestInterface_enum_arg, },
  { { 0x500000001ca9536aULL, 0x3a697b01329fe581ULL, 0xf253e5509e7ec080ULL, 0x99bab63bc8358923ULL }, InterfaceTests::_dispatch__SignalTestInterface_record_arg, },
  { { 0x500000003a8b02acULL, 0x350183fe2aaeadfeULL, 0x632ab314011b5d27ULL, 0xd1eb9724fd6133d9ULL }, InterfaceTests::_dispatch__SignalTestInterface_sequence_arg, },
  { { 0x50000000e570b3a9ULL, 0x414baa2ef0267861ULL, 0x7bb2d4e5515d1d91ULL, 0xfa502a9c448db3c8ULL }, InterfaceTests::_dispatch__SignalTestInterface_interface_arg, },
  { { 0x50000000c376b929ULL, 0xe5199bbf5bd2533aULL, 0x52977526a9c4e2c9ULL, 0x4b15ebcfa292e18fULL }, InterfaceTests::_dispatch__SignalTestInterface_self_args, },
  { { 0x500000002002b254ULL, 0x237b6d00631699f2ULL, 0xaa4a2bf137175f39ULL, 0x16724232857b7195ULL }, RapicornPlicTest::_dispatch__ButtonArea_check_activate, },
  { { 0x500000001eea842bULL, 0xdb7ee9164c9f8a60ULL, 0x1d0b0a314944036aULL, 0xfc73ff4aec88f8ffULL }, RapicornPlicTest::_dispatch__ButtonArea_activate, },
  { { 0x30000000e96382b8ULL, 0x8c16fe069c1d6b1eULL, 0x002e82b90c7db308ULL, 0x9c8a9e5a95b6ea99ULL }, RapicornPlicTest::_dispatch__PureMethods_pure_method, },
};
static Plic::DispatcherRegistry _dispatcher_registry (_dispatcher_entries);

} // RapicornPlicTest


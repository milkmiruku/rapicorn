/* --- Generated by PLIC-CxxStub --- */

// --- ServerHH Boilerplate ---
#include <rcore/plicutils.hh>
#include <rcore/rapicornsignal.hh>
using Rapicorn::Signals::slot;

// --- ClientCC/ServerCC Boilerplate ---
#include <string>
#include <vector>
#include <stdexcept>
#ifndef __PLIC_GENERIC_CC_BOILERPLATE__
#define __PLIC_GENERIC_CC_BOILERPLATE__

#define PLIC_CHECK(cond,errmsg) do { if (cond) break; throw std::runtime_error (std::string ("PLIC-ERROR: ") + errmsg); } while (0)

namespace { // Anonymous
using Plic::uint64;

static __attribute__ ((__format__ (__printf__, 1, 2), unused))
Plic::FieldBuffer* plic$_error (const char *format, ...)
{
  va_list args;
  va_start (args, format);
  Plic::error_vprintf (format, args);
  va_end (args);
  return NULL;
}

} // Anonymous
#endif // __PLIC_GENERIC_CC_BOILERPLATE__


#ifndef PLIC_CONNECTION
#define PLIC_CONNECTION()       (*(Plic::Connection*)NULL)
template<class O> O* connection_id2object (uint64 oid) { return dynamic_cast<O*> (reinterpret_cast<Plic::SimpleServer*> (oid)); }
inline uint64        connection_object2id (const Plic::SimpleServer *obj) { return reinterpret_cast<ptrdiff_t> (obj); }
inline uint64        connection_object2id (const Plic::SimpleServer &obj) { return connection_object2id (&obj); }
#endif // !PLIC_CONNECTION


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {

enum Empty {
};

enum Enum1 {
  E1_A = 1,
};

enum Enum1c {
  E1C_A = 1,
};

enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};

enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};

enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};

enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};

enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};

enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};

enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};

enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};

enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};

class I_FirstInterface_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class FirstInterface.
{
protected:
  explicit                         I_FirstInterface_Interface ();
  virtual /*Des*/                 ~I_FirstInterface_Interface () = 0;
public:
  virtual void                    void_func                  ();
};

struct XFooRecordImpl {
  bool                    single_bool;
  int                     single_num;
  double                  single_float;
  std::string             single_string;
  int                     sibling1;
  int                     sibling2;
  int                     multi1;
  int                     multi2;
  int                     multi3;
  int                     multi4;
  ExtensiveEnum           enum_field;
  I_FirstInterface_Interface* iface1;
  I_FirstInterface_Interface* iface2;
  I_FirstInterface_Interface* iface3;
  inline                  XFooRecordImpl () { single_bool = 0; single_num = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
void operator<< (Plic::FieldBuffer&, const XFooRecordImpl&);
void operator>> (Plic::FieldReader&, XFooRecordImpl&);

struct XFooSequenceImpl : public std::vector<bool> {
  typedef std::vector<bool> Sequence;
};
void operator<< (Plic::FieldBuffer&, const XFooSequenceImpl&);
void operator>> (Plic::FieldReader&, XFooSequenceImpl&);

struct IntSequenceImpl : public std::vector<int> {
  typedef std::vector<int> Sequence;
};
void operator<< (Plic::FieldBuffer&, const IntSequenceImpl&);
void operator>> (Plic::FieldReader&, IntSequenceImpl&);

struct FloatSequenceImpl : public std::vector<double> {
  typedef std::vector<double> Sequence;
};
void operator<< (Plic::FieldBuffer&, const FloatSequenceImpl&);
void operator>> (Plic::FieldReader&, FloatSequenceImpl&);

struct StringSequenceImpl : public std::vector<std::string> {
  typedef std::vector<std::string> Sequence;
};
void operator<< (Plic::FieldBuffer&, const StringSequenceImpl&);
void operator>> (Plic::FieldReader&, StringSequenceImpl&);

struct ExtensiveEnumSequenceImpl : public std::vector<ExtensiveEnum> {
  typedef std::vector<ExtensiveEnum> Sequence;
};
void operator<< (Plic::FieldBuffer&, const ExtensiveEnumSequenceImpl&);
void operator>> (Plic::FieldReader&, ExtensiveEnumSequenceImpl&);

struct RecordSequenceImpl : public std::vector<XFooRecordImpl> {
  typedef std::vector<XFooRecordImpl> Sequence;
};
void operator<< (Plic::FieldBuffer&, const RecordSequenceImpl&);
void operator>> (Plic::FieldReader&, RecordSequenceImpl&);

struct SequenceSequenceImpl : public std::vector<IntSequenceImpl> {
  typedef std::vector<IntSequenceImpl> Sequence;
};
void operator<< (Plic::FieldBuffer&, const SequenceSequenceImpl&);
void operator>> (Plic::FieldReader&, SequenceSequenceImpl&);

struct InterfaceSequenceImpl : public std::vector<I_FirstInterface_Interface*> {
  typedef std::vector<I_FirstInterface_Interface*> Sequence;
};
void operator<< (Plic::FieldBuffer&, const InterfaceSequenceImpl&);
void operator>> (Plic::FieldReader&, InterfaceSequenceImpl&);

struct NestedTypesRecImpl {
  XFooRecordImpl          rec;
  XFooSequenceImpl        seq;
  inline                  NestedTypesRecImpl () { }
};
void operator<< (Plic::FieldBuffer&, const NestedTypesRecImpl&);
void operator>> (Plic::FieldReader&, NestedTypesRecImpl&);

struct NestedTypesSeqImpl : public std::vector<NestedTypesRecImpl> {
  typedef std::vector<NestedTypesRecImpl> Sequence;
};
void operator<< (Plic::FieldBuffer&, const NestedTypesSeqImpl&);
void operator>> (Plic::FieldReader&, NestedTypesSeqImpl&);

typedef int AliasInt;

typedef double AliasFloat;

typedef bool AliasBool;

typedef std::string AliasString;

typedef XFooRecordImpl AliasRecord;

typedef XFooSequenceImpl AliasSequence;

typedef ExtensiveEnum AliasEnum;

struct NewRecordImpl {
  int                     i;
  Enum1                   enum1;
  XFooSequenceImpl        xfs;
  NestedTypesRecImpl      ntr;
  inline                  NewRecordImpl () { i = 0; enum1 = Enum1 (0); }
};
void operator<< (Plic::FieldBuffer&, const NewRecordImpl&);
void operator>> (Plic::FieldReader&, NewRecordImpl&);

namespace Inner {

struct InnerRecordImpl {
  int                     x;
  int                     y;
  NewRecordImpl           rec;
  inline                  InnerRecordImpl () { x = 0; y = 0; }
};
void operator<< (Plic::FieldBuffer&, const InnerRecordImpl&);
void operator>> (Plic::FieldReader&, InnerRecordImpl&);
} // Inner

struct Refer2InnerImpl {
  Inner::InnerRecordImpl  r;
  inline                  Refer2InnerImpl () { }
};
void operator<< (Plic::FieldBuffer&, const Refer2InnerImpl&);
void operator>> (Plic::FieldReader&, Refer2InnerImpl&);
} // MandatoryNamespace

namespace OtherNamespace {

struct SomeRecordImpl {
  MandatoryNamespace::NewRecordImpl r1;
  MandatoryNamespace::NewRecordImpl r2;
  MandatoryNamespace::Inner::InnerRecordImpl r3;
  MandatoryNamespace::Inner::InnerRecordImpl r4;
  inline                  SomeRecordImpl () { }
};
void operator<< (Plic::FieldBuffer&, const SomeRecordImpl&);
void operator>> (Plic::FieldReader&, SomeRecordImpl&);
} // OtherNamespace

namespace Auxdata {

typedef int bar;

typedef double x;

typedef std::string s;
} // Auxdata

namespace InterfaceTests {

class I_UIWidgetArea_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class UIWidgetArea.
{
protected:
  explicit                         I_UIWidgetArea_Interface ();
  virtual /*Des*/                 ~I_UIWidgetArea_Interface () = 0;
public:
  virtual double                  dummy    () const = 0;
  virtual void                    dummy    (double) = 0;
  virtual std::string             on_click () const = 0;
  virtual void                    on_click (const std::string&) = 0;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::Signal<I_UIWidgetArea_Interface, double (I_UIWidgetArea_Interface &ba1, int someint)> Signal_sample_signal;
  Signal_void_signal sig_void_signal;
  Signal_sample_signal sig_sample_signal;
  virtual double                  simple_method            ();
  virtual double                  single_arg               (int n);
  virtual double                  single_arg2              (int n = 5);
  virtual double                  two_args                 (int n,
                                                            double r);
  virtual double                  two_args2                (int n = 6,
                                                            double r = 7.7);
  virtual double                  multi_args               (int n,
                                                            double r,
                                                            int i,
                                                            const std::string &s = "String ding",
                                                            double y = 5);
  virtual double                  self_method              (I_UIWidgetArea_Interface &ba1,
                                                            I_UIWidgetArea_Interface &ba2);
  virtual void                    void_method              ();
  virtual std::string             on_click2out             ();
  virtual void                    on_click2in              (const std::string &command);
};

class I_Parent_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class Parent.
{
protected:
  explicit                         I_Parent_Interface ();
  virtual /*Des*/                 ~I_Parent_Interface () = 0;
public:
};

class I_Child_Interface : public virtual I_Parent_Interface
  /// See also the corresponding IDL class Child.
{
protected:
  explicit                         I_Child_Interface ();
  virtual /*Des*/                 ~I_Child_Interface () = 0;
public:
};

class I_Descendant_Interface : public virtual I_Child_Interface
  /// See also the corresponding IDL class Descendant.
{
protected:
  explicit                         I_Descendant_Interface ();
  virtual /*Des*/                 ~I_Descendant_Interface () = 0;
public:
};

class I_GrandChild_Interface : public virtual I_Descendant_Interface
  /// See also the corresponding IDL class GrandChild.
{
protected:
  explicit                         I_GrandChild_Interface ();
  virtual /*Des*/                 ~I_GrandChild_Interface () = 0;
public:
};

enum QuickEnum {
  ZERO = 0,
};

struct QuickRecordImpl {
  int                     int1;
  int                     int2;
  inline                  QuickRecordImpl () { int1 = 0; int2 = 0; }
};
void operator<< (Plic::FieldBuffer&, const QuickRecordImpl&);
void operator>> (Plic::FieldReader&, QuickRecordImpl&);

struct QuickSequenceImpl : public std::vector<double> {
  typedef std::vector<double> Sequence;
};
void operator<< (Plic::FieldBuffer&, const QuickSequenceImpl&);
void operator>> (Plic::FieldReader&, QuickSequenceImpl&);

class I_QuickIface_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class QuickIface.
{
protected:
  explicit                         I_QuickIface_Interface ();
  virtual /*Des*/                 ~I_QuickIface_Interface () = 0;
public:
  virtual void                    simple_function        (int i = 9);
};

class I_MethodTestInterface_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class MethodTestInterface.
{
protected:
  explicit                         I_MethodTestInterface_Interface ();
  virtual /*Des*/                 ~I_MethodTestInterface_Interface () = 0;
public:
  virtual void                    method_with_void                ();
  virtual bool                    method_with_bools               (bool input,
                                                                   bool optval = 0);
  virtual int                     method_with_ints                (int input,
                                                                   int optval = -2);
  virtual double                  method_with_floats              (double input,
                                                                   double optval = 309.9);
  virtual std::string             method_with_string              (const std::string &input,
                                                                   const std::string &optval = "default");
  virtual QuickEnum               method_with_enum                (QuickEnum input,
                                                                   QuickEnum optval = QuickEnum (0));
  virtual QuickRecordImpl         method_with_record              (const QuickRecordImpl &input,
                                                                   const QuickRecordImpl &optval = QuickRecordImpl());
  virtual QuickSequenceImpl       method_with_sequence            (const QuickSequenceImpl &input,
                                                                   const QuickSequenceImpl &optval = QuickSequenceImpl());
  virtual I_GrandChild_Interface* method_with_interface           (I_GrandChild_Interface &input,
                                                                   I_GrandChild_Interface &optval = *(I_GrandChild_Interface*) NULL);
  virtual I_QuickIface_Interface* method_with_quickiface          (I_QuickIface_Interface &input,
                                                                   I_QuickIface_Interface &iface0 = *(I_QuickIface_Interface*) NULL);
};

class I_SignalTestInterface_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class SignalTestInterface.
{
protected:
  explicit                         I_SignalTestInterface_Interface ();
  virtual /*Des*/                 ~I_SignalTestInterface_Interface () = 0;
public:
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, bool ()> Signal_bool_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, int ()> Signal_int_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, double ()> Signal_float_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, std::string ()> Signal_string_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickEnum ()> Signal_enum_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickRecordImpl ()> Signal_record_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, QuickSequenceImpl ()> Signal_sequence_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_GrandChild_Interface* ()> Signal_interface_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, I_SignalTestInterface_Interface* ()> Signal_self_result;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void ()> Signal_void_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (bool b)> Signal_bool_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (int i)> Signal_int_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (double f)> Signal_float_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const std::string &s)> Signal_string_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (QuickEnum e)> Signal_enum_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickRecordImpl &r)> Signal_record_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (const QuickSequenceImpl &s)> Signal_sequence_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_GrandChild_Interface &i)> Signal_interface_arg;
  typedef Rapicorn::Signals::Signal<I_SignalTestInterface_Interface, void (I_SignalTestInterface_Interface &self_)> Signal_self_args;
  Signal_void_result sig_void_result;
  Signal_bool_result sig_bool_result;
  Signal_int_result sig_int_result;
  Signal_float_result sig_float_result;
  Signal_string_result sig_string_result;
  Signal_enum_result sig_enum_result;
  Signal_record_result sig_record_result;
  Signal_sequence_result sig_sequence_result;
  Signal_interface_result sig_interface_result;
  Signal_self_result sig_self_result;
  Signal_void_arg sig_void_arg;
  Signal_bool_arg sig_bool_arg;
  Signal_int_arg sig_int_arg;
  Signal_float_arg sig_float_arg;
  Signal_string_arg sig_string_arg;
  Signal_enum_arg sig_enum_arg;
  Signal_record_arg sig_record_arg;
  Signal_sequence_arg sig_sequence_arg;
  Signal_interface_arg sig_interface_arg;
  Signal_self_args sig_self_args;
};

class I_PropertyTester_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class PropertyTester.
{
protected:
  explicit                         I_PropertyTester_Interface ();
  virtual /*Des*/                 ~I_PropertyTester_Interface () = 0;
public:
  virtual bool                    bool_prop      () const = 0;
  virtual void                    bool_prop      (bool) = 0;
  virtual int                     int_prop       () const = 0;
  virtual void                    int_prop       (int) = 0;
  virtual double                  float_prop     () const = 0;
  virtual void                    float_prop     (double) = 0;
  virtual std::string             string_prop    () const = 0;
  virtual void                    string_prop    (const std::string&) = 0;
  virtual QuickEnum               enum_prop      () const = 0;
  virtual void                    enum_prop      (QuickEnum) = 0;
  virtual QuickRecordImpl         record_prop    () const = 0;
  virtual void                    record_prop    (const QuickRecordImpl&) = 0;
  virtual QuickSequenceImpl       sequence_prop  () const = 0;
  virtual void                    sequence_prop  (const QuickSequenceImpl&) = 0;
  virtual I_GrandChild_Interface* interface_prop () const = 0;
  virtual void                    interface_prop (I_GrandChild_Interface*) = 0;
  virtual I_PropertyTester_Interface* self_prop      () const = 0;
  virtual void                    self_prop      (I_PropertyTester_Interface*) = 0;
};
} // InterfaceTests

namespace RapicornPlicTest {

enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};

class I_ButtonArea_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class ButtonArea.
{
protected:
  explicit                         I_ButtonArea_Interface ();
  virtual /*Des*/                 ~I_ButtonArea_Interface () = 0;
public:
  virtual std::string             on_click   () const = 0;
  virtual void                    on_click   (const std::string&) = 0;
  virtual std::string             on_click2  () const = 0;
  virtual void                    on_click2  (const std::string&) = 0;
  virtual std::string             on_click3  () const = 0;
  virtual void                    on_click3  (const std::string&) = 0;
  virtual ClickType               click_type () const = 0;
  virtual void                    click_type (ClickType) = 0;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, bool (), Rapicorn::Signals::CollectorUntil0<bool> > Signal_check_activate;
  typedef Rapicorn::Signals::Signal<I_ButtonArea_Interface, void ()> Signal_activate;
  Signal_check_activate sig_check_activate;
  Signal_activate sig_activate;
};

class I_PureMethods_Interface;

class I_PureMethods_Interface : public virtual Plic::SimpleServer
  /// See also the corresponding IDL class PureMethods.
{
protected:
  explicit                         I_PureMethods_Interface ();
  virtual /*Des*/                 ~I_PureMethods_Interface () = 0;
public:
  virtual int                     pure_method             (double f) = 0;
};
} // RapicornPlicTest

// --- Implementations ---

namespace MandatoryNamespace {

I_FirstInterface_Interface::I_FirstInterface_Interface ()
{}
I_FirstInterface_Interface::~I_FirstInterface_Interface () {}
void
operator<< (Plic::FieldBuffer &dst, const XFooRecordImpl &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (14);
  fb.add_int64 (self.single_bool);
  fb.add_int64 (self.single_num);
  fb.add_double (self.single_float);
  fb.add_string (self.single_string);
  fb.add_int64 (self.sibling1);
  fb.add_int64 (self.sibling2);
  fb.add_int64 (self.multi1);
  fb.add_int64 (self.multi2);
  fb.add_int64 (self.multi3);
  fb.add_int64 (self.multi4);
  fb.add_evalue (self.enum_field);
  fb.add_object (connection_object2id (self.iface1));
  fb.add_object (connection_object2id (self.iface2));
  fb.add_object (connection_object2id (self.iface3));
}
void
operator>> (Plic::FieldReader &src, XFooRecordImpl &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 14) return;
  self.single_bool = fbr.pop_int64();
  self.single_num = fbr.pop_int64();
  self.single_float = fbr.pop_double();
  self.single_string = fbr.pop_string();
  self.sibling1 = fbr.pop_int64();
  self.sibling2 = fbr.pop_int64();
  self.multi1 = fbr.pop_int64();
  self.multi2 = fbr.pop_int64();
  self.multi3 = fbr.pop_int64();
  self.multi4 = fbr.pop_int64();
  self.enum_field = ExtensiveEnum (fbr.pop_evalue());
  self.iface1 = connection_id2object<I_FirstInterface_Interface> (fbr.pop_object());
  self.iface2 = connection_id2object<I_FirstInterface_Interface> (fbr.pop_object());
  self.iface3 = connection_id2object<I_FirstInterface_Interface> (fbr.pop_object());
}
void
operator<< (Plic::FieldBuffer &dst, const XFooSequenceImpl &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_int64 (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, XFooSequenceImpl &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (fbr.pop_int64());
  }
}
void
operator<< (Plic::FieldBuffer &dst, const IntSequenceImpl &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_int64 (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, IntSequenceImpl &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (fbr.pop_int64());
  }
}
void
operator<< (Plic::FieldBuffer &dst, const FloatSequenceImpl &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_double (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, FloatSequenceImpl &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (fbr.pop_double());
  }
}
void
operator<< (Plic::FieldBuffer &dst, const StringSequenceImpl &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_string (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, StringSequenceImpl &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (fbr.pop_string());
  }
}
void
operator<< (Plic::FieldBuffer &dst, const ExtensiveEnumSequenceImpl &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_evalue (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, ExtensiveEnumSequenceImpl &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (ExtensiveEnum (fbr.pop_evalue()));
  }
}
void
operator<< (Plic::FieldBuffer &dst, const RecordSequenceImpl &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
}
void
operator>> (Plic::FieldReader &src, RecordSequenceImpl &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
}
void
operator<< (Plic::FieldBuffer &dst, const SequenceSequenceImpl &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
}
void
operator>> (Plic::FieldReader &src, SequenceSequenceImpl &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
}
void
operator<< (Plic::FieldBuffer &dst, const InterfaceSequenceImpl &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_object (connection_object2id (self[k]));
  }
}
void
operator>> (Plic::FieldReader &src, InterfaceSequenceImpl &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (connection_id2object<I_FirstInterface_Interface> (fbr.pop_object()));
  }
}
void
operator<< (Plic::FieldBuffer &dst, const NestedTypesRecImpl &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  fb << self.rec;
  fb << self.seq;
}
void
operator>> (Plic::FieldReader &src, NestedTypesRecImpl &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  fbr >> self.rec;
  fbr >> self.seq;
}
void
operator<< (Plic::FieldBuffer &dst, const NestedTypesSeqImpl &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb << self[k];
  }
}
void
operator>> (Plic::FieldReader &src, NestedTypesSeqImpl &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.resize (len);
  for (size_t k = 0; k < len; k++) {
    fbr >> self[k];
  }
}
void
operator<< (Plic::FieldBuffer &dst, const NewRecordImpl &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  fb.add_int64 (self.i);
  fb.add_evalue (self.enum1);
  fb << self.xfs;
  fb << self.ntr;
}
void
operator>> (Plic::FieldReader &src, NewRecordImpl &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  self.i = fbr.pop_int64();
  self.enum1 = Enum1 (fbr.pop_evalue());
  fbr >> self.xfs;
  fbr >> self.ntr;
}

namespace Inner {
void
operator<< (Plic::FieldBuffer &dst, const InnerRecordImpl &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (3);
  fb.add_int64 (self.x);
  fb.add_int64 (self.y);
  fb << self.rec;
}
void
operator>> (Plic::FieldReader &src, InnerRecordImpl &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 3) return;
  self.x = fbr.pop_int64();
  self.y = fbr.pop_int64();
  fbr >> self.rec;
}
} // Inner
void
operator<< (Plic::FieldBuffer &dst, const Refer2InnerImpl &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (1);
  fb << self.r;
}
void
operator>> (Plic::FieldReader &src, Refer2InnerImpl &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 1) return;
  fbr >> self.r;
}
} // MandatoryNamespace

namespace OtherNamespace {
void
operator<< (Plic::FieldBuffer &dst, const SomeRecordImpl &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  fb << self.r1;
  fb << self.r2;
  fb << self.r3;
  fb << self.r4;
}
void
operator>> (Plic::FieldReader &src, SomeRecordImpl &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 4) return;
  fbr >> self.r1;
  fbr >> self.r2;
  fbr >> self.r3;
  fbr >> self.r4;
}
} // OtherNamespace

namespace InterfaceTests {

I_UIWidgetArea_Interface::I_UIWidgetArea_Interface () :
  sig_void_signal (*this), sig_sample_signal (*this)
{}
I_UIWidgetArea_Interface::~I_UIWidgetArea_Interface () {}

I_Parent_Interface::I_Parent_Interface ()
{}
I_Parent_Interface::~I_Parent_Interface () {}

I_Child_Interface::I_Child_Interface ()
{}
I_Child_Interface::~I_Child_Interface () {}

I_Descendant_Interface::I_Descendant_Interface ()
{}
I_Descendant_Interface::~I_Descendant_Interface () {}

I_GrandChild_Interface::I_GrandChild_Interface ()
{}
I_GrandChild_Interface::~I_GrandChild_Interface () {}
void
operator<< (Plic::FieldBuffer &dst, const QuickRecordImpl &self)
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  fb.add_int64 (self.int1);
  fb.add_int64 (self.int2);
}
void
operator>> (Plic::FieldReader &src, QuickRecordImpl &self)
{
  Plic::FieldReader fbr (src.pop_rec());
  if (fbr.remaining() < 2) return;
  self.int1 = fbr.pop_int64();
  self.int2 = fbr.pop_int64();
}
void
operator<< (Plic::FieldBuffer &dst, const QuickSequenceImpl &self)
{
  const size_t len = self.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_double (self[k]);
  }
}
void
operator>> (Plic::FieldReader &src, QuickSequenceImpl &self)
{
  Plic::FieldReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  self.reserve (len);
  for (size_t k = 0; k < len; k++) {
    self.push_back (fbr.pop_double());
  }
}

I_QuickIface_Interface::I_QuickIface_Interface ()
{}
I_QuickIface_Interface::~I_QuickIface_Interface () {}

I_MethodTestInterface_Interface::I_MethodTestInterface_Interface ()
{}
I_MethodTestInterface_Interface::~I_MethodTestInterface_Interface () {}

I_SignalTestInterface_Interface::I_SignalTestInterface_Interface () :
  sig_void_result (*this), sig_bool_result (*this), sig_int_result (*this), sig_float_result (*this), sig_string_result (*this), sig_enum_result (*this), sig_record_result (*this), sig_sequence_result (*this), sig_interface_result (*this), sig_self_result (*this), sig_void_arg (*this), sig_bool_arg (*this), sig_int_arg (*this), sig_float_arg (*this), sig_string_arg (*this), sig_enum_arg (*this), sig_record_arg (*this), sig_sequence_arg (*this), sig_interface_arg (*this), sig_self_args (*this)
{}
I_SignalTestInterface_Interface::~I_SignalTestInterface_Interface () {}

I_PropertyTester_Interface::I_PropertyTester_Interface ()
{}
I_PropertyTester_Interface::~I_PropertyTester_Interface () {}
} // InterfaceTests

namespace RapicornPlicTest {

I_ButtonArea_Interface::I_ButtonArea_Interface () :
  sig_check_activate (*this), sig_activate (*this)
{}
I_ButtonArea_Interface::~I_ButtonArea_Interface () {}

I_PureMethods_Interface::I_PureMethods_Interface ()
{}
I_PureMethods_Interface::~I_PureMethods_Interface () {}

// --- Method Dispatchers & Registry ---
} // RapicornPlicTest

namespace MandatoryNamespace {
static Plic::FieldBuffer*
_$caller__FirstInterface__void_func (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 0) return plic$_error ("invalid number of arguments");
  I_FirstInterface_Interface *self;
  self = connection_id2object<I_FirstInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  self->void_func ();
  return NULL;
}


namespace Inner {
} // Inner
} // MandatoryNamespace

namespace OtherNamespace {
} // OtherNamespace

namespace InterfaceTests {
static Plic::FieldBuffer*
_$getter__UIWidgetArea__dummy (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  double  rval = self->dummy ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$setter__UIWidgetArea__dummy (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  double  arg_dummy = fbr.pop_double();
  self->dummy (arg_dummy);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__UIWidgetArea__on_click (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_string (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$setter__UIWidgetArea__on_click (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click = fbr.pop_string();
  self->on_click (arg_on_click);
  return NULL;
}
static Plic::FieldBuffer*
_$caller__UIWidgetArea__simple_method (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 0) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  double  rval = self->simple_method ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__UIWidgetArea__single_arg (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  int  arg_n = fbr.pop_int64();
  double  rval = self->single_arg (arg_n);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__UIWidgetArea__single_arg2 (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  int  arg_n = fbr.pop_int64();
  double  rval = self->single_arg2 (arg_n);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__UIWidgetArea__two_args (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  int  arg_n = fbr.pop_int64();
  double  arg_r = fbr.pop_double();
  double  rval = self->two_args (arg_n, arg_r);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__UIWidgetArea__two_args2 (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  int  arg_n = fbr.pop_int64();
  double  arg_r = fbr.pop_double();
  double  rval = self->two_args2 (arg_n, arg_r);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__UIWidgetArea__multi_args (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 5) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  int  arg_n = fbr.pop_int64();
  double  arg_r = fbr.pop_double();
  int  arg_i = fbr.pop_int64();
  std::string  arg_s = fbr.pop_string();
  double  arg_y = fbr.pop_double();
  double  rval = self->multi_args (arg_n, arg_r, arg_i, arg_s, arg_y);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__UIWidgetArea__self_method (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  I_UIWidgetArea_Interface *arg_ba1 = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  I_UIWidgetArea_Interface *arg_ba2 = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  double  rval = self->self_method (*arg_ba1, *arg_ba2);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__UIWidgetArea__void_method (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 0) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  self->void_method ();
  return NULL;
}
static Plic::FieldBuffer*
_$caller__UIWidgetArea__on_click2out (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 0) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click2out ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_string (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__UIWidgetArea__on_click2in (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  arg_command = fbr.pop_string();
  self->on_click2in (arg_command);
  return NULL;
}
class _$Closure__UIWidgetArea__void_signal {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__UIWidgetArea__void_signal> SharedPtr;
  _$Closure__UIWidgetArea__void_signal (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__UIWidgetArea__void_signal()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__UIWidgetArea__void_signal (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_void_signal.disconnect (con_id);
  if (handler_id) {
    _$Closure__UIWidgetArea__void_signal::SharedPtr sp (new _$Closure__UIWidgetArea__void_signal (PLIC_CONNECTION(), handler_id));
    cid = self->sig_void_signal.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__UIWidgetArea__sample_signal {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__UIWidgetArea__sample_signal> SharedPtr;
  _$Closure__UIWidgetArea__sample_signal (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__UIWidgetArea__sample_signal()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static double
  handler (I_UIWidgetArea_Interface &arg_ba1,
           int arg_someint,
           SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 2);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    fb.add_object (connection_object2id (arg_ba1));
    fb.add_int64 (arg_someint);
    sp->m_connection.send_event (&fb); // deletes fb
    return 0;
  }
};
static Plic::FieldBuffer*
_$sigcon__UIWidgetArea__sample_signal (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_UIWidgetArea_Interface *self;
  self = connection_id2object<I_UIWidgetArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_sample_signal.disconnect (con_id);
  if (handler_id) {
    _$Closure__UIWidgetArea__sample_signal::SharedPtr sp (new _$Closure__UIWidgetArea__sample_signal (PLIC_CONNECTION(), handler_id));
    cid = self->sig_sample_signal.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}





static Plic::FieldBuffer*
_$caller__QuickIface__simple_function (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_QuickIface_Interface *self;
  self = connection_id2object<I_QuickIface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  int  arg_i = fbr.pop_int64();
  self->simple_function (arg_i);
  return NULL;
}

static Plic::FieldBuffer*
_$caller__MethodTestInterface__method_with_void (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 0) return plic$_error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  self = connection_id2object<I_MethodTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  self->method_with_void ();
  return NULL;
}
static Plic::FieldBuffer*
_$caller__MethodTestInterface__method_with_bools (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  self = connection_id2object<I_MethodTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  bool  arg_input = fbr.pop_int64();
  bool  arg_optval = fbr.pop_int64();
  bool  rval = self->method_with_bools (arg_input, arg_optval);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__MethodTestInterface__method_with_ints (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  self = connection_id2object<I_MethodTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  int  arg_input = fbr.pop_int64();
  int  arg_optval = fbr.pop_int64();
  int  rval = self->method_with_ints (arg_input, arg_optval);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__MethodTestInterface__method_with_floats (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  self = connection_id2object<I_MethodTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  double  arg_input = fbr.pop_double();
  double  arg_optval = fbr.pop_double();
  double  rval = self->method_with_floats (arg_input, arg_optval);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__MethodTestInterface__method_with_string (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  self = connection_id2object<I_MethodTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  arg_input = fbr.pop_string();
  std::string  arg_optval = fbr.pop_string();
  std::string  rval = self->method_with_string (arg_input, arg_optval);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_string (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__MethodTestInterface__method_with_enum (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  self = connection_id2object<I_MethodTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  QuickEnum  arg_input = QuickEnum (fbr.pop_evalue());
  QuickEnum  arg_optval = QuickEnum (fbr.pop_evalue());
  QuickEnum  rval = self->method_with_enum (arg_input, arg_optval);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_evalue (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$caller__MethodTestInterface__method_with_record (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  self = connection_id2object<I_MethodTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  QuickRecordImpl  arg_input;
  fbr >> arg_input;
  QuickRecordImpl  arg_optval;
  fbr >> arg_optval;
  QuickRecordImpl  rval = self->method_with_record (arg_input, arg_optval);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
static Plic::FieldBuffer*
_$caller__MethodTestInterface__method_with_sequence (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  self = connection_id2object<I_MethodTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  QuickSequenceImpl  arg_input;
  fbr >> arg_input;
  QuickSequenceImpl  arg_optval;
  fbr >> arg_optval;
  QuickSequenceImpl  rval = self->method_with_sequence (arg_input, arg_optval);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
static Plic::FieldBuffer*
_$caller__MethodTestInterface__method_with_interface (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  self = connection_id2object<I_MethodTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  I_GrandChild_Interface *arg_input = connection_id2object<I_GrandChild_Interface> (fbr.pop_object());
  I_GrandChild_Interface *arg_optval = connection_id2object<I_GrandChild_Interface> (fbr.pop_object());
  I_GrandChild_Interface *rval = self->method_with_interface (*arg_input, *arg_optval);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_object (connection_object2id (rval));
  return &rb;
}
static Plic::FieldBuffer*
_$caller__MethodTestInterface__method_with_quickiface (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_MethodTestInterface_Interface *self;
  self = connection_id2object<I_MethodTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  I_QuickIface_Interface *arg_input = connection_id2object<I_QuickIface_Interface> (fbr.pop_object());
  I_QuickIface_Interface *arg_iface0 = connection_id2object<I_QuickIface_Interface> (fbr.pop_object());
  I_QuickIface_Interface *rval = self->method_with_quickiface (*arg_input, *arg_iface0);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_object (connection_object2id (rval));
  return &rb;
}

class _$Closure__SignalTestInterface__void_result {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__void_result> SharedPtr;
  _$Closure__SignalTestInterface__void_result (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__void_result()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__void_result (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_void_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__void_result::SharedPtr sp (new _$Closure__SignalTestInterface__void_result (PLIC_CONNECTION(), handler_id));
    cid = self->sig_void_result.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__bool_result {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__bool_result> SharedPtr;
  _$Closure__SignalTestInterface__bool_result (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__bool_result()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static bool
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
    return 0;
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__bool_result (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_bool_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__bool_result::SharedPtr sp (new _$Closure__SignalTestInterface__bool_result (PLIC_CONNECTION(), handler_id));
    cid = self->sig_bool_result.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__int_result {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__int_result> SharedPtr;
  _$Closure__SignalTestInterface__int_result (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__int_result()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static int
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
    return 0;
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__int_result (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_int_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__int_result::SharedPtr sp (new _$Closure__SignalTestInterface__int_result (PLIC_CONNECTION(), handler_id));
    cid = self->sig_int_result.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__float_result {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__float_result> SharedPtr;
  _$Closure__SignalTestInterface__float_result (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__float_result()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static double
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
    return 0;
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__float_result (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_float_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__float_result::SharedPtr sp (new _$Closure__SignalTestInterface__float_result (PLIC_CONNECTION(), handler_id));
    cid = self->sig_float_result.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__string_result {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__string_result> SharedPtr;
  _$Closure__SignalTestInterface__string_result (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__string_result()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static std::string
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
    return "";
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__string_result (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_string_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__string_result::SharedPtr sp (new _$Closure__SignalTestInterface__string_result (PLIC_CONNECTION(), handler_id));
    cid = self->sig_string_result.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__enum_result {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__enum_result> SharedPtr;
  _$Closure__SignalTestInterface__enum_result (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__enum_result()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static QuickEnum
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
    return QuickEnum (0);
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__enum_result (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_enum_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__enum_result::SharedPtr sp (new _$Closure__SignalTestInterface__enum_result (PLIC_CONNECTION(), handler_id));
    cid = self->sig_enum_result.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__record_result {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__record_result> SharedPtr;
  _$Closure__SignalTestInterface__record_result (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__record_result()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static QuickRecordImpl
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
    return QuickRecordImpl();
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__record_result (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_record_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__record_result::SharedPtr sp (new _$Closure__SignalTestInterface__record_result (PLIC_CONNECTION(), handler_id));
    cid = self->sig_record_result.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__sequence_result {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__sequence_result> SharedPtr;
  _$Closure__SignalTestInterface__sequence_result (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__sequence_result()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static QuickSequenceImpl
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
    return QuickSequenceImpl();
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__sequence_result (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_sequence_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__sequence_result::SharedPtr sp (new _$Closure__SignalTestInterface__sequence_result (PLIC_CONNECTION(), handler_id));
    cid = self->sig_sequence_result.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__interface_result {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__interface_result> SharedPtr;
  _$Closure__SignalTestInterface__interface_result (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__interface_result()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static I_GrandChild_Interface*
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
    return 0;
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__interface_result (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_interface_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__interface_result::SharedPtr sp (new _$Closure__SignalTestInterface__interface_result (PLIC_CONNECTION(), handler_id));
    cid = self->sig_interface_result.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__self_result {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__self_result> SharedPtr;
  _$Closure__SignalTestInterface__self_result (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__self_result()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static I_SignalTestInterface_Interface*
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
    return 0;
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__self_result (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_self_result.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__self_result::SharedPtr sp (new _$Closure__SignalTestInterface__self_result (PLIC_CONNECTION(), handler_id));
    cid = self->sig_self_result.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__void_arg {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__void_arg> SharedPtr;
  _$Closure__SignalTestInterface__void_arg (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__void_arg()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__void_arg (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_void_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__void_arg::SharedPtr sp (new _$Closure__SignalTestInterface__void_arg (PLIC_CONNECTION(), handler_id));
    cid = self->sig_void_arg.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__bool_arg {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__bool_arg> SharedPtr;
  _$Closure__SignalTestInterface__bool_arg (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__bool_arg()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (bool arg_b,
           SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    fb.add_int64 (arg_b);
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__bool_arg (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_bool_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__bool_arg::SharedPtr sp (new _$Closure__SignalTestInterface__bool_arg (PLIC_CONNECTION(), handler_id));
    cid = self->sig_bool_arg.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__int_arg {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__int_arg> SharedPtr;
  _$Closure__SignalTestInterface__int_arg (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__int_arg()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (int arg_i,
           SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    fb.add_int64 (arg_i);
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__int_arg (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_int_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__int_arg::SharedPtr sp (new _$Closure__SignalTestInterface__int_arg (PLIC_CONNECTION(), handler_id));
    cid = self->sig_int_arg.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__float_arg {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__float_arg> SharedPtr;
  _$Closure__SignalTestInterface__float_arg (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__float_arg()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (double arg_f,
           SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    fb.add_double (arg_f);
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__float_arg (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_float_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__float_arg::SharedPtr sp (new _$Closure__SignalTestInterface__float_arg (PLIC_CONNECTION(), handler_id));
    cid = self->sig_float_arg.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__string_arg {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__string_arg> SharedPtr;
  _$Closure__SignalTestInterface__string_arg (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__string_arg()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (const std::string &arg_s,
           SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    fb.add_string (arg_s);
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__string_arg (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_string_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__string_arg::SharedPtr sp (new _$Closure__SignalTestInterface__string_arg (PLIC_CONNECTION(), handler_id));
    cid = self->sig_string_arg.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__enum_arg {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__enum_arg> SharedPtr;
  _$Closure__SignalTestInterface__enum_arg (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__enum_arg()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (QuickEnum arg_e,
           SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    fb.add_evalue (arg_e);
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__enum_arg (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_enum_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__enum_arg::SharedPtr sp (new _$Closure__SignalTestInterface__enum_arg (PLIC_CONNECTION(), handler_id));
    cid = self->sig_enum_arg.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__record_arg {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__record_arg> SharedPtr;
  _$Closure__SignalTestInterface__record_arg (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__record_arg()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (const QuickRecordImpl &arg_r,
           SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    fb << arg_r;
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__record_arg (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_record_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__record_arg::SharedPtr sp (new _$Closure__SignalTestInterface__record_arg (PLIC_CONNECTION(), handler_id));
    cid = self->sig_record_arg.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__sequence_arg {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__sequence_arg> SharedPtr;
  _$Closure__SignalTestInterface__sequence_arg (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__sequence_arg()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (const QuickSequenceImpl &arg_s,
           SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    fb << arg_s;
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__sequence_arg (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_sequence_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__sequence_arg::SharedPtr sp (new _$Closure__SignalTestInterface__sequence_arg (PLIC_CONNECTION(), handler_id));
    cid = self->sig_sequence_arg.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__interface_arg {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__interface_arg> SharedPtr;
  _$Closure__SignalTestInterface__interface_arg (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__interface_arg()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (I_GrandChild_Interface &arg_i,
           SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    fb.add_object (connection_object2id (arg_i));
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__interface_arg (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_interface_arg.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__interface_arg::SharedPtr sp (new _$Closure__SignalTestInterface__interface_arg (PLIC_CONNECTION(), handler_id));
    cid = self->sig_interface_arg.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__SignalTestInterface__self_args {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__SignalTestInterface__self_args> SharedPtr;
  _$Closure__SignalTestInterface__self_args (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__SignalTestInterface__self_args()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (I_SignalTestInterface_Interface &arg_self_,
           SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 1);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    fb.add_object (connection_object2id (arg_self_));
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__SignalTestInterface__self_args (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_SignalTestInterface_Interface *self;
  self = connection_id2object<I_SignalTestInterface_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_self_args.disconnect (con_id);
  if (handler_id) {
    _$Closure__SignalTestInterface__self_args::SharedPtr sp (new _$Closure__SignalTestInterface__self_args (PLIC_CONNECTION(), handler_id));
    cid = self->sig_self_args.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}

static Plic::FieldBuffer*
_$getter__PropertyTester__bool_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  bool  rval = self->bool_prop ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$setter__PropertyTester__bool_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  bool  arg_bool_prop = fbr.pop_int64();
  self->bool_prop (arg_bool_prop);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__PropertyTester__int_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  int  rval = self->int_prop ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$setter__PropertyTester__int_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  int  arg_int_prop = fbr.pop_int64();
  self->int_prop (arg_int_prop);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__PropertyTester__float_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  double  rval = self->float_prop ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_double (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$setter__PropertyTester__float_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  double  arg_float_prop = fbr.pop_double();
  self->float_prop (arg_float_prop);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__PropertyTester__string_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  rval = self->string_prop ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_string (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$setter__PropertyTester__string_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  arg_string_prop = fbr.pop_string();
  self->string_prop (arg_string_prop);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__PropertyTester__enum_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  QuickEnum  rval = self->enum_prop ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_evalue (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$setter__PropertyTester__enum_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  QuickEnum  arg_enum_prop = QuickEnum (fbr.pop_evalue());
  self->enum_prop (arg_enum_prop);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__PropertyTester__record_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  QuickRecordImpl  rval = self->record_prop ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
static Plic::FieldBuffer*
_$setter__PropertyTester__record_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  QuickRecordImpl  arg_record_prop;
  fbr >> arg_record_prop;
  self->record_prop (arg_record_prop);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__PropertyTester__sequence_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  QuickSequenceImpl  rval = self->sequence_prop ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb << rval;
  return &rb;
}
static Plic::FieldBuffer*
_$setter__PropertyTester__sequence_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  QuickSequenceImpl  arg_sequence_prop;
  fbr >> arg_sequence_prop;
  self->sequence_prop (arg_sequence_prop);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__PropertyTester__interface_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  I_GrandChild_Interface *rval = self->interface_prop ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_object (connection_object2id (rval));
  return &rb;
}
static Plic::FieldBuffer*
_$setter__PropertyTester__interface_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  I_GrandChild_Interface *arg_interface_prop = connection_id2object<I_GrandChild_Interface> (fbr.pop_object());
  self->interface_prop (&*arg_interface_prop);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__PropertyTester__self_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  I_PropertyTester_Interface *rval = self->self_prop ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_object (connection_object2id (rval));
  return &rb;
}
static Plic::FieldBuffer*
_$setter__PropertyTester__self_prop (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_PropertyTester_Interface *self;
  self = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  I_PropertyTester_Interface *arg_self_prop = connection_id2object<I_PropertyTester_Interface> (fbr.pop_object());
  self->self_prop (&*arg_self_prop);
  return NULL;
}

} // InterfaceTests

namespace RapicornPlicTest {
static Plic::FieldBuffer*
_$getter__ButtonArea__on_click (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  self = connection_id2object<I_ButtonArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_string (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$setter__ButtonArea__on_click (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  self = connection_id2object<I_ButtonArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click = fbr.pop_string();
  self->on_click (arg_on_click);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__ButtonArea__on_click2 (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  self = connection_id2object<I_ButtonArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click2 ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_string (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$setter__ButtonArea__on_click2 (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  self = connection_id2object<I_ButtonArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click2 = fbr.pop_string();
  self->on_click2 (arg_on_click2);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__ButtonArea__on_click3 (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  self = connection_id2object<I_ButtonArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  rval = self->on_click3 ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_string (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$setter__ButtonArea__on_click3 (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  self = connection_id2object<I_ButtonArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  std::string  arg_on_click3 = fbr.pop_string();
  self->on_click3 (arg_on_click3);
  return NULL;
}
static Plic::FieldBuffer*
_$getter__ButtonArea__click_type (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1) return plic$_error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  self = connection_id2object<I_ButtonArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  ClickType  rval = self->click_type ();
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_evalue (rval);
  return &rb;
}
static Plic::FieldBuffer*
_$setter__ButtonArea__click_type (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  self = connection_id2object<I_ButtonArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  ClickType  arg_click_type = ClickType (fbr.pop_evalue());
  self->click_type (arg_click_type);
  return NULL;
}
class _$Closure__ButtonArea__check_activate {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__ButtonArea__check_activate> SharedPtr;
  _$Closure__ButtonArea__check_activate (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__ButtonArea__check_activate()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static bool
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
    return 0;
  }
};
static Plic::FieldBuffer*
_$sigcon__ButtonArea__check_activate (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  self = connection_id2object<I_ButtonArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_check_activate.disconnect (con_id);
  if (handler_id) {
    _$Closure__ButtonArea__check_activate::SharedPtr sp (new _$Closure__ButtonArea__check_activate (PLIC_CONNECTION(), handler_id));
    cid = self->sig_check_activate.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}
class _$Closure__ButtonArea__activate {
  Plic::Connection &m_connection; uint64 m_handler;
public:
  typedef Plic::shared_ptr<_$Closure__ButtonArea__activate> SharedPtr;
  _$Closure__ButtonArea__activate (Plic::Connection &conn, uint64 h) : m_connection (conn), m_handler (h) {}
  ~_$Closure__ButtonArea__activate()
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1);
    fb.add_msgid (Plic::MSGID_DISCON, 0); // FIXME: 0
    fb.add_int64 (m_handler);
    m_connection.send_event (&fb); // deletes fb
  }
  static void
  handler (SharedPtr sp)
  {
    Plic::FieldBuffer &fb = *Plic::FieldBuffer::_new (2 + 1 + 0);
    fb.add_msgid (Plic::MSGID_EVENT, 0); // FIXME: 0
    fb.add_int64 (sp->m_handler);
    sp->m_connection.send_event (&fb); // deletes fb
  }
};
static Plic::FieldBuffer*
_$sigcon__ButtonArea__activate (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 2) return plic$_error ("invalid number of arguments");
  I_ButtonArea_Interface *self;
  self = connection_id2object<I_ButtonArea_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  uint64 cid = 0, handler_id = fbr.pop_int64();
  uint64 con_id = fbr.pop_int64();
  if (con_id) self->sig_activate.disconnect (con_id);
  if (handler_id) {
    _$Closure__ButtonArea__activate::SharedPtr sp (new _$Closure__ButtonArea__activate (PLIC_CONNECTION(), handler_id));
    cid = self->sig_activate.connect (slot (sp->handler, sp)); }
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (cid);
  return &rb;
}

static Plic::FieldBuffer*
_$caller__PureMethods__pure_method (Plic::FieldReader &fbr)
{
  if (fbr.remaining() != 1 + 1) return plic$_error ("invalid number of arguments");
  I_PureMethods_Interface *self;
  self = connection_id2object<I_PureMethods_Interface> (fbr.pop_object());
  PLIC_CHECK (self, "self must be non-NULL");
  double  arg_f = fbr.pop_double();
  int  rval = self->pure_method (arg_f);
  Plic::FieldBuffer &rb = *Plic::FieldBuffer::new_result();
  rb.add_int64 (rval);
  return &rb;
}

static const Plic::Connection::MethodEntry _plic_stub_entries[] = {
  { 0x209463c55becedadULL, 0x39ddfcb9aadc3c74ULL, MandatoryNamespace::_$caller__FirstInterface__void_func, },
  { 0x39146750080bd117ULL, 0x9edc3ab3b5e82e8dULL, InterfaceTests::_$getter__UIWidgetArea__dummy, },
  { 0x2a284d0b5305ac3aULL, 0xd98a1d86235ad649ULL, InterfaceTests::_$setter__UIWidgetArea__dummy, },
  { 0x37b8129e6139dfaeULL, 0xece65fb7aeda0163ULL, InterfaceTests::_$getter__UIWidgetArea__on_click, },
  { 0x2d15d46bb30e2a40ULL, 0xc421a429912efd6dULL, InterfaceTests::_$setter__UIWidgetArea__on_click, },
  { 0x39a122b559d15903ULL, 0x0a95fe35b7a1de33ULL, InterfaceTests::_$caller__UIWidgetArea__simple_method, },
  { 0x3910395d202c93c2ULL, 0x9206a89acaaf2086ULL, InterfaceTests::_$caller__UIWidgetArea__single_arg, },
  { 0x3b5ae84b86dfa59cULL, 0x5d2ef3880b1fa360ULL, InterfaceTests::_$caller__UIWidgetArea__single_arg2, },
  { 0x359c33f1677a63ebULL, 0x3a05748016992575ULL, InterfaceTests::_$caller__UIWidgetArea__two_args, },
  { 0x3291a584ff9121b3ULL, 0xbd14f4bbc47fb2ccULL, InterfaceTests::_$caller__UIWidgetArea__two_args2, },
  { 0x3501ef84b7c1d9ffULL, 0x564566ab8a5e1b8bULL, InterfaceTests::_$caller__UIWidgetArea__multi_args, },
  { 0x316521a2bcc037d0ULL, 0x43987053dab0c3c0ULL, InterfaceTests::_$caller__UIWidgetArea__self_method, },
  { 0x2e02c52c84773703ULL, 0x00027e452edb615cULL, InterfaceTests::_$caller__UIWidgetArea__void_method, },
  { 0x3e4f2ff4e1424783ULL, 0x439ed3d602e3946eULL, InterfaceTests::_$caller__UIWidgetArea__on_click2out, },
  { 0x2294f15cd15e9458ULL, 0x5e0ac9b493bb4f17ULL, InterfaceTests::_$caller__UIWidgetArea__on_click2in, },
  { 0x52ef738c2571d0f2ULL, 0x05b653adf0a80acfULL, InterfaceTests::_$sigcon__UIWidgetArea__void_signal, },
  { 0x511bbb2e2b129d5bULL, 0xe7152819ec289550ULL, InterfaceTests::_$sigcon__UIWidgetArea__sample_signal, },
  { 0x2446078b004b9aabULL, 0x37d6c73a34ac7070ULL, InterfaceTests::_$caller__QuickIface__simple_function, },
  { 0x281392e54343bee9ULL, 0x0dbeb788728dbff4ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_void, },
  { 0x3b68546991e25342ULL, 0xa71399caec9ccfc7ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_bools, },
  { 0x39555e79a31047bfULL, 0x0f06b4f122a81e1dULL, InterfaceTests::_$caller__MethodTestInterface__method_with_ints, },
  { 0x391dd7c671dada38ULL, 0x32ca18bc1bd39689ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_floats, },
  { 0x3ad5eafe588b965aULL, 0x38c04145925d2963ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_string, },
  { 0x387f08a5c150e6a7ULL, 0x83c133fcd2be3200ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_enum, },
  { 0x3b59b493f287edf0ULL, 0x4771d353c78389d1ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_record, },
  { 0x34c9e8a686a7f261ULL, 0x9af099b173ac979cULL, InterfaceTests::_$caller__MethodTestInterface__method_with_sequence, },
  { 0x34619983babcee5bULL, 0x9875f78f28f381b7ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_interface, },
  { 0x3a2ab33a8358edcbULL, 0x7c028db9464052a0ULL, InterfaceTests::_$caller__MethodTestInterface__method_with_quickiface, },
  { 0x535d5e95471873b6ULL, 0x7a9f5692ce00e007ULL, InterfaceTests::_$sigcon__SignalTestInterface__void_result, },
  { 0x51ffffa2f8db1b1bULL, 0x3e01434baf49eceeULL, InterfaceTests::_$sigcon__SignalTestInterface__bool_result, },
  { 0x51ac083cdc878affULL, 0x72ad7414773447a2ULL, InterfaceTests::_$sigcon__SignalTestInterface__int_result, },
  { 0x5cc54429499b42b6ULL, 0x35e1fb7707130bcaULL, InterfaceTests::_$sigcon__SignalTestInterface__float_result, },
  { 0x5790f575b6cac788ULL, 0x27db8e3c014993a7ULL, InterfaceTests::_$sigcon__SignalTestInterface__string_result, },
  { 0x56fc6f3f4946e7b2ULL, 0x0fe0cc5f83d2ab84ULL, InterfaceTests::_$sigcon__SignalTestInterface__enum_result, },
  { 0x50b723665ed298a5ULL, 0x32aa063680a4e3c0ULL, InterfaceTests::_$sigcon__SignalTestInterface__record_result, },
  { 0x5ef00325dfcf4552ULL, 0x991130ecddd21730ULL, InterfaceTests::_$sigcon__SignalTestInterface__sequence_result, },
  { 0x58e8587c542d85ceULL, 0xe2b572e902c69f7cULL, InterfaceTests::_$sigcon__SignalTestInterface__interface_result, },
  { 0x59bb2da621bab28fULL, 0x32bc82e7eb9bc512ULL, InterfaceTests::_$sigcon__SignalTestInterface__self_result, },
  { 0x583dc36c7785c7f3ULL, 0xb330cefa4e8247a9ULL, InterfaceTests::_$sigcon__SignalTestInterface__void_arg, },
  { 0x5f7ba898d12986bfULL, 0x8a1143a5f6dc85b8ULL, InterfaceTests::_$sigcon__SignalTestInterface__bool_arg, },
  { 0x5f91dc79c2bee013ULL, 0x809b90b2fad4ea0aULL, InterfaceTests::_$sigcon__SignalTestInterface__int_arg, },
  { 0x5d5c43cd47b258caULL, 0xb0d5fde097d6d12cULL, InterfaceTests::_$sigcon__SignalTestInterface__float_arg, },
  { 0x53de7a105b57bf62ULL, 0x9d8ffe4942a0934fULL, InterfaceTests::_$sigcon__SignalTestInterface__string_arg, },
  { 0x586138796f133c4dULL, 0x1c7573f2d30ac907ULL, InterfaceTests::_$sigcon__SignalTestInterface__enum_arg, },
  { 0x59cb77461ddeac82ULL, 0xfeaa98721bd8ecd3ULL, InterfaceTests::_$sigcon__SignalTestInterface__record_arg, },
  { 0x547b4dd41606b568ULL, 0x1d763791a33d2bc9ULL, InterfaceTests::_$sigcon__SignalTestInterface__sequence_arg, },
  { 0x57a5dbfbeb5a4ef9ULL, 0xb5df0c3b3bba4b22ULL, InterfaceTests::_$sigcon__SignalTestInterface__interface_arg, },
  { 0x5c515ee37b78a970ULL, 0xe89c2af2f29359a0ULL, InterfaceTests::_$sigcon__SignalTestInterface__self_args, },
  { 0x396c5b1aaf49cec6ULL, 0xb6218ab5ac6b82c3ULL, InterfaceTests::_$getter__PropertyTester__bool_prop, },
  { 0x2bd3c8fc8f71f8b4ULL, 0x2dde5c2c8fcf750cULL, InterfaceTests::_$setter__PropertyTester__bool_prop, },
  { 0x369c402f00bbf1e2ULL, 0x515a4131e4516216ULL, InterfaceTests::_$getter__PropertyTester__int_prop, },
  { 0x2a015ad6b813701dULL, 0x62fa674331e78289ULL, InterfaceTests::_$setter__PropertyTester__int_prop, },
  { 0x3b2c96526265c4baULL, 0xc1f4b15d96504a08ULL, InterfaceTests::_$getter__PropertyTester__float_prop, },
  { 0x25ae78062c0435cdULL, 0x1d21f473f7647360ULL, InterfaceTests::_$setter__PropertyTester__float_prop, },
  { 0x385771786e6432dbULL, 0xcb19bfb3aa9a26feULL, InterfaceTests::_$getter__PropertyTester__string_prop, },
  { 0x206d200c92ba7e41ULL, 0x857975e0304c85f3ULL, InterfaceTests::_$setter__PropertyTester__string_prop, },
  { 0x3d09e074f5d2f8edULL, 0x38e8a275e29c3fc2ULL, InterfaceTests::_$getter__PropertyTester__enum_prop, },
  { 0x2b77a2f3a3c4d5b4ULL, 0x4d5b96d1adf5f7ccULL, InterfaceTests::_$setter__PropertyTester__enum_prop, },
  { 0x31443949c61d0fecULL, 0xeb221638d6ffd3cfULL, InterfaceTests::_$getter__PropertyTester__record_prop, },
  { 0x2a5f5c212625f446ULL, 0x30d24123307269ceULL, InterfaceTests::_$setter__PropertyTester__record_prop, },
  { 0x3f323c929c803ea8ULL, 0x6ebf49e977bfb699ULL, InterfaceTests::_$getter__PropertyTester__sequence_prop, },
  { 0x232174952090a941ULL, 0xae8b7a3e13fdfde7ULL, InterfaceTests::_$setter__PropertyTester__sequence_prop, },
  { 0x33a8b72ea92bb600ULL, 0x3837c1118556aaedULL, InterfaceTests::_$getter__PropertyTester__interface_prop, },
  { 0x29163b10631cf4b4ULL, 0xf014d69b1a1153e9ULL, InterfaceTests::_$setter__PropertyTester__interface_prop, },
  { 0x3e6b07e114fab96bULL, 0x45a97f76ee1a7bcfULL, InterfaceTests::_$getter__PropertyTester__self_prop, },
  { 0x2c1aea6b5567c7beULL, 0x8f21acd05f5030deULL, InterfaceTests::_$setter__PropertyTester__self_prop, },
  { 0x3e3aae70657f83b7ULL, 0x728ed182ccdc4020ULL, RapicornPlicTest::_$getter__ButtonArea__on_click, },
  { 0x2d526a22ceb83792ULL, 0x62169ce8c45be6e0ULL, RapicornPlicTest::_$setter__ButtonArea__on_click, },
  { 0x3c128313732bc9a9ULL, 0xad69a127aa1ce9b0ULL, RapicornPlicTest::_$getter__ButtonArea__on_click2, },
  { 0x23c57c80df9b0efbULL, 0xb8e860a363947d7dULL, RapicornPlicTest::_$setter__ButtonArea__on_click2, },
  { 0x380ad1778851e535ULL, 0x5b045ec25d2deb0eULL, RapicornPlicTest::_$getter__ButtonArea__on_click3, },
  { 0x27d09d1b9508a02bULL, 0x1e072d4d979e4921ULL, RapicornPlicTest::_$setter__ButtonArea__on_click3, },
  { 0x3d39bef0c031e35dULL, 0x7ea1af466f8574b1ULL, RapicornPlicTest::_$getter__ButtonArea__click_type, },
  { 0x27b69c1801d07bbeULL, 0x929dbc4b4f2ea981ULL, RapicornPlicTest::_$setter__ButtonArea__click_type, },
  { 0x5aa49f58f83f54b7ULL, 0xff357b59e593e480ULL, RapicornPlicTest::_$sigcon__ButtonArea__check_activate, },
  { 0x567351a83995c46eULL, 0xcd153a5a755401f6ULL, RapicornPlicTest::_$sigcon__ButtonArea__activate, },
  { 0x3c452a34192441bfULL, 0xcb1002037bf028e2ULL, RapicornPlicTest::_$caller__PureMethods__pure_method, },
};
static Plic::Connection::MethodRegistry _plic_stub_registry (_plic_stub_entries);

} // RapicornPlicTest


/* --- Generated by PLIC-CxxCaller --- */

// --- ServerHH Boilerplate ---
#include <rcore/plicutils.hh>
#include <rcore/rapicornsignal.hh>

// --- ClientCC/ServerCC Boilerplate ---
#include <string>
#include <vector>
#include <stdexcept>
#ifndef __PLIC_GENERIC_CC_BOILERPLATE__
#define __PLIC_GENERIC_CC_BOILERPLATE__

#define THROW_ERROR()   throw std::runtime_error ("PLIC: Marshalling failed")
#define PLIC_CHECK(cond,errmsg) do { if (cond) break; throw std::runtime_error (std::string ("PLIC-ERROR: ") + errmsg); } while (0)

namespace { // Anonymous
using Plic::uint64;
typedef Plic::Coupler Coupler;
typedef Plic::FieldBuffer FieldBuffer;
typedef Plic::FieldBuffer8 FieldBuffer8;
typedef Plic::FieldBufferReader FieldBufferReader;

#ifndef PLIC_COUPLER
#define PLIC_COUPLER()  _plic_coupler_static
static struct _DummyCoupler : public Coupler {
  virtual FieldBuffer* call_remote (FieldBuffer *fbcall)
  {
    bool twoway = Plic::is_callid_twoway (fbcall->first_id());
    if (send_call (fbcall)) // deletes fbcall
      ; // threaded dispatcher needs CPU
    // wakeup dispatcher
    while (check_dispatch())
      dispatch();
    return !twoway ? NULL : receive_result();
  }
} _plic_coupler_static;
#endif

} // Anonymous
#endif // __PLIC_GENERIC_CC_BOILERPLATE__


// --- Interfaces (class declarations) ---

namespace MandatoryNamespace {
enum Empty {
};
enum Enum1 {
  E1_A = 1,
};
enum Enum1c {
  E1C_A = 1,
};
enum Enum2 {
  E2_A = 1,
  E2_B = 2,
};
enum Enum2c {
  E2C_A = 1,
  E2C_B = 2,
};
enum Enum3 {
  E3_A = 1,
  E3_B = 2,
  E3_C = 3,
};
enum Enum3c {
  E3C_A = 1,
  E3C_B = 2,
  E3C_C = 3,
};
enum Enum4a {
  E4A_A = 1,
  E4A_B = 2,
  E4A_C = 3,
  E4A_D = 4,
};
enum Enum4b {
  E4B_A = 1,
  E4B_B = 2,
  E4B_C = 3,
  E4B_D = 4,
};
enum Enum4c {
  E4C_A = 1,
  E4C_B = 2,
  E4C_C = 3,
  E4C_D = 4,
};
enum Enum4d {
  E4D_A = 1,
  E4D_B = 2,
  E4D_C = 3,
  E4D_D = 4,
};
enum ExtensiveEnum {
  V1a = 1,
  V1b = 1,
  V2 = 2,
  V3 = 3,
  V4 = 4,
  V5 = 5, // "V5"
  V6 = 6, // "V6"
  V7 = 7, // _("V7")
  V8 = 8, // _("V8")
  V9 = 9,
  V10 = 10,
  V11 = 11,
  V12 = 12,
  V13 = 13,
  V14 = 14,
  V15 = 15, // "V15"
  V16 = 16, // "V16"
  V17 = 17, // _("V17")
  V18 = 18, // _("V18")
  V20 = 20,
  V21 = 21,
  V22 = 22,
  V23 = 23,
  V24 = 24,
  V25 = -16,
  V26 = 16,
  V27 = -16,
  V28 = -28,
  V30 = 42,
  V31 = 43,
  V32 = 42,
  V33 = 43,
  V34 = 44, // "foo"
  V35 = 42,
  V36 = 42, // "foo""4"
};

class FirstInterface_Iface : public virtual Plic::SimpleServer {
protected:
  virtual /*Des*/         ~FirstInterface_Iface () = 0;
public:
  virtual void            void_func ();
};
class FirstInterface : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline FirstInterface () {}
  inline FirstInterface (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline FirstInterface (FirstInterface_Iface *iface) { _iface (iface); }
  inline FirstInterface (FirstInterface_Iface &iface) { _iface (&iface); }
  // void            void_func ();
  inline FirstInterface_Iface& operator*  () const { return *dynamic_cast<FirstInterface_Iface*> (_iface()); }
  inline FirstInterface_Iface* operator-> () const { return dynamic_cast<FirstInterface_Iface*> (_iface()); }
  inline operator  FirstInterface_Iface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
struct XFooRecord {
  bool            single_bool;
  int             single_num;
  double          single_float;
  std::string     single_string;
  int             sibling1;
  int             sibling2;
  int             multi1;
  int             multi2;
  int             multi3;
  int             multi4;
  ExtensiveEnum   enum_field;
  FirstInterface  iface1;
  FirstInterface  iface2;
  FirstInterface  iface3;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline XFooRecord () { single_bool = 0; single_num = 0; single_float = 0; sibling1 = 0; sibling2 = 0; multi1 = 0; multi2 = 0; multi3 = 0; multi4 = 0; enum_field = ExtensiveEnum (0); }
};
struct XFooSequence {
  std::vector<bool> single_bool;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct IntSequence {
  std::vector<int> numx;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct FloatSequence {
  std::vector<double> fractalvalue;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct StringSequence {
  std::vector<std::string> blurb;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct ExtensiveEnumSequence {
  std::vector<ExtensiveEnum> enum_elements;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct RecordSequence {
  std::vector<XFooRecord> repeatedfield;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct SequenceSequence {
  std::vector<IntSequence> moreints;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct InterfaceSequence {
  std::vector<FirstInterface> iface1;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
struct NestedTypesRec {
  XFooRecord      rec;
  XFooSequence    seq;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline NestedTypesRec () { }
};
struct NestedTypesSeq {
  std::vector<NestedTypesRec> ntr;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};
typedef int AliasInt;
typedef double AliasFloat;
typedef bool AliasBool;
typedef std::string AliasString;
typedef XFooRecord AliasRecord;
typedef XFooSequence AliasSequence;
typedef ExtensiveEnum AliasEnum;
struct NewRecord {
  int             i;
  Enum1           enum1;
  XFooSequence    xfs;
  NestedTypesRec  ntr;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline NewRecord () { i = 0; enum1 = Enum1 (0); }
};

namespace Inner {
struct InnerRecord {
  int             x;
  int             y;
  NewRecord       rec;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline InnerRecord () { x = 0; y = 0; }
};
} // Inner
struct Refer2Inner {
  Inner::InnerRecord r;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline Refer2Inner () { }
};
} // MandatoryNamespace

namespace OtherNamespace {
struct SomeRecord {
  MandatoryNamespace::NewRecord r1;
  MandatoryNamespace::NewRecord r2;
  MandatoryNamespace::Inner::InnerRecord r3;
  MandatoryNamespace::Inner::InnerRecord r4;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline SomeRecord () { }
};
} // OtherNamespace

namespace Auxdata {
typedef int bar;
typedef double x;
typedef std::string s;
} // Auxdata

namespace InterfaceTests {

class UIWidgetArea_Iface : public virtual Plic::SimpleServer {
protected:
  virtual /*Des*/         ~UIWidgetArea_Iface () = 0;
public:
  typedef Rapicorn::Signals::Signal<UIWidgetArea_Iface, void ()> Signal_void_signal;
  typedef Rapicorn::Signals::Signal<UIWidgetArea_Iface, double (UIWidgetArea_Iface &ba1, int someint)> Signal_sample_signal;
  // Signal_void_signal sig_void_signal;
  // Signal_sample_signal sig_sample_signal;
  virtual double          simple_method ();
  virtual double          single_arg    (int n);
  virtual double          single_arg2   (int n = 5);
  virtual double          two_args      (int n,
                                         double r);
  virtual double          two_args2     (int n = 6,
                                         double r = 7.7);
  virtual double          multi_args    (int n,
                                         double r,
                                         int i,
                                         const std::string &s = "String ding",
                                         double y = 5);
  virtual double          self_method   (UIWidgetArea_Iface &ba1,
                                         UIWidgetArea_Iface &ba2);
  virtual void            void_method   ();
  virtual std::string     on_click2out  ();
  virtual void            on_click2in   (const std::string &command);
};
class UIWidgetArea : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline UIWidgetArea () {}
  inline UIWidgetArea (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline UIWidgetArea (UIWidgetArea_Iface *iface) { _iface (iface); }
  inline UIWidgetArea (UIWidgetArea_Iface &iface) { _iface (&iface); }
  // double          simple_method ();
  // double          single_arg    (int);
  // double          single_arg2   (int);
  // double          two_args      (int, double);
  // double          two_args2     (int, double);
  // double          multi_args    (int, double, int, const std::string&, double);
  // double          self_method   (UIWidgetArea&, UIWidgetArea&);
  // void            void_method   ();
  // std::string     on_click2out  ();
  // void            on_click2in   (const std::string&);
  inline UIWidgetArea_Iface& operator*  () const { return *dynamic_cast<UIWidgetArea_Iface*> (_iface()); }
  inline UIWidgetArea_Iface* operator-> () const { return dynamic_cast<UIWidgetArea_Iface*> (_iface()); }
  inline operator  UIWidgetArea_Iface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class Parent_Iface : public virtual Plic::SimpleServer {
protected:
  virtual /*Des*/         ~Parent_Iface () = 0;
public:
};
class Parent : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline Parent () {}
  inline Parent (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline Parent (Parent_Iface *iface) { _iface (iface); }
  inline Parent (Parent_Iface &iface) { _iface (&iface); }
  inline Parent_Iface& operator*  () const { return *dynamic_cast<Parent_Iface*> (_iface()); }
  inline Parent_Iface* operator-> () const { return dynamic_cast<Parent_Iface*> (_iface()); }
  inline operator  Parent_Iface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class Child_Iface : public virtual Parent_Iface {
protected:
  virtual /*Des*/         ~Child_Iface () = 0;
public:
};
class Child : public Parent {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline Child () {}
  inline Child (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline Child (Child_Iface *iface) { _iface (iface); }
  inline Child (Child_Iface &iface) { _iface (&iface); }
  inline Child_Iface& operator*  () const { return *dynamic_cast<Child_Iface*> (_iface()); }
  inline Child_Iface* operator-> () const { return dynamic_cast<Child_Iface*> (_iface()); }
  inline operator  Child_Iface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class Descendant_Iface : public virtual Child_Iface {
protected:
  virtual /*Des*/         ~Descendant_Iface () = 0;
public:
};
class Descendant : public Child {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline Descendant () {}
  inline Descendant (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline Descendant (Descendant_Iface *iface) { _iface (iface); }
  inline Descendant (Descendant_Iface &iface) { _iface (&iface); }
  inline Descendant_Iface& operator*  () const { return *dynamic_cast<Descendant_Iface*> (_iface()); }
  inline Descendant_Iface* operator-> () const { return dynamic_cast<Descendant_Iface*> (_iface()); }
  inline operator  Descendant_Iface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class GrandChild_Iface : public virtual Descendant_Iface {
protected:
  virtual /*Des*/         ~GrandChild_Iface () = 0;
public:
};
class GrandChild : public Descendant {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline GrandChild () {}
  inline GrandChild (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline GrandChild (GrandChild_Iface *iface) { _iface (iface); }
  inline GrandChild (GrandChild_Iface &iface) { _iface (&iface); }
  inline GrandChild_Iface& operator*  () const { return *dynamic_cast<GrandChild_Iface*> (_iface()); }
  inline GrandChild_Iface* operator-> () const { return dynamic_cast<GrandChild_Iface*> (_iface()); }
  inline operator  GrandChild_Iface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
enum QuickEnum {
  ZERO = 0,
};
struct QuickRecord {
  int             int1;
  int             int2;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
  inline QuickRecord () { int1 = 0; int2 = 0; }
};
struct QuickSequence {
  std::vector<double> somefloat;
  bool proto_add  (Plic::Coupler&, Plic::FieldBuffer&) const;
  bool proto_pop  (Plic::Coupler&, Plic::FieldBufferReader&);
};

class QuickIface_Iface : public virtual Plic::SimpleServer {
protected:
  virtual /*Des*/         ~QuickIface_Iface () = 0;
public:
  virtual void            simple_function (int i = 9);
};
class QuickIface : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline QuickIface () {}
  inline QuickIface (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline QuickIface (QuickIface_Iface *iface) { _iface (iface); }
  inline QuickIface (QuickIface_Iface &iface) { _iface (&iface); }
  // void            simple_function (int);
  inline QuickIface_Iface& operator*  () const { return *dynamic_cast<QuickIface_Iface*> (_iface()); }
  inline QuickIface_Iface* operator-> () const { return dynamic_cast<QuickIface_Iface*> (_iface()); }
  inline operator  QuickIface_Iface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class MethodTestInterface_Iface : public virtual Plic::SimpleServer {
protected:
  virtual /*Des*/         ~MethodTestInterface_Iface () = 0;
public:
  virtual void            method_with_void       ();
  virtual bool            method_with_bools      (bool input,
                                                  bool optval = 0);
  virtual int             method_with_ints       (int input,
                                                  int optval = -2);
  virtual double          method_with_floats     (double input,
                                                  double optval = 309.9);
  virtual std::string     method_with_string     (const std::string &input,
                                                  const std::string &optval = "default");
  virtual QuickEnum       method_with_enum       (QuickEnum input,
                                                  QuickEnum optval = QuickEnum (0));
  virtual QuickRecord     method_with_record     (const QuickRecord &input,
                                                  const QuickRecord &optval = QuickRecord());
  virtual QuickSequence   method_with_sequence   (const QuickSequence &input,
                                                  const QuickSequence &optval = QuickSequence());
  virtual GrandChild_Iface* method_with_interface  (GrandChild_Iface &input,
                                                    GrandChild_Iface &optval = *(GrandChild_Iface*) NULL);
  virtual QuickIface_Iface* method_with_quickiface (QuickIface_Iface &input,
                                                    QuickIface_Iface &iface0 = *(QuickIface_Iface*) NULL);
};
class MethodTestInterface : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline MethodTestInterface () {}
  inline MethodTestInterface (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline MethodTestInterface (MethodTestInterface_Iface *iface) { _iface (iface); }
  inline MethodTestInterface (MethodTestInterface_Iface &iface) { _iface (&iface); }
  // void            method_with_void       ();
  // bool            method_with_bools      (bool, bool);
  // int             method_with_ints       (int, int);
  // double          method_with_floats     (double, double);
  // std::string     method_with_string     (const std::string&, const std::string&);
  // QuickEnum       method_with_enum       (QuickEnum, QuickEnum);
  // QuickRecord     method_with_record     (const QuickRecord&, const QuickRecord&);
  // QuickSequence   method_with_sequence   (const QuickSequence&, const QuickSequence&);
  // GrandChild      method_with_interface  (GrandChild&, GrandChild&);
  // QuickIface      method_with_quickiface (QuickIface&, QuickIface&);
  inline MethodTestInterface_Iface& operator*  () const { return *dynamic_cast<MethodTestInterface_Iface*> (_iface()); }
  inline MethodTestInterface_Iface* operator-> () const { return dynamic_cast<MethodTestInterface_Iface*> (_iface()); }
  inline operator  MethodTestInterface_Iface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
} // InterfaceTests

namespace RapicornPlicTest {
enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE = 2,
  CLICK_SLOW_REPEAT = 3,
  CLICK_FAST_REPEAT = 4,
  CLICK_KEY_REPEAT = 5,
};

class ButtonArea_Iface : public virtual Plic::SimpleServer {
protected:
  virtual /*Des*/         ~ButtonArea_Iface () = 0;
public:
  typedef Rapicorn::Signals::Signal<ButtonArea_Iface, bool (), Rapicorn::Signals::CollectorUntil0<bool> > Signal_check_activate;
  typedef Rapicorn::Signals::Signal<ButtonArea_Iface, void ()> Signal_activate;
  // Signal_check_activate sig_check_activate;
  // Signal_activate sig_activate;
};
class ButtonArea : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline ButtonArea () {}
  inline ButtonArea (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline ButtonArea (ButtonArea_Iface *iface) { _iface (iface); }
  inline ButtonArea (ButtonArea_Iface &iface) { _iface (&iface); }
  inline ButtonArea_Iface& operator*  () const { return *dynamic_cast<ButtonArea_Iface*> (_iface()); }
  inline ButtonArea_Iface* operator-> () const { return dynamic_cast<ButtonArea_Iface*> (_iface()); }
  inline operator  ButtonArea_Iface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};

class PureMethods_Iface : public virtual Plic::SimpleServer {
protected:
  virtual /*Des*/         ~PureMethods_Iface () = 0;
public:
  virtual int             pure_method (double f) = 0;
};
class PureMethods : public virtual Plic::SmartHandle {
protected:
  inline Plic::SimpleServer* _iface() const { return (Plic::SimpleServer*) _void_iface(); }
  inline void _iface (Plic::SimpleServer *_iface) { _void_iface (_iface); }
public:
  inline PureMethods () {}
  inline PureMethods (Plic::Coupler &cpl, Plic::FieldBufferReader &fbr) { _pop_rpc (cpl, fbr); }
  inline PureMethods (PureMethods_Iface *iface) { _iface (iface); }
  inline PureMethods (PureMethods_Iface &iface) { _iface (&iface); }
  // int             pure_method (double);
  inline PureMethods_Iface& operator*  () const { return *dynamic_cast<PureMethods_Iface*> (_iface()); }
  inline PureMethods_Iface* operator-> () const { return dynamic_cast<PureMethods_Iface*> (_iface()); }
  inline operator  PureMethods_Iface&  () const { return operator*(); }
  inline operator _unspecified_bool_type () const { return _is_null() ? NULL : _unspecified_bool_true(); }
};
} // RapicornPlicTest

// --- Implementations ---

namespace MandatoryNamespace {
FirstInterface_Iface::~FirstInterface_Iface () {}

bool
XFooRecord::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (14);
  fb.add_int64 (this->single_bool);
  fb.add_int64 (this->single_num);
  fb.add_double (this->single_float);
  fb.add_string (this->single_string);
  fb.add_int64 (this->sibling1);
  fb.add_int64 (this->sibling2);
  fb.add_int64 (this->multi1);
  fb.add_int64 (this->multi2);
  fb.add_int64 (this->multi3);
  fb.add_int64 (this->multi4);
  fb.add_evalue (this->enum_field);
  fb.add_object (FirstInterface (this->iface1)._rpc_id());
  fb.add_object (FirstInterface (this->iface2)._rpc_id());
  fb.add_object (FirstInterface (this->iface3)._rpc_id());
  return true;
}
bool
XFooRecord::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 14) return false;
  this->single_bool = fbr.pop_int64();
  this->single_num = fbr.pop_int64();
  this->single_float = fbr.pop_double();
  this->single_string = fbr.pop_string();
  this->sibling1 = fbr.pop_int64();
  this->sibling2 = fbr.pop_int64();
  this->multi1 = fbr.pop_int64();
  this->multi2 = fbr.pop_int64();
  this->multi3 = fbr.pop_int64();
  this->multi4 = fbr.pop_int64();
  this->enum_field = ExtensiveEnum (fbr.pop_evalue());
  this->iface1 = FirstInterface (cpl, fbr);
  this->iface2 = FirstInterface (cpl, fbr);
  this->iface3 = FirstInterface (cpl, fbr);
  return true;
}

bool
XFooSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = single_bool.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_int64 (this->single_bool[k]);
  }
  return true;
}
bool
XFooSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->single_bool.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->single_bool.push_back (fbr.pop_int64());
  }
  return true;
}

bool
IntSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = numx.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_int64 (this->numx[k]);
  }
  return true;
}
bool
IntSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->numx.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->numx.push_back (fbr.pop_int64());
  }
  return true;
}

bool
FloatSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = fractalvalue.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_double (this->fractalvalue[k]);
  }
  return true;
}
bool
FloatSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->fractalvalue.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->fractalvalue.push_back (fbr.pop_double());
  }
  return true;
}

bool
StringSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = blurb.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_string (this->blurb[k]);
  }
  return true;
}
bool
StringSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->blurb.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->blurb.push_back (fbr.pop_string());
  }
  return true;
}

bool
ExtensiveEnumSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = enum_elements.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_evalue (this->enum_elements[k]);
  }
  return true;
}
bool
ExtensiveEnumSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->enum_elements.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->enum_elements.push_back (ExtensiveEnum (fbr.pop_evalue()));
  }
  return true;
}

bool
RecordSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = repeatedfield.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->repeatedfield[k].proto_add (cpl, fb)) return false;
  }
  return true;
}
bool
RecordSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->repeatedfield.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->repeatedfield[k].proto_pop (cpl, fbr)) return false;
  }
  return true;
}

bool
SequenceSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = moreints.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->moreints[k].proto_add (cpl, fb)) return false;
  }
  return true;
}
bool
SequenceSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->moreints.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->moreints[k].proto_pop (cpl, fbr)) return false;
  }
  return true;
}

bool
InterfaceSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = iface1.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_object (FirstInterface (this->iface1[k])._rpc_id());
  }
  return true;
}
bool
InterfaceSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->iface1.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->iface1.push_back (FirstInterface (cpl, fbr));
  }
  return true;
}

bool
NestedTypesRec::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  if (!this->rec.proto_add (cpl, fb)) return false;
  if (!this->seq.proto_add (cpl, fb)) return false;
  return true;
}
bool
NestedTypesRec::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 2) return false;
  if (!this->rec.proto_pop (cpl, fbr)) return false;
  if (!this->seq.proto_pop (cpl, fbr)) return false;
  return true;
}

bool
NestedTypesSeq::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = ntr.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->ntr[k].proto_add (cpl, fb)) return false;
  }
  return true;
}
bool
NestedTypesSeq::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->ntr.resize (len);
  for (size_t k = 0; k < len; k++) {
    if (!this->ntr[k].proto_pop (cpl, fbr)) return false;
  }
  return true;
}

bool
NewRecord::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  fb.add_int64 (this->i);
  fb.add_evalue (this->enum1);
  if (!this->xfs.proto_add (cpl, fb)) return false;
  if (!this->ntr.proto_add (cpl, fb)) return false;
  return true;
}
bool
NewRecord::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 4) return false;
  this->i = fbr.pop_int64();
  this->enum1 = Enum1 (fbr.pop_evalue());
  if (!this->xfs.proto_pop (cpl, fbr)) return false;
  if (!this->ntr.proto_pop (cpl, fbr)) return false;
  return true;
}


namespace Inner {
bool
InnerRecord::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (3);
  fb.add_int64 (this->x);
  fb.add_int64 (this->y);
  if (!this->rec.proto_add (cpl, fb)) return false;
  return true;
}
bool
InnerRecord::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 3) return false;
  this->x = fbr.pop_int64();
  this->y = fbr.pop_int64();
  if (!this->rec.proto_pop (cpl, fbr)) return false;
  return true;
}

} // Inner
bool
Refer2Inner::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (1);
  if (!this->r.proto_add (cpl, fb)) return false;
  return true;
}
bool
Refer2Inner::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 1) return false;
  if (!this->r.proto_pop (cpl, fbr)) return false;
  return true;
}

} // MandatoryNamespace

namespace OtherNamespace {
bool
SomeRecord::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (4);
  if (!this->r1.proto_add (cpl, fb)) return false;
  if (!this->r2.proto_add (cpl, fb)) return false;
  if (!this->r3.proto_add (cpl, fb)) return false;
  if (!this->r4.proto_add (cpl, fb)) return false;
  return true;
}
bool
SomeRecord::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 4) return false;
  if (!this->r1.proto_pop (cpl, fbr)) return false;
  if (!this->r2.proto_pop (cpl, fbr)) return false;
  if (!this->r3.proto_pop (cpl, fbr)) return false;
  if (!this->r4.proto_pop (cpl, fbr)) return false;
  return true;
}

} // OtherNamespace

namespace InterfaceTests {
UIWidgetArea_Iface::~UIWidgetArea_Iface () {}

Parent_Iface::~Parent_Iface () {}

Child_Iface::~Child_Iface () {}

Descendant_Iface::~Descendant_Iface () {}

GrandChild_Iface::~GrandChild_Iface () {}

bool
QuickRecord::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  Plic::FieldBuffer &fb = dst.add_rec (2);
  fb.add_int64 (this->int1);
  fb.add_int64 (this->int2);
  return true;
}
bool
QuickRecord::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_rec());
  if (fbr.remaining() != 2) return false;
  this->int1 = fbr.pop_int64();
  this->int2 = fbr.pop_int64();
  return true;
}

bool
QuickSequence::proto_add (Plic::Coupler &cpl, Plic::FieldBuffer &dst) const
{
  const size_t len = somefloat.size();
  Plic::FieldBuffer &fb = dst.add_seq (len);
  for (size_t k = 0; k < len; k++) {
    fb.add_double (this->somefloat[k]);
  }
  return true;
}
bool
QuickSequence::proto_pop (Plic::Coupler &cpl, Plic::FieldBufferReader &src)
{
  Plic::FieldBufferReader fbr (src.pop_seq());
  const size_t len = fbr.remaining();
  this->somefloat.reserve (len);
  for (size_t k = 0; k < len; k++) {
    this->somefloat.push_back (fbr.pop_double());
  }
  return true;
}

QuickIface_Iface::~QuickIface_Iface () {}

MethodTestInterface_Iface::~MethodTestInterface_Iface () {}

} // InterfaceTests

namespace RapicornPlicTest {
ButtonArea_Iface::~ButtonArea_Iface () {}

PureMethods_Iface::~PureMethods_Iface () {}


// --- Method Dispatchers & Registry ---
} // RapicornPlicTest

namespace MandatoryNamespace {
static FieldBuffer*
_dispatch__FirstInterface_void_func (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 0) return false;
  FirstInterface_Iface *self;
  self = FirstInterface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  self->void_func ();
  return NULL;
}


namespace Inner {
} // Inner
} // MandatoryNamespace

namespace OtherNamespace {
} // OtherNamespace

namespace InterfaceTests {
static FieldBuffer*
_dispatch__UIWidgetArea_simple_method (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 0) return false;
  UIWidgetArea_Iface *self;
  self = UIWidgetArea (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  double rval = self->simple_method ();
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_single_arg (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 1) return false;
  UIWidgetArea_Iface *self;
  self = UIWidgetArea (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double rval = self->single_arg (arg_n);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_single_arg2 (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 1) return false;
  UIWidgetArea_Iface *self;
  self = UIWidgetArea (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double rval = self->single_arg2 (arg_n);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_two_args (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  UIWidgetArea_Iface *self;
  self = UIWidgetArea (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double arg_r = fbr.pop_double();
  double rval = self->two_args (arg_n, arg_r);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_two_args2 (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  UIWidgetArea_Iface *self;
  self = UIWidgetArea (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double arg_r = fbr.pop_double();
  double rval = self->two_args2 (arg_n, arg_r);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_multi_args (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 5) return false;
  UIWidgetArea_Iface *self;
  self = UIWidgetArea (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_n = fbr.pop_int64();
  double arg_r = fbr.pop_double();
  int arg_i = fbr.pop_int64();
  std::string arg_s = fbr.pop_string();
  double arg_y = fbr.pop_double();
  double rval = self->multi_args (arg_n, arg_r, arg_i, arg_s, arg_y);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_self_method (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  UIWidgetArea_Iface *self;
  self = UIWidgetArea (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  UIWidgetArea_Iface *arg_ba1 = UIWidgetArea (cpl, fbr).operator->();
  UIWidgetArea_Iface *arg_ba2 = UIWidgetArea (cpl, fbr).operator->();
  double rval = self->self_method (*arg_ba1, *arg_ba2);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_void_method (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 0) return false;
  UIWidgetArea_Iface *self;
  self = UIWidgetArea (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  self->void_method ();
  return NULL;
}
static FieldBuffer*
_dispatch__UIWidgetArea_on_click2out (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 0) return false;
  UIWidgetArea_Iface *self;
  self = UIWidgetArea (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  std::string rval = self->on_click2out ();
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_string (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__UIWidgetArea_on_click2in (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 1) return false;
  UIWidgetArea_Iface *self;
  self = UIWidgetArea (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  std::string arg_command = fbr.pop_string();
  self->on_click2in (arg_command);
  return NULL;
}





static FieldBuffer*
_dispatch__QuickIface_simple_function (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 1) return false;
  QuickIface_Iface *self;
  self = QuickIface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_i = fbr.pop_int64();
  self->simple_function (arg_i);
  return NULL;
}

static FieldBuffer*
_dispatch__MethodTestInterface_method_with_void (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 0) return false;
  MethodTestInterface_Iface *self;
  self = MethodTestInterface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  self->method_with_void ();
  return NULL;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_bools (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface_Iface *self;
  self = MethodTestInterface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  bool arg_input = fbr.pop_int64();
  bool arg_optval = fbr.pop_int64();
  bool rval = self->method_with_bools (arg_input, arg_optval);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_int64 (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_ints (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface_Iface *self;
  self = MethodTestInterface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  int arg_input = fbr.pop_int64();
  int arg_optval = fbr.pop_int64();
  int rval = self->method_with_ints (arg_input, arg_optval);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_int64 (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_floats (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface_Iface *self;
  self = MethodTestInterface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  double arg_input = fbr.pop_double();
  double arg_optval = fbr.pop_double();
  double rval = self->method_with_floats (arg_input, arg_optval);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_double (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_string (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface_Iface *self;
  self = MethodTestInterface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  std::string arg_input = fbr.pop_string();
  std::string arg_optval = fbr.pop_string();
  std::string rval = self->method_with_string (arg_input, arg_optval);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_string (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_enum (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface_Iface *self;
  self = MethodTestInterface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  QuickEnum arg_input = QuickEnum (fbr.pop_evalue());
  QuickEnum arg_optval = QuickEnum (fbr.pop_evalue());
  QuickEnum rval = self->method_with_enum (arg_input, arg_optval);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_evalue (rval);
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_record (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface_Iface *self;
  self = MethodTestInterface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  QuickRecord arg_input;
  if (!arg_input.proto_pop (cpl, fbr)) return false;
  QuickRecord arg_optval;
  if (!arg_optval.proto_pop (cpl, fbr)) return false;
  QuickRecord rval = self->method_with_record (arg_input, arg_optval);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  if (!rval.proto_add (cpl, rb)) return false;
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_sequence (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface_Iface *self;
  self = MethodTestInterface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  QuickSequence arg_input;
  if (!arg_input.proto_pop (cpl, fbr)) return false;
  QuickSequence arg_optval;
  if (!arg_optval.proto_pop (cpl, fbr)) return false;
  QuickSequence rval = self->method_with_sequence (arg_input, arg_optval);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  if (!rval.proto_add (cpl, rb)) return false;
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_interface (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface_Iface *self;
  self = MethodTestInterface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  GrandChild_Iface *arg_input = GrandChild (cpl, fbr).operator->();
  GrandChild_Iface *arg_optval = GrandChild (cpl, fbr).operator->();
  GrandChild_Iface *rval = self->method_with_interface (*arg_input, *arg_optval);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_object (GrandChild (rval)._rpc_id());
  return &rb;
}
static FieldBuffer*
_dispatch__MethodTestInterface_method_with_quickiface (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 2) return false;
  MethodTestInterface_Iface *self;
  self = MethodTestInterface (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  QuickIface_Iface *arg_input = QuickIface (cpl, fbr).operator->();
  QuickIface_Iface *arg_iface0 = QuickIface (cpl, fbr).operator->();
  QuickIface_Iface *rval = self->method_with_quickiface (*arg_input, *arg_iface0);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_object (QuickIface (rval)._rpc_id());
  return &rb;
}

} // InterfaceTests

namespace RapicornPlicTest {

static FieldBuffer*
_dispatch__PureMethods_pure_method (Coupler &cpl)
{
  Plic::FieldBufferReader &fbr = cpl.reader;
  fbr.skip4(); // TypeHash
  if (fbr.remaining() != 1 + 1) return false;
  PureMethods_Iface *self;
  self = PureMethods (cpl, fbr).operator->();
  PLIC_CHECK (self, "self must be non-NULL");
  double arg_f = fbr.pop_double();
  int rval = self->pure_method (arg_f);
  FieldBuffer &rb  = *FieldBuffer::new_return();
  rb.add_int64 (rval);
  return &rb;
}

static const Plic::DispatcherEntry _dispatcher_entries[] = {
  { { 0x0ca10000511e8482ULL, 0xd7fca76824ef1339ULL, 0x9c10110ffb6e89b8ULL, 0x7aee6371c6eb9333ULL }, MandatoryNamespace::_dispatch__FirstInterface_void_func, },
  { { 0x0ca200003a5e02edULL, 0x169b0d3b86dc10cdULL, 0xc07a85a6dfe104adULL, 0xe8554a515ffc84b1ULL }, InterfaceTests::_dispatch__UIWidgetArea_simple_method, },
  { { 0x0ca20000f96d1b2eULL, 0x54efdddfc11d9638ULL, 0xb5d0abcc8a0f16c8ULL, 0x957078d12b4b2fc0ULL }, InterfaceTests::_dispatch__UIWidgetArea_single_arg, },
  { { 0x0ca20000afefb8c4ULL, 0xb9d9952905d41bfdULL, 0xa2c44e813b1a8c4dULL, 0x8e440d5ecaeecec8ULL }, InterfaceTests::_dispatch__UIWidgetArea_single_arg2, },
  { { 0x0ca20000d1f5823fULL, 0x8538f2ffa1581dd0ULL, 0xc9e7d9d486336a46ULL, 0xc941f5292b4dcdfcULL }, InterfaceTests::_dispatch__UIWidgetArea_two_args, },
  { { 0x0ca20000255fafa4ULL, 0x429116798ce5813eULL, 0x5eacea949f7cfe8eULL, 0x1f41fe0ca4311729ULL }, InterfaceTests::_dispatch__UIWidgetArea_two_args2, },
  { { 0x0ca200005e6e8ea5ULL, 0x6f4fdd2d1d4b3bb3ULL, 0xbe7de84f81bcc353ULL, 0x91710698705b209aULL }, InterfaceTests::_dispatch__UIWidgetArea_multi_args, },
  { { 0x0ca20000abd1f74aULL, 0x3f2d1aefb6d12a66ULL, 0x100e83849c144758ULL, 0x79488ee1596dab87ULL }, InterfaceTests::_dispatch__UIWidgetArea_self_method, },
  { { 0x0ca1000027be4746ULL, 0xde7d9d84a2281ae4ULL, 0xdccb312da0062c83ULL, 0x62d76268f178e709ULL }, InterfaceTests::_dispatch__UIWidgetArea_void_method, },
  { { 0x0ca20000a3ce0a03ULL, 0xaaaf9478a83b0f7cULL, 0x2664b179bda29105ULL, 0xb1f6ad88c5a0c98aULL }, InterfaceTests::_dispatch__UIWidgetArea_on_click2out, },
  { { 0x0ca10000e511187cULL, 0x9ea59f646fca1b62ULL, 0x6180b0bf59637495ULL, 0xa99463469b646df9ULL }, InterfaceTests::_dispatch__UIWidgetArea_on_click2in, },
  { { 0x0ca100007178342eULL, 0x2c84375ab4c874afULL, 0xb5578ad147fe3033ULL, 0x392cdc1a7eebbb31ULL }, InterfaceTests::_dispatch__QuickIface_simple_function, },
  { { 0x0ca10000f91c872eULL, 0xa90ceaec3b16df51ULL, 0x887b366247a3a612ULL, 0x6f4b7fab28f1ab12ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_void, },
  { { 0x0ca200008ffdba44ULL, 0xc998c0ffa6b486b1ULL, 0x9b4ea9f5a23d9c6dULL, 0xa7746e46026b843eULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_bools, },
  { { 0x0ca20000cec55716ULL, 0x747c3602672780d1ULL, 0x1852bd2e467d1e91ULL, 0x61085ceb1b2bf816ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_ints, },
  { { 0x0ca200006ede6737ULL, 0xc9ee1722db2fc583ULL, 0x4e5788c84a81be26ULL, 0x8c32f39e18ad9ab6ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_floats, },
  { { 0x0ca20000d07cd262ULL, 0xfc81ef2c220a8d45ULL, 0x59d0faae36ce56eaULL, 0x0990ad1d3c49827dULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_string, },
  { { 0x0ca20000d1a935c9ULL, 0xc1bdc5f48521c942ULL, 0xebcb3ede7a3fcbdcULL, 0xba634e15fbfde688ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_enum, },
  { { 0x0ca2000093f684d6ULL, 0x345260c4f912f67fULL, 0xa8f6c2af19dc877eULL, 0x176ffee81397fa2eULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_record, },
  { { 0x0ca20000f8d6703fULL, 0x9af82486dc8ce5aaULL, 0x3a6095e0829ba185ULL, 0x74e0fc82dbfa4b77ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_sequence, },
  { { 0x0ca20000ed320c14ULL, 0x672f050fc4be01b7ULL, 0x239a6c63e8d3bb3eULL, 0x106046b369f7e804ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_interface, },
  { { 0x0ca200003fcf3b3dULL, 0x9eeea2d03769389cULL, 0xb168e0c6140b94e5ULL, 0x5b03b11a28cd7427ULL }, InterfaceTests::_dispatch__MethodTestInterface_method_with_quickiface, },
  { { 0x0ca20000ac480384ULL, 0xd1df259f1d53b082ULL, 0x995d5e5b4bb2fcb4ULL, 0x83f6a92ee477fcd6ULL }, RapicornPlicTest::_dispatch__PureMethods_pure_method, },
};
static Plic::DispatcherRegistry _dispatcher_registry (_dispatcher_entries);

} // RapicornPlicTest


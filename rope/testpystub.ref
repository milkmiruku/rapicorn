### --- Generated by Rapicorn-PyStub --- ###

import protocol_pb2 as RapicornRope

class __BaseRecord__:
  def __init__ (self, **entries):
    self.__dict__.update (entries)
class __BaseClass__ (object):
  pass
class __Signal__:
  def __init__ (self, signame):
    self.name = signame

class XFooRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'single_bool' : 0,  'single_num' : 0,  'single_float' : 0,  'single_string' : '',  'sibling1' : 0,  'sibling2' : 0,  'multi1' : 0,  'multi2' : 0,  'multi3' : 0,  'multi4' : 0,  'enum_field' : 0, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = XFooRecord()
    if hasattr (args, "__iter__") and len (args) == 11:
      self.single_bool = args[0]
      #  self.single_bool.vint64 = args[0]
      self.single_num = args[1]
      #  self.single_num.vint64 = args[1]
      self.single_float = args[2]
      #  self.single_float.vdouble = args[2]
      self.single_string = args[3]
      #  self.single_string.vstring = args[3]
      self.sibling1 = args[4]
      #  self.sibling1.vint64 = args[4]
      self.sibling2 = args[5]
      #  self.sibling2.vint64 = args[5]
      self.multi1 = args[6]
      #  self.multi1.vint64 = args[6]
      self.multi2 = args[7]
      #  self.multi2.vint64 = args[7]
      self.multi3 = args[8]
      #  self.multi3.vint64 = args[8]
      self.multi4 = args[9]
      #  self.multi4.vint64 = args[9]
      self.enum_field = args[10]
      #  self.enum_field.vint64 = args[10]
    elif isinstance (args, dict):
      self.single_bool = args["single_bool"]
      self.single_num = args["single_num"]
      self.single_float = args["single_float"]
      self.single_string = args["single_string"]
      self.sibling1 = args["sibling1"]
      self.sibling2 = args["sibling2"]
      self.multi1 = args["multi1"]
      self.multi2 = args["multi2"]
      self.multi3 = args["multi3"]
      self.multi4 = args["multi4"]
      self.enum_field = args["enum_field"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_bool
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_num
    _plic_field = _plic_rp.fields.add()
    _plic_field.vdouble = self.single_float
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring = self.single_string
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi3
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi4
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum_field

class NestedTypesRec (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'rec' : None,  'seq' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = NestedTypesRec()
    if hasattr (args, "__iter__") and len (args) == 2:
      self.rec = args[0]
      #  XFooRecord.to_proto (self.rec.vrec, args[0])
      self.seq = args[1]
      #  XFooSequence.to_proto (self.seq.vseq, args[1])
    elif isinstance (args, dict):
      self.rec = args["rec"]
      self.seq = args["seq"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    XFooRecord.to_proto (_plic_field.vrec, self.rec)
    _plic_field = _plic_rp.fields.add()
    XFooSequence.to_proto (_plic_field.vseq, self.seq)

class AliasRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'single_bool' : 0,  'single_num' : 0,  'single_float' : 0,  'single_string' : '',  'sibling1' : 0,  'sibling2' : 0,  'multi1' : 0,  'multi2' : 0,  'multi3' : 0,  'multi4' : 0,  'enum_field' : 0, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = AliasRecord()
    if hasattr (args, "__iter__") and len (args) == 11:
      self.single_bool = args[0]
      #  self.single_bool.vint64 = args[0]
      self.single_num = args[1]
      #  self.single_num.vint64 = args[1]
      self.single_float = args[2]
      #  self.single_float.vdouble = args[2]
      self.single_string = args[3]
      #  self.single_string.vstring = args[3]
      self.sibling1 = args[4]
      #  self.sibling1.vint64 = args[4]
      self.sibling2 = args[5]
      #  self.sibling2.vint64 = args[5]
      self.multi1 = args[6]
      #  self.multi1.vint64 = args[6]
      self.multi2 = args[7]
      #  self.multi2.vint64 = args[7]
      self.multi3 = args[8]
      #  self.multi3.vint64 = args[8]
      self.multi4 = args[9]
      #  self.multi4.vint64 = args[9]
      self.enum_field = args[10]
      #  self.enum_field.vint64 = args[10]
    elif isinstance (args, dict):
      self.single_bool = args["single_bool"]
      self.single_num = args["single_num"]
      self.single_float = args["single_float"]
      self.single_string = args["single_string"]
      self.sibling1 = args["sibling1"]
      self.sibling2 = args["sibling2"]
      self.multi1 = args["multi1"]
      self.multi2 = args["multi2"]
      self.multi3 = args["multi3"]
      self.multi4 = args["multi4"]
      self.enum_field = args["enum_field"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_bool
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.single_num
    _plic_field = _plic_rp.fields.add()
    _plic_field.vdouble = self.single_float
    _plic_field = _plic_rp.fields.add()
    _plic_field.vstring = self.single_string
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.sibling2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi2
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi3
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.multi4
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum_field

class NewRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'i' : 0,  'enum1' : 0,  'xfs' : None,  'ntr' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = NewRecord()
    if hasattr (args, "__iter__") and len (args) == 4:
      self.i = args[0]
      #  self.i.vint64 = args[0]
      self.enum1 = args[1]
      #  self.enum1.vint64 = args[1]
      self.xfs = args[2]
      #  XFooSequence.to_proto (self.xfs.vseq, args[2])
      self.ntr = args[3]
      #  NestedTypesRec.to_proto (self.ntr.vrec, args[3])
    elif isinstance (args, dict):
      self.i = args["i"]
      self.enum1 = args["enum1"]
      self.xfs = args["xfs"]
      self.ntr = args["ntr"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.i
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.enum1
    _plic_field = _plic_rp.fields.add()
    XFooSequence.to_proto (_plic_field.vseq, self.xfs)
    _plic_field = _plic_rp.fields.add()
    NestedTypesRec.to_proto (_plic_field.vrec, self.ntr)

class InnerRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'x' : 0,  'y' : 0,  'rec' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = InnerRecord()
    if hasattr (args, "__iter__") and len (args) == 3:
      self.x = args[0]
      #  self.x.vint64 = args[0]
      self.y = args[1]
      #  self.y.vint64 = args[1]
      self.rec = args[2]
      #  NewRecord.to_proto (self.rec.vrec, args[2])
    elif isinstance (args, dict):
      self.x = args["x"]
      self.y = args["y"]
      self.rec = args["rec"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.x
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.y
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.rec)

class Refer2Inner (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'r' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = Refer2Inner()
    if hasattr (args, "__iter__") and len (args) == 1:
      self.r = args[0]
      #  InnerRecord.to_proto (self.r.vrec, args[0])
    elif isinstance (args, dict):
      self.r = args["r"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r)

class SomeRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'r1' : None,  'r2' : None,  'r3' : None,  'r4' : None, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = SomeRecord()
    if hasattr (args, "__iter__") and len (args) == 4:
      self.r1 = args[0]
      #  NewRecord.to_proto (self.r1.vrec, args[0])
      self.r2 = args[1]
      #  NewRecord.to_proto (self.r2.vrec, args[1])
      self.r3 = args[2]
      #  InnerRecord.to_proto (self.r3.vrec, args[2])
      self.r4 = args[3]
      #  InnerRecord.to_proto (self.r4.vrec, args[3])
    elif isinstance (args, dict):
      self.r1 = args["r1"]
      self.r2 = args["r2"]
      self.r3 = args["r3"]
      self.r4 = args["r4"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.r1)
    _plic_field = _plic_rp.fields.add()
    NewRecord.to_proto (_plic_field.vrec, self.r2)
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r3)
    _plic_field = _plic_rp.fields.add()
    InnerRecord.to_proto (_plic_field.vrec, self.r4)

class UIWidgetArea (__BaseClass__):
  def __init__ (self):
    super (UIWidgetArea, self).__init__()
    self.sig_void_signal = __Signal__ ('void_signal')
    self.sig_sample_signal = __Signal__ ('sample_signal')
  def simple_method (self): # float
    return self.__pyrope_trampoline__ (0x0def0001, self)
  def single_arg (self, n): # float
    return self.__pyrope_trampoline__ (0x0def0002, self, n)
  def single_arg2 (self, n): # float
    return self.__pyrope_trampoline__ (0x0def0003, self, n)
  def two_args (self, n, r): # float
    return self.__pyrope_trampoline__ (0x0def0004, self, n, r)
  def two_args2 (self, n, r): # float
    return self.__pyrope_trampoline__ (0x0def0005, self, n, r)
  def multi_args (self, n, r, i, s, y): # float
    return self.__pyrope_trampoline__ (0x0def0006, self, n, r, i, s, y)
  def self_method (self, ba1, ba2): # float
    return self.__pyrope_trampoline__ (0x0def0007, self, ba1, ba2)
  def void_method (self): # one way
    return self.__pyrope_trampoline__ (0x0def0008, self)
  def on_click2out (self): # string
    return self.__pyrope_trampoline__ (0x0def0009, self)
  def on_click2in (self, command): # one way
    return self.__pyrope_trampoline__ (0x0def000a, self, command)
  def __sig_void_signal__ (self): pass # default handler
  def __sig_sample_signal__ (self): pass # default handler

class Parent (__BaseClass__):
  def __init__ (self):
    super (Parent, self).__init__()

class Child (Parent):
  def __init__ (self):
    super (Child, self).__init__()

class Descendant (Child):
  def __init__ (self):
    super (Descendant, self).__init__()

class GrandChild (Descendant):
  def __init__ (self):
    super (GrandChild, self).__init__()

class QuickRecord (__BaseRecord__):
  def __init__ (self, **entries):
    defaults = { 'int1' : 0,  'int2' : 0, }
    self.__dict__.update (defaults)
    __BaseRecord__.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = QuickRecord()
    if hasattr (args, "__iter__") and len (args) == 2:
      self.int1 = args[0]
      #  self.int1.vint64 = args[0]
      self.int2 = args[1]
      #  self.int2.vint64 = args[1]
    elif isinstance (args, dict):
      self.int1 = args["int1"]
      self.int2 = args["int2"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _plic_rec):
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.int1
    _plic_field = _plic_rp.fields.add()
    _plic_field.vint64 = self.int2

class MethodTestInterface (__BaseClass__):
  def __init__ (self):
    super (MethodTestInterface, self).__init__()
  def method_with_bools (self, input, optval): # bool
    return self.__pyrope_trampoline__ (0x0def000b, self, input, optval)
  def method_with_ints (self, input, optval): # int
    return self.__pyrope_trampoline__ (0x0def000c, self, input, optval)
  def method_with_floats (self, input, optval): # float
    return self.__pyrope_trampoline__ (0x0def000d, self, input, optval)
  def method_with_string (self, input, optval): # string
    return self.__pyrope_trampoline__ (0x0def000e, self, input, optval)
  def method_with_enum (self, input, optval): # QuickEnum
    return self.__pyrope_trampoline__ (0x0def000f, self, input, optval)
  def method_with_record (self, input, optval): # QuickRecord
    return self.__pyrope_trampoline__ (0x0def0010, self, input, optval)
  def method_with_sequence (self, input, optval): # QuickSequence
    return self.__pyrope_trampoline__ (0x0def0011, self, input, optval)
  def method_with_interface (self, input, optval): # GrandChild
    return self.__pyrope_trampoline__ (0x0def0012, self, input, optval)

class SomeInterface (__BaseClass__):
  def __init__ (self):
    super (SomeInterface, self).__init__()
  def use_record (self, rr): # one way
    return self.__pyrope_trampoline__ (0x0def0013, self, rr)

class ButtonArea (__BaseClass__):
  def __init__ (self):
    super (ButtonArea, self).__init__()
    self.sig_check_activate = __Signal__ ('check_activate')
    self.sig_activate = __Signal__ ('activate')
  def __sig_check_activate__ (self): pass # default handler
  def __sig_activate__ (self): pass # default handler


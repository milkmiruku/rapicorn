### === Generated by Rapicorn-PyStub === ###

import __testpass as _CPY
class __AIDA_Enum__ (long):
  def __new__ (_class, value, ident, doc = None):
    if ident and _class.enum_values.has_key (ident):
      raise KeyError (ident)
    instance = long.__new__ (_class, value)
    if ident: # track named enums (non-anonymous)
      instance.name = ident
      _class.enum_values[ident] = instance
      vlist = _class._valuedict.get (value, [])
      if not vlist:
        _class._valuedict[value] = vlist
      vlist += [ instance ]
    if doc:
      instance.__doc__ = doc
    return instance
  def __repr__ (self):
    if hasattr (self, 'name'):
      return '<enum %s.%s value %s>' % (self.__class__.__name__, self.name, repr (long (self)))
    else:
      return '<enum %s.%u>' % (self.__class__.__name__, self)
  def __str__ (self):
    return self.name if hasattr (self, 'name') else str (long (self))
  @classmethod
  def _enum_lookup (_class, value):
    try:
      return _class.index (value)
    except:
      return _class (value, None) # anonymous enum
  @classmethod
  def index (_class, value):
    return _class._valuedict[value][0]
  @classmethod
  def get (_class, key, default = None):
    return _class.enum_values.get (key, default)

class _BaseRecord_:
  def __init__ (self, **entries):
    self.__dict__.update (entries)

class _BaseClass_ (object):
  class _AidaID_:
    def __init__ (self, _aidaid):
      assert isinstance (_aidaid, (int, long))
      self.id = _aidaid
  class __Signal__:
    def __init__ (self, object, pyconnect):
      self.__object = object
      self.__pyconnect = pyconnect
    def connect (self, _callable):
      return self.__pyconnect (self.__object, _callable, 0)
    def disconnect (self, connection_id):
      return self.__pyconnect (self.__object, None, connection_id)
    def __iadd__ (self, _callable):
      return self.connect (_callable)
    def __isub__ (self, connection_id):
      return self.disconnect (connection_id)
  def __init__ (self, _aida_id):
    assert isinstance (_aida_id, _BaseClass_._AidaID_)
    self.__dict__['__aida_pyobject__'] = _aida_id.id
  def __getattr__ (self, name):
    try:
      getter = getattr (self.__class__, '__pygetter__%s__' % name)
    except AttributeError:
      try:
        getter = getattr (self.__class__, '__pysignal__%s__' % name)
      except AttributeError:
        raise AttributeError ("class %s has no attribute '%s'" % (self.__class__.__name__, name))
    return getter (self)
  def __setattr__ (self, name, value):
    try:
      setter = getattr (self.__class__, '__pysetter__%s__' % name)
    except AttributeError:
      try:
        getattr (self.__class__, '__pysignal__%s__' % name)
        return None # ignore setting of signals to allow __iadd__ and __isub__
      except AttributeError:
        raise AttributeError ("class %s has no attribute '%s'" % (self.__class__.__name__, name))
    return setter (self, value)

def __AIDA_pyfactory__create_pyobject__ (type_name, longid):
    klass = globals().get (type_name, None)
    if hasattr (klass, '_enum_lookup'):
      return klass._enum_lookup (longid)
    if not klass or not longid:
      return None
    return klass (_BaseClass_._AidaID_ (longid))
_CPY.__AIDA_pyfactory__register_callback (__AIDA_pyfactory__create_pyobject__)
_CPY.__AIDA_BaseRecord__ = _BaseRecord_

class Enum1 (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
E1_A = Enum1 (1, "E1_A")

class Enum1c (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
E1C_A = Enum1c (1, "E1C_A")

class Enum2 (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
E2_A = Enum2 (1, "E2_A")
E2_B = Enum2 (2, "E2_B")

class Enum2c (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
E2C_A = Enum2c (1, "E2C_A")
E2C_B = Enum2c (2, "E2C_B")

class Enum3 (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
E3_A = Enum3 (1, "E3_A")
E3_B = Enum3 (2, "E3_B")
E3_C = Enum3 (3, "E3_C")

class Enum3c (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
E3C_A = Enum3c (1, "E3C_A")
E3C_B = Enum3c (2, "E3C_B")
E3C_C = Enum3c (3, "E3C_C")

class Enum4a (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
E4A_A = Enum4a (1, "E4A_A")
E4A_B = Enum4a (2, "E4A_B")
E4A_C = Enum4a (3, "E4A_C")
E4A_D = Enum4a (4, "E4A_D")

class Enum4b (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
E4B_A = Enum4b (1, "E4B_A")
E4B_B = Enum4b (2, "E4B_B")
E4B_C = Enum4b (3, "E4B_C")
E4B_D = Enum4b (4, "E4B_D")

class Enum4c (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
E4C_A = Enum4c (1, "E4C_A")
E4C_B = Enum4c (2, "E4C_B")
E4C_C = Enum4c (3, "E4C_C")
E4C_D = Enum4c (4, "E4C_D")

class Enum4d (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
E4D_A = Enum4d (1, "E4D_A")
E4D_B = Enum4d (2, "E4D_B")
E4D_C = Enum4d (3, "E4D_C")
E4D_D = Enum4d (4, "E4D_D")

class ExtensiveEnum (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
V1a = ExtensiveEnum (1, "V1a")
V1b = ExtensiveEnum (1, "V1b")
V2 = ExtensiveEnum (2, "V2")
V3 = ExtensiveEnum (3, "V3")
V4 = ExtensiveEnum (4, "V4")
V5 = ExtensiveEnum (5, "V5")
V6 = ExtensiveEnum (6, "V6")
V7 = ExtensiveEnum (7, "V7")
V8 = ExtensiveEnum (8, "V8")
V9 = ExtensiveEnum (9, "V9")
V10 = ExtensiveEnum (10, "V10")
V11 = ExtensiveEnum (11, "V11")
V12 = ExtensiveEnum (12, "V12")
V13 = ExtensiveEnum (13, "V13")
V14 = ExtensiveEnum (14, "V14")
V15 = ExtensiveEnum (15, "V15")
V16 = ExtensiveEnum (16, "V16")
V17 = ExtensiveEnum (17, "V17")
V18 = ExtensiveEnum (18, "V18")
V20 = ExtensiveEnum (20, "V20")
V21 = ExtensiveEnum (21, "V21")
V22 = ExtensiveEnum (22, "V22")
V23 = ExtensiveEnum (23, "V23")
V24 = ExtensiveEnum (24, "V24")
V25 = ExtensiveEnum (-16, "V25")
V26 = ExtensiveEnum (16, "V26")
V27 = ExtensiveEnum (-16, "V27")
V28 = ExtensiveEnum (-28, "V28")
V30 = ExtensiveEnum (42, "V30")
V31 = ExtensiveEnum (43, "V31")
V32 = ExtensiveEnum (42, "V32")
V33 = ExtensiveEnum (43, "V33")
V34 = ExtensiveEnum (44, "V34")
V35 = ExtensiveEnum (42, "V35")
V36 = ExtensiveEnum (42, "V36")

class FirstInterface (_BaseClass_):
  def __init__ (self, _aida_id):
    super (FirstInterface, self).__init__ (_aida_id)
  def void_func (self): # one way
    return _CPY.__AIDA_pycall__c3f858f5171056cb394e47a2bcd63e16__ (self)

class XFooRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'single_bool' : 0,  'single_num' : 0,  'num64' : 0,  'single_float' : 0,  'single_string' : '',  'sibling1' : 0,  'sibling2' : 0,  'multi1' : 0,  'multi2' : 0,  'multi3' : 0,  'multi4' : 0,  'enum_field' : 0,  'iface1' : None,  'iface2' : None,  'iface3' : None,  'any1' : (),  'any2' : (),  'any3' : (), }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = XFooRecord()
    if hasattr (args, "__iter__") and len (args) == 18:
      self.single_bool = args[0]
      #  self.single_bool.vint64 = args[0]
      self.single_num = args[1]
      #  self.single_num.vint64 = args[1]
      self.num64 = args[2]
      #  self.num64.vint64 = args[2]
      self.single_float = args[3]
      #  self.single_float.vdouble = args[3]
      self.single_string = args[4]
      #  self.single_string.vstring = args[4]
      self.sibling1 = args[5]
      #  self.sibling1.vint64 = args[5]
      self.sibling2 = args[6]
      #  self.sibling2.vint64 = args[6]
      self.multi1 = args[7]
      #  self.multi1.vint64 = args[7]
      self.multi2 = args[8]
      #  self.multi2.vint64 = args[8]
      self.multi3 = args[9]
      #  self.multi3.vint64 = args[9]
      self.multi4 = args[10]
      #  self.multi4.vint64 = args[10]
      self.enum_field = args[11]
      #  self.enum_field.vint64 = args[11]
      self.iface1 = args[12]
      #  self.iface1.vstring (Instance2StringCast (args[12]))
      self.iface2 = args[13]
      #  self.iface2.vstring (Instance2StringCast (args[13]))
      self.iface3 = args[14]
      #  self.iface3.vstring (Instance2StringCast (args[14]))
      self.any1 = args[15]
      #  # FIXME: support Aida::Any with Any.to_proto (self.any1.vany, args[15])
      self.any2 = args[16]
      #  # FIXME: support Aida::Any with Any.to_proto (self.any2.vany, args[16])
      self.any3 = args[17]
      #  # FIXME: support Aida::Any with Any.to_proto (self.any3.vany, args[17])
    elif isinstance (args, dict):
      self.single_bool = args["single_bool"]
      self.single_num = args["single_num"]
      self.num64 = args["num64"]
      self.single_float = args["single_float"]
      self.single_string = args["single_string"]
      self.sibling1 = args["sibling1"]
      self.sibling2 = args["sibling2"]
      self.multi1 = args["multi1"]
      self.multi2 = args["multi2"]
      self.multi3 = args["multi3"]
      self.multi4 = args["multi4"]
      self.enum_field = args["enum_field"]
      self.iface1 = args["iface1"]
      self.iface2 = args["iface2"]
      self.iface3 = args["iface3"]
      self.any1 = args["any1"]
      self.any2 = args["any2"]
      self.any3 = args["any3"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _aida_rec):
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.single_bool
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.single_num
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.num64
    _aida_field = _aida_rp.fields.add()
    _aida_field.vdouble = self.single_float
    _aida_field = _aida_rp.fields.add()
    _aida_field.vstring = self.single_string
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.sibling1
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.sibling2
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.multi1
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.multi2
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.multi3
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.multi4
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.enum_field
    _aida_field = _aida_rp.fields.add()
    _aida_field.vstring (Instance2StringCast (self.iface1))
    _aida_field = _aida_rp.fields.add()
    _aida_field.vstring (Instance2StringCast (self.iface2))
    _aida_field = _aida_rp.fields.add()
    _aida_field.vstring (Instance2StringCast (self.iface3))
    _aida_field = _aida_rp.fields.add()
    # FIXME: support Aida::Any with Any.to_proto (_aida_field.vany, self.any1)
    _aida_field = _aida_rp.fields.add()
    # FIXME: support Aida::Any with Any.to_proto (_aida_field.vany, self.any2)
    _aida_field = _aida_rp.fields.add()
    # FIXME: support Aida::Any with Any.to_proto (_aida_field.vany, self.any3)

class NestedTypesRec (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'rec' : None,  'seq' : (), }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = NestedTypesRec()
    if hasattr (args, "__iter__") and len (args) == 2:
      self.rec = args[0]
      #  XFooRecord.to_proto (self.rec.vrec, args[0])
      self.seq = args[1]
      #  XFooSequence.to_proto (self.seq.vseq, args[1])
    elif isinstance (args, dict):
      self.rec = args["rec"]
      self.seq = args["seq"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _aida_rec):
    _aida_field = _aida_rp.fields.add()
    XFooRecord.to_proto (_aida_field.vrec, self.rec)
    _aida_field = _aida_rp.fields.add()
    XFooSequence.to_proto (_aida_field.vseq, self.seq)

class AliasRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'single_bool' : 0,  'single_num' : 0,  'num64' : 0,  'single_float' : 0,  'single_string' : '',  'sibling1' : 0,  'sibling2' : 0,  'multi1' : 0,  'multi2' : 0,  'multi3' : 0,  'multi4' : 0,  'enum_field' : 0,  'iface1' : None,  'iface2' : None,  'iface3' : None,  'any1' : (),  'any2' : (),  'any3' : (), }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = AliasRecord()
    if hasattr (args, "__iter__") and len (args) == 18:
      self.single_bool = args[0]
      #  self.single_bool.vint64 = args[0]
      self.single_num = args[1]
      #  self.single_num.vint64 = args[1]
      self.num64 = args[2]
      #  self.num64.vint64 = args[2]
      self.single_float = args[3]
      #  self.single_float.vdouble = args[3]
      self.single_string = args[4]
      #  self.single_string.vstring = args[4]
      self.sibling1 = args[5]
      #  self.sibling1.vint64 = args[5]
      self.sibling2 = args[6]
      #  self.sibling2.vint64 = args[6]
      self.multi1 = args[7]
      #  self.multi1.vint64 = args[7]
      self.multi2 = args[8]
      #  self.multi2.vint64 = args[8]
      self.multi3 = args[9]
      #  self.multi3.vint64 = args[9]
      self.multi4 = args[10]
      #  self.multi4.vint64 = args[10]
      self.enum_field = args[11]
      #  self.enum_field.vint64 = args[11]
      self.iface1 = args[12]
      #  self.iface1.vstring (Instance2StringCast (args[12]))
      self.iface2 = args[13]
      #  self.iface2.vstring (Instance2StringCast (args[13]))
      self.iface3 = args[14]
      #  self.iface3.vstring (Instance2StringCast (args[14]))
      self.any1 = args[15]
      #  # FIXME: support Aida::Any with Any.to_proto (self.any1.vany, args[15])
      self.any2 = args[16]
      #  # FIXME: support Aida::Any with Any.to_proto (self.any2.vany, args[16])
      self.any3 = args[17]
      #  # FIXME: support Aida::Any with Any.to_proto (self.any3.vany, args[17])
    elif isinstance (args, dict):
      self.single_bool = args["single_bool"]
      self.single_num = args["single_num"]
      self.num64 = args["num64"]
      self.single_float = args["single_float"]
      self.single_string = args["single_string"]
      self.sibling1 = args["sibling1"]
      self.sibling2 = args["sibling2"]
      self.multi1 = args["multi1"]
      self.multi2 = args["multi2"]
      self.multi3 = args["multi3"]
      self.multi4 = args["multi4"]
      self.enum_field = args["enum_field"]
      self.iface1 = args["iface1"]
      self.iface2 = args["iface2"]
      self.iface3 = args["iface3"]
      self.any1 = args["any1"]
      self.any2 = args["any2"]
      self.any3 = args["any3"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _aida_rec):
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.single_bool
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.single_num
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.num64
    _aida_field = _aida_rp.fields.add()
    _aida_field.vdouble = self.single_float
    _aida_field = _aida_rp.fields.add()
    _aida_field.vstring = self.single_string
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.sibling1
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.sibling2
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.multi1
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.multi2
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.multi3
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.multi4
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.enum_field
    _aida_field = _aida_rp.fields.add()
    _aida_field.vstring (Instance2StringCast (self.iface1))
    _aida_field = _aida_rp.fields.add()
    _aida_field.vstring (Instance2StringCast (self.iface2))
    _aida_field = _aida_rp.fields.add()
    _aida_field.vstring (Instance2StringCast (self.iface3))
    _aida_field = _aida_rp.fields.add()
    # FIXME: support Aida::Any with Any.to_proto (_aida_field.vany, self.any1)
    _aida_field = _aida_rp.fields.add()
    # FIXME: support Aida::Any with Any.to_proto (_aida_field.vany, self.any2)
    _aida_field = _aida_rp.fields.add()
    # FIXME: support Aida::Any with Any.to_proto (_aida_field.vany, self.any3)

class AliasEnum (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
V1a = AliasEnum (1, "V1a")
V1b = AliasEnum (1, "V1b")
V2 = AliasEnum (2, "V2")
V3 = AliasEnum (3, "V3")
V4 = AliasEnum (4, "V4")
V5 = AliasEnum (5, "V5")
V6 = AliasEnum (6, "V6")
V7 = AliasEnum (7, "V7")
V8 = AliasEnum (8, "V8")
V9 = AliasEnum (9, "V9")
V10 = AliasEnum (10, "V10")
V11 = AliasEnum (11, "V11")
V12 = AliasEnum (12, "V12")
V13 = AliasEnum (13, "V13")
V14 = AliasEnum (14, "V14")
V15 = AliasEnum (15, "V15")
V16 = AliasEnum (16, "V16")
V17 = AliasEnum (17, "V17")
V18 = AliasEnum (18, "V18")
V20 = AliasEnum (20, "V20")
V21 = AliasEnum (21, "V21")
V22 = AliasEnum (22, "V22")
V23 = AliasEnum (23, "V23")
V24 = AliasEnum (24, "V24")
V25 = AliasEnum (-16, "V25")
V26 = AliasEnum (16, "V26")
V27 = AliasEnum (-16, "V27")
V28 = AliasEnum (-28, "V28")
V30 = AliasEnum (42, "V30")
V31 = AliasEnum (43, "V31")
V32 = AliasEnum (42, "V32")
V33 = AliasEnum (43, "V33")
V34 = AliasEnum (44, "V34")
V35 = AliasEnum (42, "V35")
V36 = AliasEnum (42, "V36")

class NewRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'i' : 0,  'enum1' : 0,  'xfs' : (),  'ntr' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = NewRecord()
    if hasattr (args, "__iter__") and len (args) == 4:
      self.i = args[0]
      #  self.i.vint64 = args[0]
      self.enum1 = args[1]
      #  self.enum1.vint64 = args[1]
      self.xfs = args[2]
      #  XFooSequence.to_proto (self.xfs.vseq, args[2])
      self.ntr = args[3]
      #  NestedTypesRec.to_proto (self.ntr.vrec, args[3])
    elif isinstance (args, dict):
      self.i = args["i"]
      self.enum1 = args["enum1"]
      self.xfs = args["xfs"]
      self.ntr = args["ntr"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _aida_rec):
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.i
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.enum1
    _aida_field = _aida_rp.fields.add()
    XFooSequence.to_proto (_aida_field.vseq, self.xfs)
    _aida_field = _aida_rp.fields.add()
    NestedTypesRec.to_proto (_aida_field.vrec, self.ntr)

class InnerRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'x' : 0,  'y' : 0,  'rec' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = InnerRecord()
    if hasattr (args, "__iter__") and len (args) == 3:
      self.x = args[0]
      #  self.x.vint64 = args[0]
      self.y = args[1]
      #  self.y.vint64 = args[1]
      self.rec = args[2]
      #  NewRecord.to_proto (self.rec.vrec, args[2])
    elif isinstance (args, dict):
      self.x = args["x"]
      self.y = args["y"]
      self.rec = args["rec"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _aida_rec):
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.x
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.y
    _aida_field = _aida_rp.fields.add()
    NewRecord.to_proto (_aida_field.vrec, self.rec)

class Refer2Inner (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'r' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = Refer2Inner()
    if hasattr (args, "__iter__") and len (args) == 1:
      self.r = args[0]
      #  InnerRecord.to_proto (self.r.vrec, args[0])
    elif isinstance (args, dict):
      self.r = args["r"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _aida_rec):
    _aida_field = _aida_rp.fields.add()
    InnerRecord.to_proto (_aida_field.vrec, self.r)

class SomeRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'r1' : None,  'r2' : None,  'r3' : None,  'r4' : None, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = SomeRecord()
    if hasattr (args, "__iter__") and len (args) == 4:
      self.r1 = args[0]
      #  NewRecord.to_proto (self.r1.vrec, args[0])
      self.r2 = args[1]
      #  NewRecord.to_proto (self.r2.vrec, args[1])
      self.r3 = args[2]
      #  InnerRecord.to_proto (self.r3.vrec, args[2])
      self.r4 = args[3]
      #  InnerRecord.to_proto (self.r4.vrec, args[3])
    elif isinstance (args, dict):
      self.r1 = args["r1"]
      self.r2 = args["r2"]
      self.r3 = args["r3"]
      self.r4 = args["r4"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _aida_rec):
    _aida_field = _aida_rp.fields.add()
    NewRecord.to_proto (_aida_field.vrec, self.r1)
    _aida_field = _aida_rp.fields.add()
    NewRecord.to_proto (_aida_field.vrec, self.r2)
    _aida_field = _aida_rp.fields.add()
    InnerRecord.to_proto (_aida_field.vrec, self.r3)
    _aida_field = _aida_rp.fields.add()
    InnerRecord.to_proto (_aida_field.vrec, self.r4)

class UIWidgetArea (_BaseClass_):
  def __init__ (self, _aida_id):
    super (UIWidgetArea, self).__init__ (_aida_id)
  def simple_method (self): # returns float64
    return _CPY.__AIDA_pycall__d0dd4c08ba5022c0b1af31ca1ec7037a__ (self)
  def single_arg (self, n): # returns float64
    return _CPY.__AIDA_pycall__e4e890540b4c0579e14a7ffaa82f1c4f__ (self, n)
  def single_arg2 (self, n = 5): # returns float64
    return _CPY.__AIDA_pycall__9cfaa316ccbb6ea06cc5207c5520e081__ (self, n)
  def two_args (self, n, r): # returns float64
    return _CPY.__AIDA_pycall__64511c410b16c27419b47eb22b4cd4d4__ (self, n, r)
  def two_args2 (self, n = 6, r = 7.7): # returns float64
    return _CPY.__AIDA_pycall__2089150ae3f7ad80e6154471cb4560e0__ (self, n, r)
  def multi_args (self, b, n, r, i, s = "String ding", y = 5): # returns float64
    return _CPY.__AIDA_pycall__349f073a5bad36fdf7a10ae13b8e391b__ (self, b, n, r, i, s, y)
  def self_method (self, ba1, ba2): # returns float64
    return _CPY.__AIDA_pycall__4b479b2f4e3ba551b7c407eee57eb21a__ (self, ba1, ba2)
  def void_method (self): # one way
    return _CPY.__AIDA_pycall__dbb304ad4df15873ca276abf2bb1603c__ (self)
  def on_click2out (self): # returns String
    return _CPY.__AIDA_pycall__b8bc20394724087abc7b1e7d30aeb178__ (self)
  def on_click2in (self, command): # one way
    return _CPY.__AIDA_pycall__3432c3bb41bc72a0533bc22135f973bf__ (self, command)
  def __pysignal__sig_void_signal__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__0774aa0ffbdf5f023f1b5247dca90c86__)
  def __pysignal__sig_sample_signal__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__219d8339499d690e08bca1e9a82f86b0__)
  __pygetter__dummy__             = _CPY.__AIDA_pygetter__f67db704b9d460d6d4950feab697e61e__ # UIWidgetArea.dummy
  __pygetter__on_click__          = _CPY.__AIDA_pygetter__58ba68f6b64584c9a7d2686edb40f27a__ # UIWidgetArea.on_click
  __pysetter__dummy__             = _CPY.__AIDA_pysetter__7aaf2f96f30428293d0391e5b72e7ba5__ # UIWidgetArea.dummy
  __pysetter__on_click__          = _CPY.__AIDA_pysetter__f0025ec0fa66e3e2880c10e8e6b57cfb__ # UIWidgetArea.on_click

class Parent (_BaseClass_):
  def __init__ (self, _aida_id):
    super (Parent, self).__init__ (_aida_id)

class Child (Parent):
  def __init__ (self, _aida_id):
    super (Child, self).__init__ (_aida_id)

class Descendant (Child):
  def __init__ (self, _aida_id):
    super (Descendant, self).__init__ (_aida_id)

class GrandChild (Descendant):
  def __init__ (self, _aida_id):
    super (GrandChild, self).__init__ (_aida_id)

class QuickEnum (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
ZERO = QuickEnum (0, "ZERO")

class QuickRecord (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'int1' : 0,  'int2' : 0, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = QuickRecord()
    if hasattr (args, "__iter__") and len (args) == 2:
      self.int1 = args[0]
      #  self.int1.vint64 = args[0]
      self.int2 = args[1]
      #  self.int2.vint64 = args[1]
    elif isinstance (args, dict):
      self.int1 = args["int1"]
      self.int2 = args["int2"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _aida_rec):
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.int1
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.int2

class QuickIface (_BaseClass_):
  def __init__ (self, _aida_id):
    super (QuickIface, self).__init__ (_aida_id)
  def simple_function (self, i = 9): # one way
    return _CPY.__AIDA_pycall__76ac7a704663d24623abac49621c6802__ (self, i)

class MethodTestInterface (_BaseClass_):
  def __init__ (self, _aida_id):
    super (MethodTestInterface, self).__init__ (_aida_id)
  def method_with_void (self): # one way
    return _CPY.__AIDA_pycall__1addfccb0a3e01be314f2eb467d7a72b__ (self)
  def method_with_bools (self, input, optval = 0): # returns bool
    return _CPY.__AIDA_pycall__55291a7348d1424232dac90dde65a764__ (self, input, optval)
  def method_with_ints32 (self, input, optval = -2): # returns int32
    return _CPY.__AIDA_pycall__dc38cf6855c54108328ddcdcec8f161e__ (self, input, optval)
  def method_with_ints64 (self, input, optval = 576460752303423488): # returns int64
    return _CPY.__AIDA_pycall__678de8636167b6a1b27d37ca066b5335__ (self, input, optval)
  def method_with_floats (self, input, optval = 309.9): # returns float64
    return _CPY.__AIDA_pycall__eea6d5fb184699a3ce05c988a9bfd2d9__ (self, input, optval)
  def method_with_string (self, input, optval = "default"): # returns String
    return _CPY.__AIDA_pycall__646f80849d732dc572fd1ede45b153e3__ (self, input, optval)
  def method_with_enum (self, input, optval = 0): # returns QuickEnum
    return _CPY.__AIDA_pycall__ee3b0b1c6eb52bde13729d2db240b4f9__ (self, input, optval)
  def method_with_record (self, input, optval = None): # returns QuickRecord
    return _CPY.__AIDA_pycall__852c7f5942a87cce487dc78cd38240f6__ (self, input, optval)
  def method_with_sequence (self, input, optval = ()): # returns QuickSequence
    return _CPY.__AIDA_pycall__5534838e08bdc63dd852fd5abb88ab7d__ (self, input, optval)
  def method_with_interface (self, input, optval = None): # returns GrandChild
    return _CPY.__AIDA_pycall__fe9af28dc9c5de7d418be0c0e085ea6d__ (self, input, optval)
  def method_with_anys (self, input, optval): # returns Any
    return _CPY.__AIDA_pycall__807e5dacf307a2772b65069e50e63c80__ (self, input, optval)
  def method_with_quickiface (self, input, iface0 = None): # returns QuickIface
    return _CPY.__AIDA_pycall__be67f4e0afeafd685cdf24c075b03215__ (self, input, iface0)

class SignalTestInterface (_BaseClass_):
  def __init__ (self, _aida_id):
    super (SignalTestInterface, self).__init__ (_aida_id)
  def __pysignal__sig_void_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__e2ae7c707a04333c420330b70d64eb5f__)
  def __pysignal__sig_bool_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__31529d809bd68e6ba11d55517d4325ae__)
  def __pysignal__sig_int32_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__ac712d196d3466f3eb06bf4f2b2a414c__)
  def __pysignal__sig_int64_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__1439d37d87e2668b57ded621e6b0cde6__)
  def __pysignal__sig_float64_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__4c5a782eaa76edb0b66fbaa524004fd9__)
  def __pysignal__sig_string_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__bc5c00f41d7c710d368d920fb6c136e6__)
  def __pysignal__sig_enum_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__60702e53aca1b772eac0d39852c951fb__)
  def __pysignal__sig_record_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__755d247d6abfde87093ff68bbb0f5257__)
  def __pysignal__sig_sequence_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__b5c453295aa722077c0fa1c12417b139__)
  def __pysignal__sig_interface_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__e8ef1fe5de31f95bc0e4bcc410120585__)
  def __pysignal__sig_any_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__296163d4220985ce40daacab4a841093__)
  def __pysignal__sig_self_result__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__35828273200534f772873f1374d6093b__)
  def __pysignal__sig_void_arg__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__e79b3592345942f66818e92df5df5bef__)
  def __pysignal__sig_bool_arg__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__495e3d2d698caad7f16b2f75ddaf3220__)
  def __pysignal__sig_int32_arg__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__1d335377194859d1fa00c7fb47bc82e4__)
  def __pysignal__sig_int64_arg__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__52b8b36ec08458caeecdb452f6b51528__)
  def __pysignal__sig_float64_arg__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__dcacb20b2d942f30242d314085f3e44a__)
  def __pysignal__sig_string_arg__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__9bb22c59672e3921981c8364b2197db9__)
  def __pysignal__sig_enum_arg__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__62459d25ac74ebedd598edad744f61b7__)
  def __pysignal__sig_record_arg__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__e4c732769519ca6a8cf6e34972e875aa__)
  def __pysignal__sig_sequence_arg__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__eca8cf0dd80dee4a1bb3845a0704c774__)
  def __pysignal__sig_interface_arg__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__c2562bdab457affd189f1ba486f30579__)
  def __pysignal__sig_any_arg__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__445abac8fb3999b7422ee36946f0b021__)
  def __pysignal__sig_self_args__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__f62d65c3c8ab76a77f95ce585cfc2b0c__)

class ChildInheritingSignals (SignalTestInterface):
  def __init__ (self, _aida_id):
    super (ChildInheritingSignals, self).__init__ (_aida_id)
  def __pysignal__sig_child_signal__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__0b181d52b5db5237d1c6370677791f5a__)

class AnotherChild (SignalTestInterface):
  def __init__ (self, _aida_id):
    super (AnotherChild, self).__init__ (_aida_id)

class PropertyTester (_BaseClass_):
  def __init__ (self, _aida_id):
    super (PropertyTester, self).__init__ (_aida_id)
  __pygetter__bool_prop__         = _CPY.__AIDA_pygetter__14469c03fdfc61e43bb8a3b5d9832788__ # PropertyTester.bool_prop
  __pygetter__int32_prop__        = _CPY.__AIDA_pygetter__8a2f1538f2b852fb7d3e8ea6f069a1c0__ # PropertyTester.int32_prop
  __pygetter__int64_prop__        = _CPY.__AIDA_pygetter__c9bb6114fc5c90de400dff0f59e66f63__ # PropertyTester.int64_prop
  __pygetter__float64_prop__      = _CPY.__AIDA_pygetter__b3d53f6a66ba171ec9e2fe1ad9d2d2ab__ # PropertyTester.float64_prop
  __pygetter__string_prop__       = _CPY.__AIDA_pygetter__d11acce29fa83acfb251b5fc0f737558__ # PropertyTester.string_prop
  __pygetter__enum_prop__         = _CPY.__AIDA_pygetter__42f93106aeb5af11dc4094dc01da9f81__ # PropertyTester.enum_prop
  __pygetter__record_prop__       = _CPY.__AIDA_pygetter__b6ab96740d7834eee7873bec722bb0c8__ # PropertyTester.record_prop
  __pygetter__sequence_prop__     = _CPY.__AIDA_pygetter__7f96e6ff442ecdd5db054c03831fd75b__ # PropertyTester.sequence_prop
  __pygetter__interface_prop__    = _CPY.__AIDA_pygetter__f3cef8a00677d9318733ca529b58ea4a__ # PropertyTester.interface_prop
  __pygetter__self_prop__         = _CPY.__AIDA_pygetter__dd2a04f6c2fc300568868b01ea78948f__ # PropertyTester.self_prop
  __pygetter__any_prop__          = _CPY.__AIDA_pygetter__b54c6ac2d1c8f9321c8ea2813f2c268e__ # PropertyTester.any_prop
  __pysetter__bool_prop__         = _CPY.__AIDA_pysetter__a88d7a16adc7ad4333e7a32598f08880__ # PropertyTester.bool_prop
  __pysetter__int32_prop__        = _CPY.__AIDA_pysetter__7b7b3182160469e4bd3c44c3a57484eb__ # PropertyTester.int32_prop
  __pysetter__int64_prop__        = _CPY.__AIDA_pysetter__b33bf89d2259a1db0154420aebe9a16c__ # PropertyTester.int64_prop
  __pysetter__float64_prop__      = _CPY.__AIDA_pysetter__f1df5bd296ac78e2bb263cff89927093__ # PropertyTester.float64_prop
  __pysetter__string_prop__       = _CPY.__AIDA_pysetter__fadb1eed1d8d358a17cd2ca684080698__ # PropertyTester.string_prop
  __pysetter__enum_prop__         = _CPY.__AIDA_pysetter__99206fff699c82d61dcbc77498569411__ # PropertyTester.enum_prop
  __pysetter__record_prop__       = _CPY.__AIDA_pysetter__55aaf8cee9dd7a4683d8416416740bf0__ # PropertyTester.record_prop
  __pysetter__sequence_prop__     = _CPY.__AIDA_pysetter__f86952a034b8bc843be169a3f0a9a07d__ # PropertyTester.sequence_prop
  __pysetter__interface_prop__    = _CPY.__AIDA_pysetter__bf62779e2a11aebb95547f4e29ca3814__ # PropertyTester.interface_prop
  __pysetter__self_prop__         = _CPY.__AIDA_pysetter__1a1ee3ab20ab3c2feeaf17826dba2891__ # PropertyTester.self_prop
  __pysetter__any_prop__          = _CPY.__AIDA_pysetter__e0c7d397e652f3f7bbdf7826e88f4f42__ # PropertyTester.any_prop

class ClickType (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
CLICK_ON_PRESS = ClickType (1, "CLICK_ON_PRESS")
CLICK_ON_RELEASE = ClickType (2, "CLICK_ON_RELEASE")
CLICK_SLOW_REPEAT = ClickType (3, "CLICK_SLOW_REPEAT")
CLICK_FAST_REPEAT = ClickType (4, "CLICK_FAST_REPEAT")
CLICK_KEY_REPEAT = ClickType (5, "CLICK_KEY_REPEAT")

class ButtonArea (_BaseClass_):
  def __init__ (self, _aida_id):
    super (ButtonArea, self).__init__ (_aida_id)
  def __pysignal__sig_check_activate__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__528a0b92de4a958c4d47eecbae62f654__)
  def __pysignal__sig_activate__ (self):
    return self.__Signal__ (self, _CPY.__AIDA_pyconnect__0c46b868988bad84ff7acbea142bbcd0__)
  __pygetter__on_click__          = _CPY.__AIDA_pygetter__199859aecc756e97a744332174ed27f4__ # ButtonArea.on_click
  __pygetter__on_click2__         = _CPY.__AIDA_pygetter__1b448d91990181da9751c08ae956c729__ # ButtonArea.on_click2
  __pygetter__on_click3__         = _CPY.__AIDA_pygetter__5176fbf25dcf50f44d7ae8b51fb816b5__ # ButtonArea.on_click3
  __pygetter__click_type__        = _CPY.__AIDA_pygetter__b6ab79b43e1f0df9aa0f1ec5c39b704a__ # ButtonArea.click_type
  __pysetter__on_click__          = _CPY.__AIDA_pysetter__db3a24116c6539852a0576faff45b4b2__ # ButtonArea.on_click
  __pysetter__on_click2__         = _CPY.__AIDA_pysetter__fc93898ba4104662c918694fe5c2bfef__ # ButtonArea.on_click2
  __pysetter__on_click3__         = _CPY.__AIDA_pysetter__1c1990dca0fde97c6cc2c7cc49d811f8__ # ButtonArea.on_click3
  __pysetter__click_type__        = _CPY.__AIDA_pysetter__1f5a6d031cb7e1042d4a207f0842bec8__ # ButtonArea.click_type

class PureMethods (_BaseClass_):
  def __init__ (self, _aida_id):
    super (PureMethods, self).__init__ (_aida_id)
  def pure_method (self, f): # returns int32
    return _CPY.__AIDA_pycall__f196563f00b6d48488b59c2ed0597dcc__ (self, f)

class MathExpressions (__AIDA_Enum__):
  enum_values = {}
  _valuedict = {}
RESULT_2 = MathExpressions (2, "RESULT_2")
RESULT_5 = MathExpressions (5, "RESULT_5")
RESULT_8 = MathExpressions (8, "RESULT_8")
RESULT_6 = MathExpressions (6, "RESULT_6")
RESULT_7 = MathExpressions (7, "RESULT_7")
RESULT_16 = MathExpressions (16, "RESULT_16")
RESULT_3 = MathExpressions (3, "RESULT_3")
RESULT_24 = MathExpressions (24, "RESULT_24")
RESULT_13 = MathExpressions (13, "RESULT_13")
RESULT_m2 = MathExpressions (-2, "RESULT_m2")
RESULT_77 = MathExpressions (77, "RESULT_77")
RESULT_511 = MathExpressions (511, "RESULT_511")

class NameTests (_BaseClass_):
  def __init__ (self, _aida_id):
    super (NameTests, self).__init__ (_aida_id)
  def args_from_other_namespace (self, qr, qe, sr): # one way
    return _CPY.__AIDA_pycall__d471f88e8c15081c963d2094339d0220__ (self, qr, qe, sr)

class Compressor (_BaseClass_):
  def __init__ (self, _aida_id):
    super (Compressor, self).__init__ (_aida_id)
  __pygetter__threshold__         = _CPY.__AIDA_pygetter__dea15f2de1c3d8e3e3fc9febf31cdc20__ # Compressor.threshold
  __pygetter__ratio__             = _CPY.__AIDA_pygetter__c61a8d739c7b963bca1ad4eeab1aa56e__ # Compressor.ratio
  __pysetter__threshold__         = _CPY.__AIDA_pysetter__f40a3fd3d07b3d0bbae97c41e3d6a92b__ # Compressor.threshold
  __pysetter__ratio__             = _CPY.__AIDA_pysetter__302f0b5b99a2a6c8c8b771894ecd9315__ # Compressor.ratio

class RecordForGroups (_BaseRecord_):
  def __init__ (self, **entries):
    defaults = { 'i' : 0,  'ratio' : 0,  'ordinary_bool' : 0,  'threshold1' : 0,  'threshold2' : 0, }
    self.__dict__.update (defaults)
    _BaseRecord_.__init__ (self, **entries)
  @staticmethod
  def create (args):
    self = RecordForGroups()
    if hasattr (args, "__iter__") and len (args) == 5:
      self.i = args[0]
      #  self.i.vint64 = args[0]
      self.ratio = args[1]
      #  self.ratio.vdouble = args[1]
      self.ordinary_bool = args[2]
      #  self.ordinary_bool.vint64 = args[2]
      self.threshold1 = args[3]
      #  self.threshold1.vdouble = args[3]
      self.threshold2 = args[4]
      #  self.threshold2.vdouble = args[4]
    elif isinstance (args, dict):
      self.i = args["i"]
      self.ratio = args["ratio"]
      self.ordinary_bool = args["ordinary_bool"]
      self.threshold1 = args["threshold1"]
      self.threshold2 = args["threshold2"]
    else: raise RuntimeError ("invalid or missing record initializers")
    return self
  @staticmethod
  def to_proto (self, _aida_rec):
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.i
    _aida_field = _aida_rp.fields.add()
    _aida_field.vdouble = self.ratio
    _aida_field = _aida_rp.fields.add()
    _aida_field.vint64 = self.ordinary_bool
    _aida_field = _aida_rp.fields.add()
    _aida_field.vdouble = self.threshold1
    _aida_field = _aida_rp.fields.add()
    _aida_field.vdouble = self.threshold2

class SoundModule (_BaseClass_):
  def __init__ (self, _aida_id):
    super (SoundModule, self).__init__ (_aida_id)

del _CPY

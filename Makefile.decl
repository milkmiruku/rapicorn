# Rapicorn						-*-mode:makefile;-*-
# This Source Code Form is licensed MPLv2: http://mozilla.org/MPL/2.0

# declare variables that we might want to use += on.
EXTRA_HEADERS=
MAINTAINERCLEANFILES=$(GENERATED)
CLEANFILES=$(GENERATED_CLEANFILES)
GENERATED_EXTRA_DIST=
GENERATED_CLEANFILES=
GENERATED=$(strip $(GENERATED_EXTRA_DIST) $(GENERATED_CLEANFILES))
EXTRA_DIST=$(GENERATED_EXTRA_DIST)

# Verbosity macros
Q       = $(if $(findstring 1, $(V)) ,, @)
QGEN    = $(Q:@=@echo '  GEN   ' $@; )
QSTDERR = $(Q:@=2>/dev/null)
QSTDOUT = $(Q:@=1>/dev/null)

# == download ==
# recursive rule supported by all Makefiles to download files hosted online
.PHONY: download download-recursive download-local
download: download-local download-recursive
download-recursive:
	$(Q) for subdir in $(SUBDIRS) ; do test "$$subdir" = '.' || $(MAKE) -C "$$subdir" $(AM_MAKEFLAGS) download || exit $$? ; done

# == X11 for Unit Tests ==
x11test_log   = $(abs_top_builddir)/.x11test.log
DISPLAYHASH   = x11test-$(shell echo "$(PACKAGE) $(abs_top_builddir)" | md5sum | sed 's/\(.\{7\}\).*/\1/')
X11TEST_FIND  = \
  for F in $$(ps -eo pid,args | \
    sed -n '{s/^\s*\([0-9]\+\)\s\+Xephyr :\([0-9]\+\) -displayID $(DISPLAYHASH)\b.*/\1:\2/; Tdone; p; :done }') nil ; do \
    X11TEST_PID=$${F/:*/} ; X11TEST_DISPLAY=$${F/*:/} ; \
    xset -display :$$X11TEST_DISPLAY q >/dev/null 2>&1 && break ; done
x11test-find:
	@$(X11TEST_FIND) || { echo "$(MAKECMDGOALS): no X11 test server, issue: make x11test-start" ; exit 1 ; } \
	&& echo "DISPLAY=:$$X11TEST_DISPLAY # x11test: Xephyr: pid=$$X11TEST_PID"
x11test-start:
	@$(X11TEST_FIND) || { \
	  Xephyr -help 2>&1 | grep -q display || { echo "$(MAKECMDGOALS): failed to start Xephyr"; exit 1 ; } \
	  && for idoffs in `seq 1001 1500` ; do X11TEST_DISPLAY=$$(($$idoffs + $$RANDOM % 500)) \
	  && test ! -e /tmp/.X$$X11TEST_DISPLAY-lock && break ; done \
	  || { echo "$(MAKECMDGOALS): out of available X11 Display IDs"; exit 1 ; }; \
	  Xephyr :$$X11TEST_DISPLAY -displayID $(DISPLAYHASH) -screen 800x600x32 -nolisten tcp -keybd ephyr \
	         -auth /dev/null -noreset -retro >$(x11test_log) 2>&1 & X11TEST_PID="$$!" \
	  && { [ -z "$$DISPLAY" ] || { sleep 1; setxkbmap -print | xkbcomp - :$$X11TEST_DISPLAY 2>/dev/null ; }; }; } \
	&& echo "DISPLAY=:$$X11TEST_DISPLAY # x11test: Xephyr: pid=$$X11TEST_PID"
# -host-cursor
x11test-stop:
	@$(X11TEST_FIND) || { echo "$(MAKECMDGOALS): no x11test running" ; exit 0 ; } \
	&& kill -SIGTERM $$X11TEST_PID \
	&& test -z `ps -o pid=  $$X11TEST_PID` || { sleep 1 ; kill -SIGKILL $$X11TEST_PID 2>/dev/null ; } \
	|| true
export X11TEST_DISPLAY ?= $(shell $(X11TEST_FIND) && echo ":$$X11TEST_DISPLAY")
# use: $(X11TEST_SERVER) && someprogram # sets $DISPLAY
X11TEST_SERVER := \
  if [ -z "$$X11TEST_DISPLAY" ] ; then \
    Xvfb -help 2>&1 | grep -q display || { echo "$(MAKECMDGOALS): failed to start Xvfb" ; exit -2 ; } \
    && for idoffs in `seq 1001 1500` ; do D=$$(($$idoffs + $$RANDOM % 500)) \
    && test ! -e /tmp/.X$$D-lock && break ; done \
    || { echo "$(MAKECMDGOALS): out of available X11 Display IDs" ; exit -2 ; } \
    && { Xvfb :$$D -screen 0 800x600x24 -nolisten tcp -auth /dev/null -noreset -retro >>$(x11test_log) 2>&1 & } \
    && trap "set +x; kill -15 $$!" 0 HUP INT QUIT TRAP ILL ABRT FPE SEGV PIPE ALRM TERM BUS SYS XCPU XFSZ USR1 \
    && until xset -display :$$D q >/dev/null 2>&1 ; do sleep 0.1 ; done && DISPLAY=:$$D ; \
  else DISPLAY="$$X11TEST_DISPLAY" ; \
  fi && export DISPLAY
CLEANFILES += $(if $(filter $(top_builddir), . ), $(x11test_log))

# == Error Filter ==
FIX_STDERR_FILTER = grep -v -E \
  -e '^Xlib: *extension "[^"]*" missing on display ":[^"]*"'
# Use grep to filter bogus messages from test results
# === distfile-list ===
# recursive rule supported by all Makefiles to generate a list of all files
# listed as DISTFILES. this asserts a writable file named $DISTFILE_LIST.
.PHONY: distfile-list
distfile-list:
	@if test ! -f "$(DISTFILE_LIST)" ; then				\
		echo 'distfile-list: $$(DISTFILE_LIST) is unwritable' ;	\
		exit 1 ;						\
	fi
	@for subdir in $(SUBDIRS) ; do				\
	  test "$$subdir" = '.' ||				\
	    $(MAKE) -C "$$subdir" $(AM_MAKEFLAGS) $@ ||		\
	    exit 1 ;						\
	done
	for file in $(DISTFILES) ; do				\
	  test -e "$$file" &&					\
	    echo "$(subdir)/$$file" >> $(DISTFILE_LIST) ;	\
	done ; true

# === check: check-before / check-after ===
.PHONY: check-before check-after
check-am: check-before
check-local: check-after
check-local: ; @:
TSTV1=test-verbose

# === slowcheck ===
slowcheck: slowcheck-recursive
.PHONY: slowcheck-recursive slowcheck
slowcheck-recursive:		# rule to run slowcheck recursively in subdirs
	@for subdir in $(SUBDIRS) ; do                  	\
	  test "$$subdir" = '.' ||                              \
	    $(MAKE) -C "$$subdir" $(AM_MAKEFLAGS) slowcheck ||  \
	    exit $$? ;                                          \
	done
define slowcheck_parallel_TEMPLATE
.PHONY: slowcheck_parallel--$(1)
slowcheck_parallel--$(1): $(1)
	$$(Q) $$(X11TEST_SERVER) \
	&& RAPICORN_TEST="$$(TSTV$$(V)):test-slow" ./$(1) ; _e=$$$$?; \
	  [ $$$$_e = 0 ] || { echo "FAILED($$$$_e): $(1)" ; exit $$$$_e; }
slowcheck: slowcheck_parallel--$(1)
check: @NOTDEVELMODE@ slowcheck_parallel--$(1)
endef
$(foreach PRG,$(TEST_PROGS),$(eval $(call slowcheck_parallel_TEMPLATE,$(PRG))))

# === TEST_PROGS ===
TEST_PROGS =
define check_parallel_TEMPLATE
.PHONY: check_parallel--$(1)
check_parallel--$(1): $(1)
	$$(Q) $$(X11TEST_SERVER) \
	&& RAPICORN_TEST="$$(TSTV$$(V))" ./$(1) ; _e=$$$$?; \
	  [ $$$$_e = 0 ] || { echo "FAILED($$$$_e): $(1)" ; exit $$$$_e; }
check: check_parallel--$(1)
endef
$(foreach PRG,$(TEST_PROGS),$(eval $(call check_parallel_TEMPLATE,$(PRG))))

# === LOGTEST_PROGS ===
LOGTEST_PROGS =
define check_readout_TEMPLATE
.PHONY: check_readout--$(1)
check_readout--$(1): $(1)
	$$(Q) $$(X11TEST_SERVER) \
	&& tstout="$(1).log" \
	&& RAPICORN_TEST="$$(TSTV$$(V)):test-readout" ./$(1) 2>&1 \
	| $(FIX_STDERR_FILTER) >"$$$$tstout" \
	; eval "$$$$TSTDIAGNOSE_LOGTEST" "'$(1)'" \
	; eval "$$$$TSTDIFF" "'$$(srcdir)/$(1).ref'" "'$$$$tstout'" "'$(1)'"
check: check_readout--$(1)
endef
$(foreach PRG,$(LOGTEST_PROGS),$(eval $(call check_readout_TEMPLATE,$(PRG))))
### Auto-Create refs: 	; $${FORCECHECKUPDATE} || { test -e "$$(srcdir)/$(1).ref" || touch "$$(srcdir)/$(1).ref" ; }

# === ALLTESTS ===
ALLTESTS = $(TESTS) $(TEST_PROGS) $(LOGTEST_PROGS) # used in noinst_PROGRAMS

# === Test-rule macros ===
FORCECHECKUPDATE = false
export MAKE_TARGET      = $@
export MAKE_TARGET_FILE = $(@F)
export MAKE_TARGET_DIR  = $(@D)
export FAILOK           = FAIL  OK
### eval $$TSTDIAGNOSE ['TESTNAME'] - show test title and result atomically
export TSTDIAGNOSE = _e=$$?; tstdiagnose() { printf '  CHECK  %-64s%s\n' "$${1:-$$MAKE_TARGET_FILE}:" \
				"$${FAILOK:$$(($$_e?0:6)):6}"; [ $$_e = 0 ] || exit $$_e; }; tstdiagnose
export TSTDIAGNOSE_LOGTEST = _e=$$?; tstdiagnose() { printf 'LOGTEST: %-64s%s\n' "$${1:-$$MAKE_TARGET_FILE}:" \
				"$${FAILOK:$$(($$_e?0:6)):6}"; [ $$_e = 0 ] || exit $$_e; }; tstdiagnose
### eval $$TSTDIFF ['TESTREF'] ['TESTLOG'] ['TESTNAME']
export TSTDIFF = tstverify() { \
	${FORCECHECKUPDATE} && { cp $(if $(Q),,-v) $${2:-$(TSTOUT)} $${1:-$(TSTREF)} ; FAILOK="FAIL "" FORCED" ; } ; \
	cmp --quiet $${1:-$(TSTREF)} $${2:-$(TSTOUT)} ; _e=$$? ; \
	printf '  DIFF   %-64s%s\n' "$${3:-$$MAKE_TARGET_FILE}:" "$${FAILOK:$$(($$_e?0:6)):6}" ; \
	test $$_e = 0 || { diff -up $${1:-$(TSTREF)} $${2:-$(TSTOUT)} ; exit $$_e ; } ; rm -f $${2:-$(TSTOUT)} ; \
} ; tstverify
### eval $$TSTOCR 'PNGFILE' [REGEXPATTERNS...] - OCR-grep a PNG file for regular expressions
export TSTOCR = tstocr() { IMG="$$1"; OUT=`basename "$$1".tocr`; shift; \
  gocr "$$IMG" > "$$OUT" 2>/dev/null && while [ -n "$$1" ] ; do \
  grep -qE -e "$$1" "$$OUT" ; _e=$$? ; \
  printf '  CHECK  %-64s%s\n' "$$MAKE_TARGET_FILE: $$1" "$${FAILOK:$$(($$_e?0:6)):6}" ; [ $$_e = 0 ] || exit $$_e ; \
  shift ; done || \
  printf '  CHECK  %-64s%s\n' "$$MAKE_TARGET_FILE: OCR tests with gocr(1)..." "SKIP" ; \
  rm -f "$$OUT" ; }; tstocr
# $(call TSTOUT, [postfix]) - test output filename
TSTOUT = $(strip xtst$(strip $(1))-$(@F).out)
# $(call TSTTMP, [postfix]) - temporary test filename
TSTTMP = $(strip xtst$(strip $(1))-$(@F).tmp)

# === force-check-update ===
force-check-update:
	$(MAKE) FORCECHECKUPDATE=true check


# === report ===
.PHONY: report
report: all
	@export   REPORTFILE="$(REPORTFILE)" && [ -z "$$REPORTFILE" ]		\
	&& export REPORTFILE="$(shell pwd)/report.out"				\
	; (  echo -n    "#TSTREPORT: install: "	     && date --iso-8601=seconds	\
	  && $(MAKE) $(AM_MAKEFLAGS) install 					\
	  && echo -n    "#TSTREPORT: check: "	     && date --iso-8601=seconds	\
	  && $(MAKE) $(AM_MAKEFLAGS) check 					\
	  && echo -n    "#TSTREPORT: installcheck: " && date --iso-8601=seconds	\
	  && $(MAKE) $(AM_MAKEFLAGS) installcheck				\
	  && echo -n    "#TSTREPORT: slowcheck: "    && date --iso-8601=seconds	\
	  && $(MAKE) $(AM_MAKEFLAGS) slowcheck					\
	  && echo -n    "#TSTREPORT: done: "	     && date --iso-8601=seconds	\
	) 2>&1 | tee "$$REPORTFILE"

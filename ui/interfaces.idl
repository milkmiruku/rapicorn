// Licensed GNU LGPL v3 or later: http://www.gnu.org/licenses/lgpl.html -*-mode:c++;-*-
/**
 * @file
 * @brief Rapicorn user interface API classes.
 */

namespace Rapicorn {

Const MAXINT32 = +4294967295;
Const MAXINT31 = +2147483647;
Const MININT31 = -2147483648;

/// Enum used to specify how adjustments are picked from Widget ancestry.
enum AdjustmentSourceType {
  ADJUSTMENT_SOURCE_NONE = 0,
  ADJUSTMENT_SOURCE_ANCESTRY_HORIZONTAL,
  ADJUSTMENT_SOURCE_ANCESTRY_VERTICAL,
  ADJUSTMENT_SOURCE_ANCESTRY_VALUE
};

/// Enum generally used for text paragraph alignments.
enum AlignType  {
  ALIGN_LEFT = 1,
  ALIGN_CENTER,
  ALIGN_RIGHT,
};

/// Enum to specify an anchoring point for graphical elements.
enum AnchorType {
  ANCHOR_NONE = 0,
  ANCHOR_CENTER,
  ANCHOR_EAST,
  ANCHOR_NORTH_EAST,
  ANCHOR_NORTH,
  ANCHOR_NORTH_WEST,
  ANCHOR_WEST,
  ANCHOR_SOUTH_WEST,
  ANCHOR_SOUTH,
  ANCHOR_SOUTH_EAST,
};

/// Enum to specify button click behaviour.
enum ClickType {
  CLICK_ON_PRESS = 1,
  CLICK_ON_RELEASE,
  CLICK_SLOW_REPEAT,
  CLICK_FAST_REPEAT,
  CLICK_KEY_REPEAT,
};

/// Enum used to index various predefined colors.
enum ColorType {
  COLOR_NONE = 0,
  COLOR_FOREGROUND,
  COLOR_BACKGROUND,
  COLOR_BACKGROUND_EVEN,
  COLOR_BACKGROUND_ODD,
  COLOR_DARK,
  COLOR_DARK_SHADOW,
  COLOR_DARK_GLINT,
  COLOR_LIGHT,
  COLOR_LIGHT_SHADOW,
  COLOR_LIGHT_GLINT,
  COLOR_FOCUS,
  COLOR_BLACK,
  COLOR_WHITE,
  COLOR_RED,
  COLOR_YELLOW,
  COLOR_GREEN,
  COLOR_CYAN,
  COLOR_BLUE,
  COLOR_MAGENTA,
};

/// Enum used to specify the color schemes of a Widget.
enum ColorSchemeType {
  COLOR_INHERIT = 0,    ///< Inherit color from parent component
  COLOR_NORMAL,         ///< Normal color specification
  COLOR_SELECTED,       ///< Color used for selected areas
  COLOR_BASE,           ///< Color used for text or scroll fields
};

///< Enum type for directional elements like arrows.
enum DirType {
  DIR_NONE = 0,
  DIR_RIGHT,
  DIR_UP,
  DIR_LEFT,
  DIR_DOWN,
};

///< Enum type for text ellipsization.
enum EllipsizeType {
  ELLIPSIZE_START = 1,
  ELLIPSIZE_MIDDLE,
  ELLIPSIZE_END
};

///< Enum values used to navigate the focus chain.
enum FocusDirType {
  FOCUS_NEXT = 1,
  FOCUS_PREV,
  FOCUS_RIGHT,
  FOCUS_UP,
  FOCUS_LEFT,
  FOCUS_DOWN
};

///< Enum type to discriminate various Frame widget types.
enum FrameType {
  FRAME_NONE = 0,
  FRAME_BACKGROUND,
  FRAME_IN,
  FRAME_OUT,
  FRAME_ETCHED_IN,
  FRAME_ETCHED_OUT,
  FRAME_FOCUS,
  FRAME_ALERT_FOCUS,
};

///< Enum with various lighting types.
flags enum LightingType {
  LIGHTING_NONE = 0,
  LIGHTING_UPPER_LEFT,
  LIGHTING_UPPER_RIGHT,
  LIGHTING_LOWER_LEFT,
  LIGHTING_LOWER_RIGHT,
  LIGHTING_CENTER,
  LIGHTING_DIFFUSE,
  LIGHTING_DARK_FLAG         = 0x80,
  LIGHTING_DARK_UPPER_LEFT   = LIGHTING_DARK_FLAG | LIGHTING_UPPER_LEFT,
  LIGHTING_DARK_UPPER_RIGHT  = LIGHTING_DARK_FLAG | LIGHTING_UPPER_RIGHT,
  LIGHTING_DARK_LOWER_LEFT   = LIGHTING_DARK_FLAG | LIGHTING_LOWER_LEFT,
  LIGHTING_DARK_LOWER_RIGHT  = LIGHTING_DARK_FLAG | LIGHTING_LOWER_RIGHT,
  LIGHTING_DARK_CENTER       = LIGHTING_DARK_FLAG | LIGHTING_CENTER,
  LIGHTING_DARK_DIFFUSE      = LIGHTING_DARK_FLAG | LIGHTING_DIFFUSE,
};

///< Enum type for list widget selection behaviour.
enum SelectionMode {
  SELECTION_NONE = 0,   ///< No selection possible
  SELECTION_SINGLE,     ///< Allow selection toggling of a single widget
  SELECTION_BROWSE,     ///< Browse by always forcing a single selected widget
  SELECTION_MULTIPLE,   ///< Allow arbitrary combinations of selected widgets
};

///< Enum policy type for sizing trade offs.
enum SizePolicyType {
  SIZE_POLICY_NORMAL = 0,
  SIZE_POLICY_WIDTH_FROM_HEIGHT,
  SIZE_POLICY_HEIGHT_FROM_WIDTH,
};

///< Enum type for Widget states.
flags enum StateType {
  STATE_NORMAL          = 0,
  STATE_INSENSITIVE     = 1 << 0,
  STATE_PRELIGHT        = 1 << 1,
  STATE_IMPRESSED       = 1 << 2,
  STATE_FOCUS           = 1 << 3,
  STATE_DEFAULT         = 1 << 4,
};

///< Enum type to discriminate various Text widget types.
enum TextMode {
  TEXT_MODE_WRAPPED = 1,
  TEXT_MODE_ELLIPSIZED,
  TEXT_MODE_SINGLE_LINE,
};

///< Enum type to discriminate various toplevel Window types.
enum WindowType {
  WINDOW_TYPE_NORMAL = 0,       ///< Normal window
  WINDOW_TYPE_DESKTOP,          ///< Desktop background
  WINDOW_TYPE_DOCK,             ///< Dock or panel
  WINDOW_TYPE_TOOLBAR,          ///< Torn-off toolbar
  WINDOW_TYPE_MENU,             ///< Torn-off menu
  WINDOW_TYPE_UTILITY,          ///< Palette or toolbox
  WINDOW_TYPE_SPLASH,           ///< Startup/splash screen
  WINDOW_TYPE_DIALOG,           ///< Dialog window, usually transient
  WINDOW_TYPE_DROPDOWN_MENU,    ///< Menu, opened from menubar
  WINDOW_TYPE_POPUP_MENU,       ///< Menu, opened as context menu
  WINDOW_TYPE_TOOLTIP,          ///< Transient context info window
  WINDOW_TYPE_NOTIFICATION,     ///< Transient info window (e.g. info bubble)
  WINDOW_TYPE_COMBO,            ///< Combo box menu or list window
  WINDOW_TYPE_DND,              ///< Window for dragged during DND operations
};

/// A sequence of booleans.
sequence BoolSeq { bool bools; };

/// A sequence of strings (in C++ of std::string).
sequence StringSeq { String strings; };

/** A sequence of @a Any objects.
 * An AnySeq is useful when the sequence element types need to be determined at runtime.
 */
sequence AnySeq { Any vany; };

/// A sequence of AnySeq sequence objects, useful when multiple AnySeq instances are needed.
sequence AnySeqSeq { AnySeq seq; };

/// A sequence of ARGB pixel values.
sequence PixelSeq { int32 argb; };

/** Pixbuf is a simple pixel buffer.
 * See Pixmap and PixmapT<> for convenient pixel based image manipulation.
 */
record Pixbuf {
  int32     row_length;         ///< Length of a Pixbuf row in pixels.
  PixelSeq  pixels;             ///< Pixel values in 32Bit ARGB format.
  StringSeq variables;
};

/// Base class for all interface types.
interface Object {};

/// BinadbleRelay - A server side relay to provide the BindableIface API for client objects to servants.
interface BindableRelay : Object {
  signal void relay_set  (String bpath, int64 nonce, Any value);   ///< Signal to request setting of a property.
  signal void relay_get  (String bpath, int64 nonce);              ///< Signal to request getting of a property.
  signal void relay_list (String bpath, int64 nonce);              ///< Signal to request listing of property names.
  void report_notify     (String bpath) = 0;                       ///< Notify about changes of a property.
  void report_result (int64 nonce, Any result, String error) = 0;  ///< Function to report set/get/list results.
};

/// Classification for element update request messages.
enum UpdateKind {
  UPDATE_READ,                  ///< Indicates an element range read request.
  UPDATE_CHANGE,                ///< Indicates element range changes.
  UPDATE_INSERTION,             ///< Indicates element range insertions.
  UPDATE_DELETION               ///< Indicates deletion of a range of elements.
};

/** Structure identifying an index span.
 * Specification of a span with start position and extent length.
 * The upper bound is retrieved by start + length.
 */
record UpdateSpan {
  int32 start;                  ///< Start of the span.
  int32 length;                 ///< Length of the span.
};

/** Structure describing an update for a list or table.
 * An update request specifies the kind of update, the element ranges affected and optional context variables.
 */
record UpdateRequest {
  UpdateKind kind;              ///< Classifies the update request type.
  UpdateSpan rowspan;           ///< List of rows affected.
  UpdateSpan colspan;           ///< List of columns affected.
  StringSeq  variables;         ///< Optional "key=UTF-8 string" pairs to provide auxillary information.
  Any        value;             ///< Row or cell value newly inserted, possibly sequences thereof.
};

/** A row-oriented data provider.
 * The ListModel interface serves as a row-oriented data provider for list views.
 * For many model implementations, in-order read outs should be of complexity O(1),
 * while random order read outs may be of O(log n) or even O(n).
 */
interface ListModel : Object {
  int32       count   () = 0;		        ///< Obtain the number of rows provided by this model.
  Any         row     (int32 index) = 0;        ///< Read-out row at @a index. In-order read outs are generally fastest.
  signal void updated (UpdateRequest urequest); ///< Notify about row insertions, changes and deletions.
};

/** Adapter for ListModel classes.
 * A ListModelRelay is an adapter that provides a push-API for ListModel classes.
 * This allows use of a ListModel in for example a list view, while the data to
 * be displayed is provided sparsely on demand through explicit API calls.
 */
interface ListModelRelay : Object {
  ListModel   model  () = 0;                          ///< Obtain the ListModel, bundled with this relay, to which all data is relayed.
  void        fill   (int32 first, AnySeq asq) = 0;   ///< Provide row data as requested by refill().
  signal void refill (UpdateRequest urequest);        ///< Refill requests row data for bound-first rows.
  void        update (UpdateRequest urequest) = 0;    ///< Issue model notification for row change, insertion and deletion.
};

/// Requisition information, providing requisition @a width and @a height.
record Requisition {
  float64 width;          ///< Request width.
  float64 height;         ///< Request height.
};

interface Widget;

/// A sequence of Widget objects.
sequence WidgetSeq { Widget  widgets; };

/// Widget is the base type for all UI elements.
/// See also the corresponding implementation class WidgetImpl.
interface Widget : Object {
  String          name         = String (_("Name"), _("Identification name of the widget"), "rw");
  bool            visible      = Bool (_("Visible"),   _("Whether this widget is visible"), "rw");
  bool            sensitive    = Bool (_("Sensitive"), _("Whether this widget is sensitive (receives events)"), "rw");
  ColorSchemeType color_scheme = Enum (_("Color Scheme"), _("Color scheme to render this widget"), "rw");
  /// @name User Sizes and Size Groups
  String  hsize_group = String (_("Horizontal Size Group"), _("Group name for widgets requesting the same horizontal size"), "rw");
  String  vsize_group = String (_("Vertical Size Group"), _("Group name for widgets requesting the same vertical size"), "rw");
  float64 width  = Range (_("Requested Width"),  _("The width to request from its container for this widget, -1=automatic"),  "rw", -1, MAXINT31);
  float64 height = Range (_("Requested Height"), _("The height to request from its container for this widget, -1=automatic"), "rw", -1, MAXINT31);
  Requisition requisition () = 0;               ///< Get the current effective size requisition
  /// @name Widget Packing Properties
  bool    hexpand = Bool (_("Horizontal Expand"), _("Whether to expand this widget horizontally"), "rw");
  bool    vexpand = Bool (_("Vertical Expand"),   _("Whether to expand this widget vertically"), "rw");
  bool    hspread = Bool (_("Horizontal Spread"), _("Whether to expand this widget and all its parents horizontally"), "rw");
  bool    vspread = Bool (_("Vertical Spread"),   _("Whether to expand this widget and all its parents vertically"), "rw");
  bool    hshrink = Bool (_("Horizontal Shrink"), _("Whether the widget may be shrunken horizontally"), "rw");
  bool    vshrink = Bool (_("Vertical Shrink"),   _("Whether the widget may be shrunken vertically"), "rw");
  float64 hposition = Range (_("Horizontal Position"), _("Horizontal layout position for the widget"), "Prw", 0, 99999, 5);
  float64 hspan     = Range (_("Horizontal Span"),     _("Horizontal span for widget layout"), "Prw", 1, 100000, 5);
  float64 vposition = Range (_("Vertical Position"),   _("Vertical layout position for the widget"), "Prw", 0, 99999, 5);
  float64 vspan     = Range (_("Vertical Span"),       _("Vertical span for widget layout"), "Prw", 1, 100000, 5);
  float64 hanchor = Range (_("Horizontal Anchor"), _("Horizontal position of child anchor, 0=left, 1=right"), "Prw", 0, 1, 0.5);
  float64 vanchor = Range (_("Vertical Anchor"),   _("Vertical position of child anchor, 0=bottom, 1=top"), "Prw", 0, 1, 0.5);
  float64 halign = Range (_("Horizontal Alignment"), _("Horizontal position within extra space when unexpanded, 0=left, 1=right"), "Prw", 0, 1, 0.5);
  float64 hscale = Range (_("Horizontal Scale"),     _("Fractional horizontal expansion within extra space, 0=unexpanded, 1=expanded"), "Prw", 0, 1, 0.5);
  float64 valign = Range (_("Vertical Alignment"),   _("Vertical position within extra space when unexpanded, 0=bottom, 1=top"), "Prw", 0, 1, 0.5);
  float64 vscale = Range (_("Vertical Scale"),       _("Fractional vertical expansion within extra space, 0=unexpanded, 1=expanded"), "Prw", 0, 1, 0.5);
  int32   left_spacing   = Range (_("Left Spacing"),   _("Amount of spacing to add at the widget's left side"),   "Prw", 0, 65535, 3);
  int32   right_spacing  = Range (_("Right Spacing"),  _("Amount of spacing to add at the widget's right side"),  "Prw", 0, 65535, 3);
  int32   bottom_spacing = Range (_("Bottom Spacing"), _("Amount of spacing to add at the widget's bottom side"), "Prw", 0, 65535, 3);
  int32   top_spacing    = Range (_("Top Spacing"),    _("Amount of spacing to add at the widget's top side"),    "Prw", 0, 65535, 3);
  /// @name Widget Selector API
  bool            match_selector          (String selector) = 0; ///< Check if selector matches this widget.
  Widget          query_selector          (String selector) = 0; ///< Returns first selector match.
  WidgetSeq       query_selector_all      (String selector) = 0; ///< Returns all selector matches.
  Widget          query_selector_unique   (String selector) = 0; ///< Returns single selector match if unique.
  /// @name Widget Miscellaneous
  void            data_context            (Object context) = 0;  ///< Provide context object for data Binding.
  /// @name Hosting arbitrary user data
  void            set_user_data           (String name, Any any) = 0;   ///< Store user data @a any under @a name.
  Any             get_user_data           (String name) = 0;            ///< Retrieve user data stored under @a name.
  /// @name Testing & Debugging
  String	  test_dump               () = 0;
};

/// Container is a special type of Widget that can contain other widgets.
/// See also the corresponding implementation class ContainerImpl.
interface Container : Widget {
  /// Create a child widget from the @a widget_identifier template and add it to the container.
  Widget create_widget (String widget_identifier, StringSeq args = 0) = 0;
  void   remove_widget (Widget child) = 0;
};

/** Window represents the toplevel onscreen widget.
 * A Window interface is the main user visible handle for screen objects in Rapicorn.
 * Windows can be obtained from the Application singleton. They contain UI elements
 * like buttons and text fields, and the neccessary logic for UI event processing.
 * <br/> See also the corresponding implementation class WindowImpl.
 */
interface Window : Container {
  String        title = String (_("Window Title"), _("User visible title to be displayed in the window title bar"), "rw");
  bool          auto_focus = Bool (_("Auto Focus"), _("Automatically set focus widget when the window is shown initially"), "rw");
  bool          screen_viewable         () = 0;
  void          show                    () = 0;
  bool          closed                  () = 0;
  void          close                   () = 0;
  bool          snapshot                (String     pngname) = 0;
  signal bool   commands                (String     cmdname, StringSeq args);
  signal void   displayed               ();
  bool          synthesize_click        (Widget       widget,
                                         int32        button,
                                         float64      xalign = 0.5,
                                         float64      yalign = 0.5) = 0;
  bool          synthesize_enter        (float64      xalign = 0.5,
                                         float64      yalign = 0.5) = 0;
  bool          synthesize_leave        () = 0;
  bool          synthesize_delete       () = 0;
};

/// A sequence of Window objects.
sequence WindowList { Window windows; };

/// The Arrangement layout container allows coordinate driven free form positioning of children.
/// See also the corresponding implementation class ArrangementImpl.
interface Arrangement : Container {
  float64 xorigin        = Range (_("X-Origin"), _("The x coordinate origin to be displayed by the arrangement"), "rw", -MININT31, +MAXINT31, 10);
  float64 yorigin        = Range (_("Y-Origin"), _("The y coordinate origin to be displayed by the arrangement"), "rw", -MININT31, +MAXINT31, 10);
  float64 origin_hanchor = Range (_("Horizontal Anchor"), _("Horizontal position of the origin within arrangement, 0=left, 1=right"), "rw", 0, 1, 0.1);
  float64 origin_vanchor = Range (_("Vertical Anchor"),   _("Vertical position of the origin within arrangement, 0=bottom, 1=top"),   "rw", 0, 1, 0.1);
};

/// The Alignment layout container allows adding of extra padding around its child.
/// See also the corresponding implementation class AlignmentImpl.
interface Alignment : Container {
  int32 left_padding   = Range (_("Left Padding"),   _("Amount of padding to add at the child's left side"),   "rw", 0, 65535, 3);
  int32 right_padding  = Range (_("Right Padding"),  _("Amount of padding to add at the child's right side"),  "rw", 0, 65535, 3);
  int32 bottom_padding = Range (_("Bottom Padding"), _("Amount of padding to add at the child's bottom side"), "rw", 0, 65535, 3);
  int32 top_padding    = Range (_("Top Padding"),    _("Amount of padding to add at the child's top side"),    "rw", 0, 65535, 3);
  int32 padding        = Range (_("Padding"),        _("Amount of padding to add at the child's sides"),       "wo", 0, 65535, 3);
};

/// The Frame container decorates its single child with a state dependant frame drawing.
/// See also the corresponding implementation class FrameImpl.
interface Frame : Container {
  FrameType normal_frame    = Enum (_("Normal Frame"),   _("The kind of frame to draw in normal state"), "rw");
  FrameType impressed_frame = Enum (_("Impresed Frame"), _("The kind of frame to draw in impressed state"), "rw");
  FrameType frame_type      = Enum (_("Frame Type"),     _("The kind of frame to draw in all states"), "wo");
  bool      overlap_child   = Bool (_("Overlap Child"),  _("Draw frame into child allocation"), "rw");
  FrameType current_frame () = 0; ///< Retrieve the kind of frame that is currently being displayed.
};

/// The FocusFrame container decorates its single child depending on whether its descendants have focus.
/// See also the corresponding implementation class FocusFrameImpl.
interface FocusFrame : Frame {
  FrameType focus_frame = Enum (_("Focus Frame"), _("The kind of frame to draw in focus state"), "rw");
  bool      tight_focus = Bool (_("Tight Focus"), _("Prevent extra padding around focus frames"), "rw");
};

/// The Ambience container provides its single child with state dependant background painting.
/// See also the corresponding implementation class AmbienceImpl.
interface Ambience : Container {
  String normal_background          = String (_("Normal Background"), _("The kind of background painted when normal"), "rw");
  String prelight_background        = String (_("Prelight Background"), _("The kind of background painted when prelight"), "rw");
  String impressed_background       = String (_("Impressed Background"), _("The kind of background painted when impressed"), "rw");
  String insensitive_background     = String (_("Insensitive Background"), _("The kind of background painted when insensitive"), "rw");
  LightingType normal_lighting      = Enum (_("Normal Lighting"), _("The kind of lighting painted when normal"), "rw");
  LightingType prelight_lighting    = Enum (_("Prelight Lighting"), _("The kind of lighting painted when prelight"), "rw");
  LightingType impressed_lighting   = Enum (_("Impressed Lighting"), _("The kind of lighting painted when impressed"), "rw");
  LightingType insensitive_lighting = Enum (_("Insensitive Lighting"), _("The kind of lighting painted when insensitive"), "rw");
  LightingType normal_shade         = Enum (_("Normal Shade"), _("The kind of shade painted when normal"), "rw");
  LightingType prelight_shade       = Enum (_("Prelight Shade"), _("The kind of shade painted when prelight"), "rw");
  LightingType impressed_shade      = Enum (_("Impressed Shade"), _("The kind of shade painted when impressed"), "rw");
  LightingType insensitive_shade    = Enum (_("Insensitive Shade"), _("The kind of shade painted when insensitive"), "rw");
  String       background           = String (_("Background"), _("The kind of background painted for all modes"), "wo");
  LightingType lighting             = Enum (_("Lighting"), _("The kind of lighting painted for all modes"), "wo");
  LightingType shade                = Enum (_("Shade"), _("The kind of shade painted for all modes"), "wo");
};

/// The Table layout container allows to arrange widgets in rows and columns.
/// See also the corresponding implementation class TableImpl.
interface Table : Container {
  bool  homogeneous = Bool (_("Homogeneous"), _("Whether all children get the same size"), "rw");
  int32 col_spacing = Range (_("Column Spacing"), _("The amount of space between two consecutive columns"), "rw", 0, 65535, 10);
  int32 row_spacing = Range (_("Row Spacing"), _("The amount of space between two consecutive rows"), "rw", 0, 65535, 10);
  int32 n_cols      = Range (_("Number of Columns"), _("The number of columns available in this table to attach children"), "rw", 0, MAXINT31, 1);
  int32 n_rows      = Range (_("Number of Rows"), _("The number of rows available in this table to attach children"), "rw", 0, MAXINT31, 1);
  bool  is_col_used (int32 col) = 0; ///< Find out if any child allocates the specified column.
  bool  is_row_used (int32 row) = 0; ///< Find out if any child allocates the specified row.
  void  resize      (int32 n_cols, int32 n_rows) = 0;    ///< Resize columns and rows, but accomodate for space needed by children.
  void  insert_cols (int32 first_col, int32 n_cols) = 0; ///< Insert a number of columns, shifting or stretching children as needed.
  void  insert_rows (int32 first_row, int32 n_rows) = 0; ///< Insert a number of rows, shifting or stretching children as needed.
};

/** The ButtonArea interface provides an area with the ability to process button clicks.
 * Arbitraty actions can be associated with button1, button2 and button3 clicks to be caried
 * out when the respective mouse button is clicked.
 * <br/> See also the corresponding implementation class ButtonAreaImpl.
 */
interface ButtonArea : Container {
  ClickType     click_type      = Enum (_("CLick Type"), _("Click event generation type"), "rw");
  String	on_click	= String (_("On CLick"), _("Action to carry out on button1 clicks."), "rw");
  String	on_click2	= String (_("On CLick"), _("Action to carry out on button2 clicks."), "rw");
  String	on_click3	= String (_("On CLick"), _("Action to carry out on button3 clicks."), "rw");
};

/** Widget containing a list of selectable widgets.
 * List widget is a widget that displays a list of widgets generated according to a data source.
 * <br/> See also the corresponding implementation class WidgetListImpl.
 */
interface WidgetList : Container {
  String        model           = String (_("Model"), _("Source locator for the data to be displayed."), "rw");
  SelectionMode selection_mode  = Enum (_("Selection Mode"), _("None - allow no selected rows<br/>"
                                                               "Single - allow a single selected row<br/>"
                                                               "Browse - always select a single row<br/>"
                                                               "Multiple - allow any row selection combinations<br/>"),
                                        "rw");
  void          set_selection  (BoolSeq selection) = 0;
  BoolSeq       get_selection  () = 0;
  void          select_range   (int32 first, int32 length) = 0;
  void          unselect_range (int32 first, int32 length) = 0;
};

/// The Arrow widget paints a single arrow with configurable direction.
/// See also the corresponding implementation class ArrowImpl.
interface Arrow : Widget {
  DirType        arrow_dir   = Enum (_("Arrow Direction"), _("The direction the arrow points to"), "rw");
  SizePolicyType size_policy = Enum (_("Size Policy"),     _("Policy which determines coupling of width and height"), "rw");
};

/// The DotGrid widget paints a configurable set of dots arranged in a grid.
/// See also the corresponding implementation class DotGridImpl.
interface DotGrid : Widget {
  FrameType normal_dot      = Enum (_("Normal Dot"), _("The kind of dot-frame to draw in normal state"), "rw");
  FrameType impressed_dot   = Enum (_("Impresed Dot"), _("The kind of dot-frame to draw in impressed state"), "rw");
  FrameType dot_type        = Enum (_("Dot Type"), _("The kind of dot-frame to draw in all states"), "wo");
  int32 n_hdots             = Range (_("H-Dot #"), _("The number of horizontal dots to be drawn"), "rw", 0, 99999, 3);
  int32 n_vdots             = Range (_("V-Dot #"), _("The number of vertical dots to be drawn"), "rw", 0, 99999, 3);
  int32 right_padding_dots  = Range (_("Right Padding Dots"), _("Amount of padding in dots to add at the child's right side"), "rw", 0, 65535, 3);
  int32 top_padding_dots    = Range (_("Top Padding Dots"), _("Amount of padding in dots to add at the child's top side"), "rw", 0, 65535, 3);
  int32 left_padding_dots   = Range (_("Left Padding Dots"), _("Amount of padding in dots to add at the child's left side"), "rw", 0, 65535, 3);
  int32 bottom_padding_dots = Range (_("Bottom Padding Dots"), _("Amount of padding in dots to add at the child's bottom side"), "rw", 0, 65535, 3);
  FrameType current_dot () = 0; ///< Retrieve the kind of dot that is currently being displayed.
};

/** The Drawable widget allows display of custom graphics.
 * A Drawable widget allows client-side rendering by emitting the redraw() signal when updates are needed.
 * The draw_rect() method is used to draw into the widget display.
 * <br/> See also the corresponding implementation class DrawableImpl.
 */
interface Drawable : Widget {
  signal void redraw    (int32 x, int32 y, int32 w, int32 h);   ///< Requests a redraw at @a width and @a height.
  void	      draw_rect	(int32 x, int32 y, Pixbuf pixbuf) = 0;  ///< Draws pixels on the drawable display.
};

/// Image widgets are used to display pixel or vector images.
/// See also the corresponding implementation class ImageImpl.
interface Image : Widget {
  String        source  = String (_("Source URL"), _("Resource or file URL to load the image from."), "rw");
  Pixbuf        pixbuf;
};

/** Application singleton.
 * For each Rapicorn program, there exists one global Application singleton.
 * All general program operations are provided by the Application interface,
 * such as the facility to create Window objects on the screen.
 * <br/> See also the corresponding implementation class ApplicationImpl.
 * @nosubgrouping
 */
interface Application : Object {
  /// @name Application Startup
  String        auto_path       (String         file_name,
                                 String         binary_path,
                                 bool           search_vpath = true) = 0;
  StringSeq     auto_load       (String         defs_domain,
                                 String         file_name,
                                 String         binary_path,
                                 String         i18n_domain = "") = 0;
  bool          factory_window  (String         factory_definition);
  void          load_string     (String         defs_domain,
                                 String         xml_string,
                                 String         i18n_domain = "") = 0;
  /// @name Window handling
  Window        create_window   (String window_identifier, StringSeq arguments = 0) = 0; ///< Create a hidden window with children.
  bool          finishable      ();                     ///< Indicates whether all windows and other primary event sources are gone.
  signal void   missing_primary ();                     ///< Indicates the Application entering finishable() state.
  void          close_all       () = 0;                 ///< Forces closing of all windows.
  Window        query_window    (String selector) = 0;  ///< Returns first Window match for @a selector.
  WindowList    query_windows   (String selector) = 0;  ///< Returns all Window matches for @a selector.
  WindowList    list_windows    () = 0;
  /// @name Application Factory
  BindableRelay create_bindable_relay    () = 0;        ///< Create a BindableRelay, usually for uses in @a data_context.
  /// Create a ListModelRelay coupled with a ListModel registered as @a name.
  ListModelRelay create_list_model_relay (String name = "") = 0;
  /// @name Test counter for debugging/profiling
  void          test_counter_set        (int32 val) = 0;  ///< Testing, set the test counter.
  void          test_counter_add        (int32 val) = 0;  ///< Testing, add to the test counter.
  int32         test_counter_get        () = 0;           ///< Testing, retrieve the test counter value.
  int32         test_counter_inc_fetch  () = 0;           ///< Testing, increment and return the resulting test counter value.
  int64         test_hook               () = 0;
};

/// An enum used exclusively for unit testing.
enum TestEnum {
  TEST_ENUM_VALUE1,
  TEST_ENUM_VALUE2,
  TEST_ENUM_VALUE3,
};

/// A widget used exclusively for unit testing.
/// See also the corresponding implementation class IdlTestWidgetImpl.
interface IdlTestWidget : Widget {
  bool           bool_prop;
  int32          int_prop;
  float64        float_prop;
  String         string_prop;
  TestEnum       enum_prop;
  Requisition    record_prop;
  StringSeq      sequence_prop;
  IdlTestWidget  self_prop;
};

} // Rapicorn
